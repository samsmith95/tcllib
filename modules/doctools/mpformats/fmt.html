# -*- tcl -*-
#
# fmt.html
#
# Copyright (c) 2001-2003 Andreas Kupries <andreas_kupries@sourceforge.net>
#
# Definitions to convert a tcl based manpage definition into
# a manpage based upon HTML markup.
#
################################################################
################################################################

dt_source _common.tcl   ; # Shared code
dt_source _html.tcl     ; # HTML basic formatting

proc c_copyrightsymbol {} {markup "&copy;"}

proc bgcolor {} {return ""}
proc border  {} {return 0}
proc Year    {} {clock format [clock seconds] -format %Y}

# possibleReference text gi --
#	Check if $text is a potential cross-reference;
#	if so, format as a reference;
#	otherwise format as a $gi element.
#
proc c_possibleReference {text gi} {
    global SectionNames
    set id [c_sectionId $text]
    if {[info exists SectionNames($id)]} {
	return [link $text "#$id"]
    } else {
	return [tag_ $gi $text]
    }
}

c_holdBuffers require

################################################################
## Backend for HTML markup

# --------------------------------------------------------------
# Handling of lists. Simplified, the global check of nesting and
# legality of list commands allows us to throw away most of the
# existing checks.

global liststack ; # stack of list tags to use in list_end
global hintstack ; # stack of hint information.
global chint     ; # current hint settings
global lmark     ; # boolean flag, 1 = list item command was last
#                ; #               0 = something other than a list item command

set    liststack [list]
set    hintstack [list]
set    chint     ""
set    lmark     0
set    prev_litem_close   {} ;# Piece of html to close the previous list element, if any.
#                   ;# Saved on the stack!

proc llevel {} {global liststack ; return [llength $liststack]}

proc lpush {t hint} {
    global  liststack hintstack chint prev_litem_close
    lappend liststack [list [tag/ $t] $prev_litem_close]
    lappend hintstack $chint
    set     chint $hint
    set prev_litem_close {}
    return [tag $t]
}

proc lpop {} {
    global liststack hintstack chint prev_litem_close
    set t         [lindex   $liststack end]
    set liststack [lreplace $liststack end end]
    set chint     [lindex   $hintstack end]
    set hintstack [lreplace $hintstack end end]
    foreach {t prev_litem_close} $t break
    return $t
}

proc lsmark {value} {
    global lmark ; set lmark $value ; return
}

proc limark {} {
    # hint and mark processing.
    # hint: compact list, do not create additional whitespace
    if {[lcompact]} {return ""}

    # hint: wide list, create additional whitespace.
    # mark: exception: two list items following each other have no whitespace.
    global lmark ; if {$lmark} {return ""}
    return [tag br][tag br]\n
}

proc lcompact {} {global chint ; string equal $chint compact}

proc fmt_plain_text {text} {
    # Control list state
    set redux [string map [list " " "" "\t" "" "\n" ""] $text]
    if {$redux != {}} {lsmark 0}
    return $text
}

################################################################
# Formatting commands.

c_pass 1 fmt_manpage_begin {title section version} {c_cinit ; c_clrSections ; return}
c_pass 2 fmt_manpage_begin {title section version} {
    XrefInit
    c_cinit
    set module      [dt_module]
    set shortdesc   [c_get_module]
    set description [c_get_title]
    set copyright   [c_get_copyright]

    set     hdr ""
    append  hdr [tag html] [tag head] \n
    append  hdr [tag_ title "$title - $shortdesc"] \n

    # Engine parameter - insert 'meta'
    Extend hdr meta

    append  hdr [tag/ head] \n
    append  hdr [ht_comment [c_provenance]]\n
    if {$copyright != {}} {
	append  hdr [ht_comment $copyright]\n
    }
    append  hdr [ht_comment "CVS: \$Id\$ $title.$section"]
    append  hdr \n\n
    append  hdr [tag body] [tag* div id doctools] \n

    # Engine parameter - insert 'header'
    Extend hdr header

    append  hdr [tag_ h1 "[string trimleft $title :]($section) $version $module \"$shortdesc\""] \n
    append  hdr [fmt_section NAME]\n
    append  hdr "[para_open] $title - $description"
    return $hdr
}

c_pass 1 fmt_moddesc   {desc} {c_set_module $desc}
c_pass 2 fmt_moddesc   {desc} NOP

c_pass 1 fmt_titledesc {desc} {c_set_title $desc}
c_pass 2 fmt_titledesc {desc} NOP

c_pass 1 fmt_copyright {desc} {c_set_copyright $desc}
c_pass 2 fmt_copyright {desc} NOP

c_pass 1 fmt_manpage_end {} {c_creset ; return}
c_pass 2 fmt_manpage_end {} {
    c_creset
    set res ""

    set sa [c_xref_seealso]
    set kw [c_xref_keywords]
    set ct [c_get_copyright]

    if {[llength $sa] > 0} {
	append res [fmt_section {SEE ALSO}] \n
	append res [join [XrefList [lsort $sa] sa] ", "] \n
    }
    if {[llength $kw] > 0} {
	append res [fmt_section KEYWORDS] \n
	append res [join [XrefList [lsort $kw] kw] ", "] \n
    }
    if {$ct != {}} {
	append res [fmt_section COPYRIGHT] \n
	append res [join [split $ct \n] [tag br]\n] [tag br]\n
    }

   # Close last paragraph, subsection, and section.
    append res [para_close][subsec_close][sec_close]

    # Engine parameter - insert 'footer'
    Extend res footer

    append res [tag/ div] [tag/ body] [tag/ html]
    return $res
}

c_pass 1 fmt_section {name} {c_newSection $name 1 end}
c_pass 2 fmt_section {name} {
    set id [c_sectionId $name]
    return "[sec_open $id][markup <h2><]a name=[markup \"]$id[markup \">]$name[markup </a></h2>]\n[para_open]"
}

c_pass 1 fmt_subsection {name} {c_newSection $name 2 end}
c_pass 2 fmt_subsection {name} {
    set id [c_sectionId $name]
    return "[subsec_open $id][markup <h3><]a name=[markup \"]$id[markup \">]$name[markup </a></h3>]\n[para_open]"
}

proc fmt_para {} {para_open}

c_pass 2 fmt_require {pkg {version {}}} NOP
c_pass 1 fmt_require {pkg {version {}}} {
    set result "package require [markup <b>]$pkg"
    if {$version != {}} {
	append result " $version"
    }
    append result [markup "</b><br>"]
    c_hold require $result
    return
}

c_pass 2 fmt_usage {cmd args} NOP
c_pass 1 fmt_usage {cmd args} {
    if {[llength $args]} {
	set text "$cmd [join $args " "]"
    } else {
	set text $cmd
    }
    c_hold synopsis "[trtop][td]$text[markup </td></tr>]"
}

c_pass 1 fmt_call {cmd args} {
    if {[llength $args]} {
	set text "$cmd [join $args " "]"
    } else {
	set text $cmd
    }
    c_hold synopsis "[trtop][td][link $text "#[c_cnext]"][markup </td></tr>]"
}
c_pass 2 fmt_call {cmd args} {
    if {[llength $args]} {
	set text "$cmd [join $args " "]"
    } else {
	set text $cmd
    }
    return "[fmt_lst_item [anchor [c_cnext] $text]]\n"
}

c_pass 1 fmt_description {} NOP
c_pass 2 fmt_description {} {
    set result ""
    set syn [c_held synopsis]
    set req [c_held require]

    # Create the TOC.

    # Pass 1: We have a number of special sections which were not
    #         listed explicitly in the document sources. Add them
    #         now. Note the inverse order for the section added
    #         at the beginning.

    c_newSection DESCRIPTION 1 0
    if {$syn != {} || $req != {}} {c_newSection SYNOPSIS 1 0}
    c_newSection {TABLE OF CONTENTS} 1 0

    if {[llength [c_xref_seealso]] > 0}  {c_newSection {SEE ALSO} 1 end}
    if {[llength [c_xref_keywords]] > 0} {c_newSection KEYWORDS   1 end}
    if {[c_get_copyright]         != {}} {c_newSection COPYRIGHT  1 end}

    set sections $::SectionList

    # Pass 2: Generate the markup for the TOC, indenting the
    #         links according to the level of the section.

    append result [fmt_section {TABLE OF CONTENTS}]

    foreach {name id level} $sections {
	append result \
	    [markup [string repeat "&nbsp;&nbsp;&nbsp;&nbsp;" $level]] \
	    [link $name "#$id"] [tag br] \n
    }

    # Implicit sections coming after the TOC (Synopsis, then the
    # description which starts the actual document). The other
    # implict sections are added at the end of the document and
    # are generated by 'fmt_manpage_end' in the second pass.

    if {$syn != {} || $req != {}} {
	append result [fmt_section SYNOPSIS]\n
    }
    if {$req != {}} {
	append result $req \n [tag br]
    }
    if {$syn != {}} {
	proc bgcolor {} {return lightyellow}

	append result \
	    [btable] [tr] [td] [table] \
	    $syn \n \
	    [tag/ table] [tag/ td] [tag/ tr] [tag/ table] \n

	proc bgcolor {} {return ""}
    }
    append result [fmt_section DESCRIPTION]
    return $result
}

################################################################

proc fmt_list_begin  {what {hint {}}} {
    switch -exact -- $what {
	enumerated  {set tag ol}
	itemized    {set tag ul}
	arguments -
	commands  -
	options   -
	tkoptions -
	definitions {set tag dl}
    }
    return [para_close][if {[llevel]} {limark} else {}][lpush $tag $hint][lsmark 1]
}

proc fmt_list_end {}        {
    global prev_litem_close
    set res $prev_litem_close[lpop][lsmark 1][para_open]
    set prev_litem_close {}
    return $res
}
proc fmt_lst_item {text}    {
    global prev_litem_close
    set res [limark]$prev_litem_close[tag dt]$text[tag/ dt][tag dd][lsmark 1]
    set prev_litem_close [tag/ dd]
    return $res
}
proc fmt_bullet {} {
    global prev_litem_close
    set res [limark]$prev_litem_close[tag li][lsmark 1]
    set prev_litem_close [tag/ li]
    return $res
}
proc fmt_enum {} {
    global prev_litem_close
    set res [limark]$prev_litem_close[tag li][lsmark 1]
    set prev_litem_close [tag/ li]
    return $res
}
proc fmt_cmd_def  {command} {fmt_lst_item [fmt_cmd $command]}

proc fmt_arg_def {type name {mode {}}} {
    set    text ""
    append text $type " " [fmt_arg $name]
    if {$mode != {}} {
	append text " (" $mode ")"
    }
    fmt_lst_item $text
}
proc fmt_opt_def {name {arg {}}} {
    set text [fmt_option $name]
    if {$arg != {}} {append text " " $arg}
    fmt_lst_item $text
}
proc fmt_tkoption_def {name dbname dbclass} {
    set    text ""
    append text "Command-Line Switch:\t[fmt_option $name][tag br]\n"
    append text "Database Name:\t[bold $dbname optdbname][tag br]\n"
    append text "Database Class:\t[bold $dbclass optdbclass][tag br]\n"
    fmt_lst_item $text
}


################################################################

proc fmt_example_begin {} {
    lsmark 0
    return [para_close][tag* div class example][tag table][tag tr][tag_ td [markup "&nbsp;"] bgcolor black][tag td][tag* pre class sample]
}
proc fmt_example_end   {} {
    return [tag/ pre][tag/ td][tag/ tr][tag/ table][tag/ div][para_open]
}
proc fmt_example {code} {
    return "[fmt_example_begin][fmt_plain_text $code][fmt_example_end]"
}

proc fmt_nl {} {
    if {[lcompact]} {return [tag br]}
    return [tag br][tag br]
}
proc fmt_arg  {text} { italic $text                arg }
proc fmt_cmd  {text} { bold   [XrefMatch $text sa] cmd }
proc fmt_emph {text} { em     $text }
proc fmt_opt  {text} { span   "?$text?" opt }

proc fmt_comment {text} {ht_comment $text}
proc fmt_sectref {text {label {}}} {
    global SectionNames
    if {![string length $label]} {set label $text}
    set id [c_sectionId $text]
    if {[info exists SectionNames($id)]} {
    	return [span [link $label "#$id"] sectref]
    } else {
	return [bold $label sectref]
    }
}

proc fmt_syscmd  {text} {bold [XrefMatch $text sa] syscmd}
proc fmt_method  {text} {bold $text method}
proc fmt_option  {text} {bold $text option}
proc fmt_widget  {text} {bold $text widget}
proc fmt_fun     {text} {bold $text function}
proc fmt_type    {text} {bold $text type}
proc fmt_package {text} {bold [XrefMatch $text sa kw] package}
proc fmt_class   {text} {bold $text class}
proc fmt_var     {text} {bold $text variable}
proc fmt_file    {text} {return "\"[bold $text file]\""}
proc fmt_namespace     {text} {bold $text namespace}
proc fmt_uri     {text {label {}}} {
    if {$label == {}} {set label $text}
    return [link $label $text]
}
proc fmt_term    {text} {italic [XrefMatch $text kw sa] term}
proc fmt_const   {text} {bold $text const}

################################################################

global sec_is_open
set    sec_is_open 0

proc sec_open  {id} {
    global sec_is_open
    set res [para_close][subsec_close][sec_close][tag* div id $id class section]
    set sec_is_open 1
    return $res
}

proc sec_close {}   {
    global sec_is_open
    if {!$sec_is_open} {return ""}
    set sec_is_open 0
    return [tag/ div]\n
}

################################################################

global subsec_is_open
set    subsec_is_open 0

proc subsec_open  {id} {
    global subsec_is_open
    set res [para_close][subsec_close][tag* div id $id class subsection]
    set subsec_is_open 1
    return $res
}

proc subsec_close {}   {
    global subsec_is_open
    if {!$subsec_is_open} {return ""}
    set subsec_is_open 0
    return [tag/ div]\n
}

################################################################

global para_is_open
set    para_is_open 0

proc para_open {} {
    global para_is_open
    set res [para_close][tag p]
    set para_is_open 1
    return $res
}

proc para_close {} {
    global para_is_open
    if {!$para_is_open} {return ""}
    set para_is_open 0
    return [tag/ p]\n
}

################################################################

global xref ; array set xref {}

global    __var
array set __var {
    meta   {}
    header {}
    footer {}
    xref   {}
}
proc Get               {varname}      {global __var ; return $__var($varname)}
proc fmt_listvariables {}             {global __var ; return [array names __var]}
proc fmt_varset        {varname text} {
    global __var
    if {![info exists __var($varname)]} {return -code error "Unknown engine variable \"$varname\""}
    set __var($varname) $text
    return
}

# Engine parameter handling
proc Extend {v by} {
    set html [Get $by]
    if {$html == {}} return
    upvar 1 $v text
    append text [markup $html] \n
    return
}

################################################################

proc XrefInit {} {
    global xref __var
    foreach item $__var(xref) {
	foreach {pattern fname fragment} $item break
	set fname_ref [dt_fmap $fname]
	if {$fragment != {}} {append fname_ref #$fragment}
	set xref($pattern) $fname_ref
    }
    proc XrefInit {} {}
    return
}

proc XrefMatch {word args} {
    global xref

    foreach ext $args {
	if {$ext != {}} {
	    if {[info exists xref($ext,$word)]} {
		return [XrefLink $xref($ext,$word) $word]
	    }
	}
    }
    if {[info exists xref($word)]} {
	return [XrefLink $xref($word) $word]
    }

    # Convert the word to all-lower case and then try again.

    set lword [string tolower $word]

    foreach ext $args {
	if {$ext != {}} {
	    if {[info exists xref($ext,$lword)]} {
		return [XrefLink $xref($ext,$lword) $word]
	    }
	}
    }
    if {[info exists xref($lword)]} {
	return [XrefLink $xref($lword) $word]
    }

    return $word
}

proc XrefList {list {ext {}}} {
    set res [list]
    foreach w $list {lappend res [XrefMatch $w $ext]}
    return $res
}

proc XrefLink {dest label} {
    # Ensure that the link is properly done relative to this file!

    set save $dest

    #puts_stderr "XrefLink $dest $label"

    set here [file split [dt_fmap [dt_file]]]
    set dest [file split $dest]

    #puts_stderr "XrefLink < $here"
    #puts_stderr "XrefLink > $dest"

    while {[string equal [lindex $dest 0] [lindex $here 0]]} {
	set dest [lrange $dest 1 end]
	set here [lrange $here 1 end]
	if {[llength $dest] == 0} {break}
    }
    set ul [llength $dest]
    set hl [llength $here]

    if {$ul == 0} {
	set dest [lindex [file split $save] end]
    } else {
	while {$hl > 1} {
	    set dest [linsert $dest 0 ..]
	    incr hl -1
	}
	set dest [eval file join $dest]
    }

    #puts_stderr "XrefLink --> $dest"
    return [link $label $dest]
}
