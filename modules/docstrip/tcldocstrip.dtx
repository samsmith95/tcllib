%
% \iffalse
%<*driver>
\documentclass{tclldoc}
\begin{document}
\DocInput{tcldocstrip.dtx}
\end{document}
%</driver>
% \fi
% 
% \title{The \textsf{docstrip} \Tcllogo\ package}
% \author{Lars Hellstr\"om}
% \date{10 January 2005}
% \maketitle
% 
% \begin{abstract}
%   The \textsf{docstrip} package provides a pure-\Tcllogo\ 
%   implementation of some of the functionality of the \LaTeX\ 
%   \textsc{docstrip} program. In particular, there is a command 
%   using which one can |source| \Tcllogo\ code from within a 
%   \texttt{.dtx} file.
% \end{abstract}
% 
% \changes{1.0}{2004/09/17}{Changing namespace to \texttt{docstrip} and 
%   also all command names. (LH)}
% 
% 
% \section{Usage}
% 
% \subsection{\textsf{docstrip} package}
% 
% The simplest usage of the \textsf{docstrip} package is to source 
% \Tcllogo\ code from within a \texttt{.dtx} file without having to 
% generate any stripped file first. The command that does this is
% \describestring[proc][docstrip]{sourcefrom}|docstrip::sourcefrom|, 
% which has the syntax
% \begin{quote}
%   |docstrip::sourcefrom| \word{filename} \word{terminals} 
%   \begin{regblock}[\regstar]\word{option} \word{value}\end{regblock}
% \end{quote}
% where \word{filename} is the source file name. The \word{terminals} 
% is the list of guard expression terminals that should be considered 
% true; the \textsc{docstrip} program calls these the ``options'' for 
% the source file. The \word{option} and \word{value} arguments are 
% passed on to |fconfigure|, to configure the file before |read|ing 
% it.
% 
% A typical usage is
% \begin{quote}
%   |docstrip::sourcefrom foobar.dtx {foo debug}|
% \end{quote}
% which corresponds to |source|ing the file \texttt{temp.tcl} that 
% would be generated by
% \begin{quote}
%   |\generate{\file{temp.tcl}{\from{foobar.dtx}{foo,debug}}}|
% \end{quote}
% A more advanced usage (making use of the ability to |fconfigure| the 
% source file before reading it) is
% \begin{quote}
%   |docstrip::sourcefrom ruslish.dtx pkg -encoding koi8-r|
% \end{quote}
% which ensures that the file is interpreted as being 
% \texttt{koi8-r} encoded.
% 
% \iffalse
% (Files which require an encoding specification can actually be tricky 
% to handle using the \textsc{docstrip} program, since most \TeX's will 
% by default write \TeX-style |^^|-escapes for all characters outside 
% visible ASCII, but the \textsf{docstrip} package handles such matters 
% easily.)
% \fi
% 
% The \textsf{docstrip} package can even be used in 
% \texttt{pkgIndex.tcl} scripts. The typical pattern is\pagebreak[2]
%\begin{verbatim}
%   package ifneeded foo 1.0 [format {
%      package require docstrip
%      docstrip::sourcefrom [file join %s foobar.dtx] foo
%   } [list $dir]]
%   package ifneeded bar 0.2 [format {
%      package require docstrip
%      docstrip::sourcefrom [file join %s foobar.dtx] bar
%   } [list $dir]]
%\end{verbatim}
% where |format| is used to embed the package directory into the 
% |package ifneeded| scripts. |list| provides the right amount of 
% quoting of the directory string.
% 
% The semantics of |sourcefrom| closely follows those of |source|: The 
% code is evaluated in the local context of the caller, a |return| will 
% abort the sourcing early, and |info script| will return the 
% \word{filename} for the duration of the |sourcefrom|. A difference is 
% that |sourcefrom| does not stop at |\u001a| characters (control-Z, 
% end of file). Also note that the entire file is ``docstripped'' 
% before any of the code in it gets evaluated, so e.g. module nesting 
% errors at the end of the file cannot be hidden by an early |return| 
% in it.
% 
% The actual ``docstripping'' is done by the 
% \describestring[proc][docstrip]{extract}|docstrip::extract| command, 
% which has the syntax
% \begin{quote}
%   |docstrip::extract| \word{text} \word{terminals}
%   \begin{regblock}[\regstar]\word{option} 
%   \word{value}\end{regblock}
% \end{quote}
% Unlike the \textsc{docstrip} program, which is file-oriented, this 
% command takes the \word{text} to extract code from as an argument and 
% returns the code that was extracted. The \word{terminals} is as for 
% |sourcefrom| the list of guard expression terminals that should have 
% the value true. 
% 
% The options are
% \begin{quote}
%   |-metaprefix| \word{string}\\
%   |-onerror| \begin{regblock}|throw|\regalt |puts|\regalt
%     |ignore|\end{regblock}\\
%   |-trimlines| \word{boolean}
% \end{quote}
% These control some fine details of the extraction process. See 
% Section~\ref{Sec:Extract} for further information.
% 
% The |extract| command does not as the \textsc{docstrip} program 
% wrap the extracted code up with a preamble and postamble; it just 
% handles the basic extraction, not the higher level operation of 
% complete file generation.
% 
% 
% \subsection{\textsf{docstrip::util} package}
% 
% The \textsf{docstrip::util} package is meant for collecting various 
% utility procedures that may be useful for developers who make use of 
% the \textsf{docstrip} package in some projects. It is separate from 
% the main package to avoid overhead for end-users.
% 
% Currently the only command in this package is the |ddt2man| command. 
% It provides an alternative to \LaTeX\ markup for programmers who 
% think \LaTeX\ is too heavy (e.g.\ installation-wise) and prefer a 
% pure-\Tcllogo\ documentation setup, namely to use 
% \textsf{doctools}~\cite{doctools_fmt} man page markup. This is 
% nowhere near as powerful as \LaTeX, but may well suffice in cases 
% with less sophisticated typographical requirements.
% 
% \describestring[proc][docstrip::util]{ddt2man}
% Since \textsf{doctools} cannot be configured to process 
% docstrip-style master sources directly, a conversion to some format 
% that can be processed is necessary, and that is precisely what the 
% |ddt2man| command does. The syntax is
% \begin{quote}
%   |docstrip::util::ddt2man| \word{ddt-text}
% \end{quote}
% where \word{ddt-text} is the contents of a master source code file 
% and the result is the same text reformatted as \textsf{doctools} 
% man page source. The command name comes from the recommended file 
% suffixes: \textsf{doctools} man pages have the suffix \texttt{.man} 
% and master source files with \textsf{doctools} markup in the comments 
% should use the suffix \texttt{.ddt} to distinguish them from 
% \texttt{.dtx} files which have \LaTeX\ markup in the comments.
% 
% 
% 
% \section{Headers}
% 
% The package headers are nothing unusual. \Tcllogo~8.4 is required 
% because |info script| with an argument is used by the |sourcefrom| 
% command, and there are also some uses of the |eq| operator in |if| 
% expressions.
% \begin{tcl}
%<*pkg>
package require Tcl 8.4
package provide docstrip 1.0
namespace eval docstrip {}
%</pkg>
%<*utilpkg>
package require Tcl 8.4
package provide docstrip::util 1.0
namespace eval docstrip::util {}
%</utilpkg>
% \end{tcl}
% \setnamespace{docstrip}
% 
% The test initialisation is nothing strange either. The route is taken 
% to explicitly |source| the \texttt{docstrip.tcl} file in the same 
% directory as the \texttt{docstrip.test} being run.
% \begin{tcl}
%<*test>
package require tcltest
source [file join [pwd] [file dirname [info script]] docstrip.tcl]
puts "** Tcl docstrip package (v [package provide docstrip]) **"
% \end{tcl}
% One of the tests require that \texttt{tcldocstrip.dtx} (this file) and 
% \texttt{docstrip.tcl} are both present. A \textsf{tcltest} constraint 
% is declared for this purpose.
% \begin{tcl}
tcltest::testConstraint docstripSourcesAvailable [expr {[
   file exists\
     [file join [pwd] [file dirname [info script]] docstrip.tcl]
] && [
   file exists\
     [file join [pwd] [file dirname [info script]] tcldocstrip.dtx]
]}]
%</test>
% \end{tcl}
% 
% Finally the header for the \textsf{doctools} manpages.
% \begin{tcl}
%<*man,utilman>
%<man>[manpage_begin docstrip n 1.0]
%<utilman>[manpage_begin docstrip_util n 1.0]
[copyright "2003-2005 Lars Hellstr\u00F6m\
  <Lars dot Hellstrom at math dot umu dot se>"]
[moddesc {Literate programming tool}]
%<man>[titledesc {Docstrip style source code extraction}]
%<utilman>[titledesc {Docstrip-related utilities}]
[require Tcl 8.4]
%<man>[require docstrip [opt 1.0]]
%<utilman>[require docstrip::util [opt 1.0]]
[description]
%</man,utilman>
% \end{tcl}
% 
% 
% \section{Manpage source}
% 
% The main package manpage is in four sections: introduction, 
% description of the format of files to be processed by 
% \textsc{docstrip}, description of commands, and basic remarks on 
% overall document structure. Since command descriptions and 
% implementations appear in the same sections of the \texttt{.dtx} 
% file, a big batch of manpage source has to appear first.
% 
% The introduction is indended for \Tcllogo\ programmers who have not
% previously encountered \textsc{docstrip}---hence it is probably a 
% bit boring for experienced \LaTeX\ programmers.
%    \begin{macrocode}
%<*man>

[syscmd Docstrip] is a tool created to support a brand of Literate 
Programming. It is most common in the (La)TeX community, where it 
is being used for pretty much everything from the LaTeX core and up, 
but there is nothing about [syscmd docstrip] which prevents using it 
for other types of software.
[para]

In short, the basic principle of literate programming is that program 
source should primarily be written and structured to suit the 
developers (and advanced users who want to peek "under the hood"), not 
to suit the whims of a compiler or corresponding source code consumer. 
This means literate sources often need some kind of "translation" to an 
illiterate form that dumb software can understand. 
The [package docstrip] Tcl package handles this translation.
[para]

Even for those who do not whole-hartedly subscribe to the philosophy 
behind literate programming, [syscmd docstrip] can bring greater 
clarity to in particular:
[list_begin bullet]
  [bullet] programs employing non-obvious mathematics
  [bullet] projects where separate pieces of code, perhaps in 
    different languages, need to be closely coordinated.
[list_end]
The first is by providing access to much more powerful typographical 
features for source code comments than are possible in plain text. 
The second is because all the separate pieces of code can be kept 
next to each other in the same source file.
[para]

The way it works is that the programmer edits directly only one or 
several "master" source code files, from which [syscmd docstrip] 
generates the more traditional "source" files compilers or the like 
would expect. The master sources typically contain a large amount of 
documentation of the code, sometimes even in places where the code 
consumers would not allow any comments. The etymology of "docstrip" 
is that this [emph doc]umentation was [emph strip]ped away (although 
"code extraction" might be a better description, as it has always 
been a matter of copying selected pieces of the master source rather 
than transforming it). 
The [package docstrip] Tcl package contains a reimplementation of 
the basic extraction functionality from the [syscmd docstrip] 
program, and thus makes it possible for a Tcl interpreter to read 
and interpret the master source files directly.
[para]

Readers who are not previously familiar with [syscmd docstrip] but 
want to know more about it may consult the following sources.
[list_begin enum]
[enum]
  [emph {The tclldoc package and class}],
  [uri {http://tug.org/tex-archive/macros/latex/contrib/tclldoc/}].
[enum]
  [emph {The DocStrip utility}],
  [uri {http://tug.org/tex-archive/macros/latex/base/docstrip.dtx}].
[enum]
  [emph {The doc and shortvrb Packages}],
  [uri {http://tug.org/tex-archive/macros/latex/base/doc.dtx}].
[enum]
  Chapter 14 of
  [emph {The LaTeX Companion}] (second edition),
  Addison-Wesley, 2004; ISBN 0-201-36299-6.
[list_end]


[section {File format}]

The basic unit [syscmd docstrip] operates on are the [emph lines] of 
a master source file. Extraction consists of selecting some of these 
lines to be copied from input text to output text. The basic 
distinction is that between [emph {code lines}] (which are copied and 
do not begin with a percent character) and [emph {comment lines}] 
(which begin with a percent character and are not copied).

[example {
%</man>
%    \end{macrocode}
% At this point, let's do a little trick: use this example also as the 
% first test. This is just a matter of putting groups of lines in the 
% right modules.
% \begin{tcl}
%<*test>
tcltest::test docstrip-1.1 {code/comment line distinction} -body {
%</test>
%<*test,man>
   docstrip::extract [join {
     {% comment}
     {% more comment !"#$%&/(}
     {some command}
     { % blah $blah "Not a comment."}
     {% abc; this is comment}
     {# def; this is code}
     {ghi}
     {% jkl}
   } \n] {}
%<man>}]
%<man>returns the same sequence of lines as
%<man>[example {
%<test>} -result [
   join {
     {some command}
     { % blah $blah "Not a comment."}
     {# def; this is code}
     {ghi} ""
   } \n
%<test>]
%</test,man>
% \end{tcl}
% This completes the code for the test, so let's switch back to just 
% \Module{man}.
%    \begin{macrocode}
%<*man>
}]

It does not matter to [syscmd docstrip] what format is used for the 
documentation in the comment lines, but in order to do better than 
plain text comments, one typically uses some markup language. Most 
commonly LaTeX is used, as that is a very established standard and 
also provides the best support for mathematical formulae, but the 
[package docstrip::util] package also gives some support for 
[term doctools]-like markup.
[para]

Besides the basic code and comment lines, there are also 
[emph {guard lines}], which begin with the two characters '%<', and 
[emph {meta-comment lines}], which begin with the two characters 
'%%'. Within guard lines there is furthermore the distinction between 
[emph {verbatim guard lines}], which begin with '%<<', and ordinary 
guard lines, where the '%<' is not followed by another '<'. The last 
category is by far the most common.
[para]

Ordinary guard lines conditions extraction of the code line(s) they 
guard by the value of a boolean expression; the guarded block of 
code lines will only be included if the expression evaluates to true. 
The syntax of an ordinary guard line is one of
[example {
    '%' '<' STARSLASH EXPRESSION '>'
    '%' '<' PLUSMINUS EXPRESSION '>' CODE
}]
where
[example {
    STARSLASH  ::=  '*' | '/'
    PLUSMINUS  ::=  '+' | '-' |
    EXPRESSION ::= SECONDARY | SECONDARY ',' EXPRESSION
                 | SECONDARY '|' EXPRESSION
    SECONDARY  ::= PRIMARY | PRIMARY '&' SECONDARY
    PRIMARY    ::= TERMINAL | '!' PRIMARY | '(' EXPRESSION ')'
    CODE       ::= { any character except end-of-line }
}]
Comma and vertical bar both denote 'or'. Ampersand denotes 'and'. 
Exclamation mark denotes 'not'. A TERMINAL can be any nonempty string 
of characters not containing '>', '&', '|', comma, '(', or ')', 
although the [syscmd docstrip] manual is a bit restrictive and only 
guarantees proper operation for strings of letters. The second 
argument of [cmd docstrip::extract] is the list of those TERMINALs 
that should count as having the value 'true'; all other TERMINALs 
count as being 'false' when guard expressions are evaluated.
[para]

In the case of a '%<*[emph EXPRESSION]>' guard, the lines guarded are 
all lines up to the next '%</[emph EXPRESSION]>' guard with the same 
[emph EXPRESSION] (compared as strings). The blocks of code delimited 
by such '*' and '/' guard lines must be properly nested.
%    \end{macrocode}
% This looks like a good place for another example.
% \begin{tcl}
[example {
%</man>
%<*man,test>
%<test>tcltest::test docstrip-1.2 {blocks and nesting} -body {
   set text [join {
      {begin}
      {%<*foo>}
      {1}
      {%<*bar>}
      {2}
      {%</bar>}
      {%<*!bar>}
      {3}
      {%</!bar>}
      {4}
      {%</foo>}
      {5}
      {%<*bar>}
      {6}
      {%</bar>}
      {end}
   } \n]
   set res [docstrip::extract $text foo]
   append res [docstrip::extract $text {foo bar}]
   append res [docstrip::extract $text bar]
%<*man>
}]
sets $res to the result of
[example {
%</man>
%<test>} -result [
   join {
      {begin}
      {1}
      {3}
      {4}
      {5}
      {end}
      {begin}
      {1}
      {2}
      {4}
      {5}
      {6}
      {end}
      {begin}
      {5}
      {6}
      {end} ""
   } \n
%<test>]
%</man,test>
%<*man>
}]
% \end{tcl}
%    \begin{macrocode}

In guard lines without any '*', '/', '+', or '-' modifier after 
the '%<', the guard applies only to the CODE following the '>' on that 
single line. A '+' modifier is equivalent to no modifier. A '-' 
modifier is like the case with no modifier, but the expression is 
implicitly negated, i.e., the CODE of a '%<-' guard line is only 
included if the expression evaluates to false.
[para]

Metacomment lines are "comment lines which should not be stripped 
away", but be extracted like code lines; these are sometimes used for 
copyright notices and similar material. The '%%' prefix is however 
not kept, but substituted by the current [option -metaprefix], which 
is customarily set to some "comment until end of line" character (or 
character sequence) of the language of the code being extracted.
%    \end{macrocode}
% Ho hum, another example\slash test.
%    \begin{macrocode}
[example {
%</man>
%<*man,test>
%<*test>
tcltest::test docstrip-1.3 {plusminus guards and metacomments} -body {
%</test>
   set text [join {
      {begin}
      {%<foo> foo}
      {%<+foo>plusfoo}
      {%<-foo>minusfoo}
      {middle}
      {%% some metacomment}
      {%<*foo>}
      {%%another metacomment}
      {%</foo>}
      {end}
   } \n]
   set res [docstrip::extract $text foo -metaprefix {# }]
   append res [docstrip::extract $text bar -metaprefix {#}]
%<*man>
}]
sets $res to the result of
[example {
%</man>
%<test>} -result [
   join {
      {begin}
      { foo}
      {plusfoo}
      {middle}
      {#  some metacomment}
      {# another metacomment}
      {end}
      {begin}
      {minusfoo}
      {middle}
      {# some metacomment}
      {end} ""
   } \n
%<test>]
%</man,test>
%<*man>
}]

Verbatim guards can be used to force code line 
interpretation of a block of lines even if some of them happen to look 
like any other type of lines to docstrip. A verbatim guard has the 
form '%<<[emph END-TAG]' and the verbatim block is terminated by the 
first line that is exactly '%[emph END-TAG]'. 
[example {
%</man>
%<*man,test>
%<*test>
tcltest::test docstrip-1.4 {verbatim mode} -body {
%</test>
   set text [join {
      {begin}
      {%<*myblock>}
      {some stupid()}
      {   #computer<program>}
      {%<<QQQ-98765}
      {% These three lines are copied verbatim (including percents}
      {%% even if -metaprefix is something different than %%).}
      {%</myblock>}
      {%QQQ-98765}
      {   using*strange@programming<language>}
      {%</myblock>}
      {end}
   } \n]
   set res [docstrip::extract $text myblock -metaprefix {# }]
   append res [docstrip::extract $text {}]
%<*man>
}]
sets $res to the result of
[example {
%</man>
%<test>} -result [
   join {
      {begin}
      {some stupid()}
      {   #computer<program>}
      {% These three lines are copied verbatim (including percents}
      {%% even if -metaprefix is something different than %%).}
      {%</myblock>}
      {   using*strange@programming<language>}
      {end}
      {begin}
      {end} ""
   } \n
%<test>]
%</man,test>
%<*man>
}]
The processing of verbatim guards takes place also inside blocks of 
lines which due to some outer block guard will not be copied.
[para]

The final piece of [syscmd docstrip] syntax is that extraction 
stops at a line that is exactly "\endinput"; this is often used to 
avoid copying random whitespace at the end of a file. In the unlikely 
case that one wants such a code line, one can protect it with a 
verbatim guard.

%    \end{macrocode}
% Thus far the general descriptions; now for the actual commands. 
% The manpage source for these are next to the actual implementations.
%    \begin{macrocode}

[section Commands]

The package defines two commands.

[list_begin definitions]
%    \end{macrocode}
% 
% 
% \section{Code extraction}
% \label{Sec:Extract}
% 
% \begin{proc}{extract}
%   The |extract| procedure implements the core functionality of the 
%   \textsc{docstrip} program: copying the some lines of code as 
%   directed by relevant guard linnes. The main difference is that this 
%   takes the input as a string and returns output as a string.
%   
%   The syntax is
%   \begin{quote}
%     |docstrip::extract| \word{text} \word{terminal list}
%     \begin{regblock}[\regstar]\word{option} 
%     \word{value}\end{regblock}
%   \end{quote}
%   where \word{text} is the string to docstrip and \word{terminal list} 
%   is the list of expression terminals that should be true. 
%   \changes{1.0}{2004/09/30}{Switched to option--value syntax for 
%     equivalents of \textsc{docstrip} parameters. (LH)}
%   The options are
%   \begin{quote}
%     |-metaprefix| \word{string}\\
%     |-onerror| \begin{regblock}|throw|\regalt |puts|\regalt
%       |ignore|\end{regblock}\\
%     |-trimlines| \word{boolean}
%   \end{quote}
%   
%   The \describeopt[docstrip]{extract}{-metaprefix}|-metaprefix| value 
%   is the string to use for the \textsc{docstrip} parameter 
%   \verb|\MetaPrefix|. The default is `|%%|'. 
%   The \describeopt[docstrip]{extract}{-trimlines}|-trimlines| option 
%   specifies whether spaces at the end of a line should be trimmed 
%   away before it is processed. For compatibility with 
%   \textsc{docstrip} (which due to a quirk in the low-level input 
%   routines of \TeX\ cannot help doing this), this is by default on.
%   
%   The \describeopt[docstrip]{extract}{-onerror}|-onerror| option 
%   specifies what should happen when an error in the \word{text} being 
%   processed is detected. The value |puts| causes error messages to 
%   be written to |stderr|, but processing continues. |ignore| causes 
%   processing to continue silently. The default |throw| causes a 
%   \Tcllogo\ error to be thrown. In this last case, the |errorCode| is 
%   set to a list with the format
%   \begin{quote}
%     |DOCSTRIP| \word{situation} \word{lineno}
%   \end{quote}
%   where \word{lineno} is the line number (starting at one) of the line 
%   where the error was detected. The \word{situation}s are described 
%   below, at the positions in the code where they are detected.
%   
%   Now, for the manpage, a quick resum\'e of the above.
%    \begin{macrocode}
[call [cmd docstrip::extract] [arg text] [arg terminals] [
   opt "[arg option] [arg value] ..."
]]
  The [cmd extract] command docstrips the [arg text] and returns the 
  extracted lines of code, as a string with each line terminated with 
  a newline. The [arg terminals] is the list of those guard 
  expression terminals which should evaluate to true. 
  The available options are:
  [list_begin opt]
  [opt_def -metaprefix [arg string]]
    The string by which the '%%' prefix of a metacomment line will 
    be replaced. Defaults to '%%'. For Tcl code this would typically 
    be '#'.
  [opt_def -onerror [arg keyword]]
    Controls what will be done when a format error in the [arg text] 
    being processed is detected. The settings are:
    [list_begin definitions]
    [lst_item [const ignore]]
      Just ignore the error; continue as if nothing happened.
    [lst_item [const puts]]
      Write an error message to [const stderr], then continue 
      processing.
    [lst_item [const throw]]
      Throw an error. [var ::errorCode] is set to a list whose 
      first element is [const DOCSTRIP], second element is the 
      type of error, and third element is the line number where 
      the error is detected. This is the default.
    [list_end]
  [opt_def -trimlines [arg boolean]]
    Controls whether [emph spaces] at the end of a line should be 
    trimmed away before the line is processed. Defaults to true.
  [list_end]
  
  It should be remarked that the [arg terminals] are often called 
  "options" in the context of the [syscmd docstrip] program, since 
  these specify which optional code fragments should be included.

%</man>
%    \end{macrocode}
%   Hmm\dots\ Perhaps not so quick, after all.
%   \begin{tcl}
%<*pkg>
proc docstrip::extract {text terminals args} {
   array set O {
      -metaprefix %%
      -onerror throw
      -trimlines 1
   }
   array set O $args
%   \end{tcl}
%   The |O| array is for options of this procedure. The |T| array is 
%   for the terminals, so that the truth value of a terminal can be 
%   tested using |info exists|.
%   \begin{tcl}
   foreach t $terminals {set T($t) ""}
%   \end{tcl}
%   |stripped| is where the text that passes docstripping is collected.
%   \begin{tcl}
   set stripped ""
%   \end{tcl}
%   |block_stack| is the list of modules inside which the current line 
%   lies. |offlevel| is the number of modules that must be exited 
%   before code lines should once again be included. |verbatim| is a 
%   flag for whether verbatim mode is in force.
%   \begin{tcl}
   set block_stack [list]
   set offlevel 0
   set verbatim 0
%   \end{tcl}
%   |lineno| is the input line number counter, for use in error 
%   messages. 
%   \begin{tcl}
   set lineno 1
%   \end{tcl}
%   Here starts the main loop over lines in the \word{text}. It 
%   constitutes the majority of the procedure and is split in two 
%   parts. The smaller part handles lines in verbatim mode (unusual), 
%   the large part handles lines in normal mode (with comment lines, 
%   code lines, guard lines, and so on).
%   \begin{tcl}
   foreach line [split $text \n] {
      if {$O(-trimlines)} then {
         set line [string trimright $line " "]
      }
      if {$verbatim} then {
         if {$line eq $endverbline} then {
            set verbatim 0
         } elseif {!$offlevel} then {
            append stripped $line \n
         }
      } else {
%   \end{tcl}
%   Here starts the processing of lines in non-verbatim mode.
%   \begin{tcl}
         switch -glob -- $line %%* {
            if {!$offlevel} then {
               append stripped $O(-metaprefix)\
                 [string range $line 2 end] \n
            }
         } %<<* {
            set endverbline "%[string range $line 3 end]"
            set verbatim 1
         } %<* {
            if {[
               regexp -- {^%<([*/+-]?)([^>]*)>(.*)$} $line ""\
                 modifier expression line
            ]} then {
%   \end{tcl}
%   At this point, an ordinary guard line has successfully been split 
%   into parts. First the expression is evaluated, by converting it 
%   to an |expr| expression.
%   \begin{tcl}
               regsub -all -- {\\|\{|\}|\$|\[|\]| |;} $expression\
                 {\\&} E
               regsub -all -- {,} $E {|} E
               regsub -all -- {[^()|&!]+} $E {[info exists T(&)]} E
               if {[catch {expr $E} val]} then {
%   \end{tcl}
%   Apparently the expression was malformed. That is an 
%   \describestring[error situation]{EXPRERR}|EXPRERR| \word{situation}.
%   \changes{1.0}{2004/09/29}{Catching errors in expressions. (LH)}
%   \begin{tcl}
                  switch -- [string tolower $O(-onerror)] "puts" {
                     puts stderr "docstrip: Error in expression\
                       <$expression> ignored on line $lineno."
                  } "ignore" {} default {
                     error $val "" [list DOCSTRIP EXPRERR $lineno]
                  }
                  set val -1
               }
%   \end{tcl}
%   With the expression evaluated, the processing of a guard line
%   now branches according to its type.
%   \begin{tcl}
               switch -exact -- $modifier * {
                  lappend block_stack $expression
                  if {$offlevel || !$val} then {incr offlevel}
               } / {
                  if {![llength $block_stack]} then {
%   \end{tcl}
%   In this case there was no open block for this guard to end. That 
%   is a \describestring[error situation]{SPURIOUS}|SPURIOUS| 
%   \word{situation}.
%   \begin{tcl}
                     switch -- [string tolower $O(-onerror)] "puts" {
                        puts stderr "docstrip: Spurious end\
                          block </$expression> ignored on line\
                          $lineno."
                     } "ignore" {} default {
                        error "Spurious end block </$expression>." ""\
                          [list DOCSTRIP SPURIOUS $lineno]
                     }
                  } else {
                     if {[string compare $expression\
                       [lindex $block_stack end]]} then {
%   \end{tcl}
%   In this case the expression of the block being closed does not match 
%   the expression on the block on top of the stack. That is a 
%   \describestring[error situation]{MISMATCH}|MISMATCH| 
%   \word{situation}. \textsc{docstrip} by default raises an error and 
%   recovers by treating this situation as a typo.
%   \begin{tcl}
                        switch -- [string tolower $O(-onerror)] "puts" {
                           puts stderr "docstrip:\
                             Found </$expression> instead of\
                             </[lindex $block_stack end]> on line\
                             $lineno."
                        } "ignore" {} default {
                           error "Found </$expression> instead of\
                             </[lindex $block_stack end]>." ""\
                             [list DOCSTRIP MISMATCH $lineno]
                        }
                     }
%   \end{tcl}
%   All that error processing makes it easy to lose track, but the 
%   following two lines are what does the real work for an end of block 
%   guard: pop a block off the stack and decrement the |offlevel|.
%   \begin{tcl}
                     if {$offlevel} then {incr offlevel -1}
                     set block_stack [lreplace $block_stack end end]
                  }
%   \end{tcl}
%   These last cases of the |switch| handle |-|, |+|, and ``no 
%   modifier'' lines.
%   \begin{tcl}
               } - {
                  if {!$offlevel && !$val} then {
                     append stripped $line \n
                  }
               } default {
                  if {!$offlevel && $val} then {
                     append stripped $line \n
                  }
               }
            } else {
%   \end{tcl}
%   In this case the line looks like a guard line, but there is no |>| 
%   terminating the guard expression. This is a 
%   \describestring[error situation]{BADGUARD}|BADGUARD| 
%   \word{situation}.
%   \begin{tcl}
               switch -- [string tolower $O(-onerror)] "puts" {
                  puts stderr "docstrip: Malformed guard\
                    on line $lineno:"
                  puts stderr $line
               } "ignore" {} default {
                  error "Malformed guard on line $lineno." ""\
                    [list DOCSTRIP BADGUARD $lineno]
               }
            }
         } %* {}\
%   \end{tcl}
%   Back to the outer |switch|. With comment lines, nothing is done. 
%   A line being the exact string |\endinput| terminates the stripping.
%   \begin{tcl}
         {\\endinput} {
           break
         } default {
%   \end{tcl}
%   Other lines are code lines. These are included or not, depending on 
%   the |offlevel|.
%   \begin{tcl}
            if {!$offlevel} then {append stripped $line \n}
         }
      }
      incr lineno
   }
   return $stripped
}
%</pkg>
%   \end{tcl}
% \end{proc}
% 
% The following is a test of the |extract| procedure, which compares its 
% output to the \textsc{docstrip} program output. If need be, and \LaTeX\ 
% is not available, then this could also be modified to produce a new 
% version of \texttt{docstrip.tcl} using the |extract| command of 
% an older version.
% \begin{tcl}
%<*test>
tcltest::test docstrip-2.1 {have docstrip extract itself} -constraints {
   docstripSourcesAvailable
} -body {
   # First read in the ready-stripped file, but gobble the preamble and
   # postamble, as those are a bit messy to reproduce.
   set F [open docstrip.tcl r]
   regsub -all -- {(^|\n)#[^\n]*} [read $F] {} stripped
   close $F
   # Then read the master source and strip it manually.
   set F [open tcldocstrip.dtx r]
   set source [read $F]
   close $F
   set stripped2 [docstrip::extract $source pkg -metaprefix ##]
   # Finally compare the two.
   if {[string trim $stripped \n] ne [string trim $stripped2 \n]} then {
      error "$strippped\n ne \n$stripped2"
   }
}
%</test>
% \end{tcl}
% 
% 
% 
% \section{Code sourcing}
% 
% \begin{proc}{sourcefrom}
%   This procedure behaves as a docstripping |source| command: it reads 
%   a file, docstrips its contents in memory, and evaluates the result 
%   as a \Tcllogo\ script in the context of the caller. The syntax is
%   \begin{quote}
%     |docstrip::sourcefrom| \word{filename} \word{terminals} 
%     \begin{regblock}[\regstar]\word{option} \word{value}\end{regblock}
%   \end{quote}
%   where \word{filename} is the file name and \word{terminals} is the 
%   list of true guard expression terminals. The \word{option} and 
%   \word{value} arguments are passed on to |fconfigure|, to configure 
%   the file before |read|ing it.
%   \changes{1.0}{2004/10/01}{Added \texttt{info script} management. 
%     (LH)}
%   \begin{tcl}
%<*man>

[call [cmd docstrip::sourcefrom] [arg filename] [arg terminals] [
   opt "[arg option] [arg value] ..."
]]
  The [cmd sourcefrom] command is a docstripping emulation of 
  [cmd source]. It opens the file [arg filename], reads it, closes it, 
  docstrips the contents as specified by the [arg terminals], and 
  evaluates the result in the local context of the caller, during 
  which time the [cmd info] [method script] value will be the 
  [arg filename]. The options are passed on to [cmd fconfigure] to 
  configure the file before its contents are read. The 
  [option -metaprefix] is set to '#', all other [cmd extract] 
  options have their default values.
%</man>
%<*pkg>
proc docstrip::sourcefrom {name terminals args} {
   set F [open $name r]
   if {[llength $args]} then {
      eval [linsert $args 0 fconfigure $F]
   }
   set text [read $F]
   close $F
   set oldscr [info script]
   info script $name
   set code [catch {
      uplevel 1 [extract $text $terminals -metaprefix #]
   } res]
   info script $oldscr
   if {$code == 1} then {
      error $res $::errorInfo $::errorCode
   } else {
      return $res
   }
}
%</pkg>
%   \end{tcl}
% \end{proc}
% 
% Testing the above procedure requires an external file.
% \begin{tcl}
%<*test>
tcltest::test docstrip-2.2 {soucefrom} -setup {
   tcltest::makeFile [join {
      {% Just a minor test file.}
      {puts A}
      {%<*bar>}
      {puts B}
      {%<*foo>}
      {puts [info exists baz]}
      {set baz 1}
      {%</foo>}
      {%<-foo>return}
      {%</bar>}
      {puts $baz}
      {puts [info script]}
      {%<*!foo>}
      {puts C}
      "%% Tricky comment; guess what comes next\\"
      {%</!foo>}
      {incr baz}
% \end{tcl}
% What the above construction does depends on the truth value of |foo|. 
% When true, the \Module{!foo} block is skipped in its entirety, and 
% thus the next command after |puts [info script]| is |incr baz|. 
% However when |foo| is false the block will be included. 
% The metacomment line gets a prefix |#| and will therefore become 
% a comment when the code is evaluated. The backslash escapes the 
% subsequent newline, and thus the |incr baz| will only be part of 
% a \Tcllogo\ comment.
% \begin{tcl}
      {puts "baz=$baz"}
   } \n] test.dtx
} -body {
   set baz 0
   docstrip::sourcefrom test.dtx {foo bar}
   docstrip::sourcefrom test.dtx {}
   docstrip::sourcefrom test.dtx {bar}
   puts $baz
} -cleanup {
   tcltest::removeFile test.dtx
} -output [join {
   {A} {B} {1} {1} {test.dtx} {baz=2}
   {A} {2} {test.dtx} {C} {baz=2}
   {A} {B}
   {2} ""
} \n]
%</test>
% \end{tcl}
% 
% 
% 
% \section{More manpage source}
% 
% This completes the package code, but there are more things which
% should be said on the manpage.
%    \begin{macrocode}
%<*man>
[list_end]


[section {Document structure}]

The file format (as described above) determines whether a master
source code file can be processed correctly by [syscmd docstrip], 
but the usefulness of the format is to no little part also dependent
on that the code and comment lines together constitute a well-formed
document.
[para]

For a document format that does not require any non-Tcl software, see 
the [cmd ddt2man] command in the [package docstrip::util] package. It 
is suggested that files employing that document format are given the 
suffix [file .ddt], to distinguish them from the more traditional 
LaTeX-based [file .dtx] files.
[para]

Master source files with [file .dtx] extension are usually set up so
that they can be typeset directly by [syscmd latex] without any
support from other files. This is achieved by beginning the file 
with the lines
[example_begin]
   % \iffalse
   %<*driver>
   \documentclass{tclldoc}
   \begin{document}
   \DocInput{[emph filename.dtx]}
   \end{document}
   %</driver>
   % \fi
[example_end]
or some variation thereof. The trick is that the file gets read twice.
With normal LaTeX reading rules, the first two lines are comments and 
therefore ignored. The third line is the document preamble, the fourth
line begins the document body, and the sixth line ends the document, 
so LaTeX stops there. First the \DocInput command on the fifth line 
is processed however, and that does two things: it changes the
interpretation of '%' from "comment" to "ignored", and it inputs the 
file specified in the argument (which is normally the name of the file
the command is in). It is this second time that the file is being 
read that the comments and code in it are typeset.
[para]

The function of the \iffalse ... \fi is to skip lines two to seven 
on this second time through; this is similar to the "if 0 { ... }" 
idiom for block comments in Tcl code, and it is needed here because 
(amongst other things) the \documentclass command may only be 
executed once. The function of the <driver> guards is to prevent this 
short piece of LaTeX code from being extracted by [syscmd docstrip]. 
The total effect is that the file can function both as a LaTeX 
document and as a [syscmd docstrip] master source code file.
[para]

It is not necessary to use the tclldoc document class, but that does 
provide a number of features that are convenient for [file .dtx] 
files containing Tcl code. More information on this matter can be 
found in the references above.

%</man>
%    \end{macrocode}
% 
% \section{The docstrip utilities package}
% 
%    \begin{macrocode}
%<*utilman>

The [package docstrip::util] package is meant for collecting various 
utility procedures that may be useful for developers who make use of 
the [package docstrip] package in some projects. It is separate from 
the main package to avoid overhead for end-users.


[section Commands]

[list_begin definitions]
%    \end{macrocode}
% 
% \subsection{Doctools support}
% 
% In the interest of making \textsf{docstrip} useful also for 
% programmers who do not want to write \LaTeX\ markup, some support is 
% offered also for files with \textsf{doctools} \texttt{.man} markup in 
% the comment lines. It is suggested that such files are given the 
% suffix \texttt{.ddt} to distinguish them from the \texttt{.dtx} files 
% that are directly \LaTeX able.
% 
% More precisely, it is suggested that the markup on comment and 
% metacomment lines of a \texttt{.ddt} file should follow the syntax on 
% the \texttt{doctools\_fmt} manpage~\cite{doctools_fmt}, or in the 
% future perhaps some derivative thereof. Unlike the case in 
% \texttt{.dtx} files, no explicit markup is required (or wanted) 
% around blocks of code and guard lines; such markup is to be generated 
% by the procedure below, as part of adding suitable markup to the code 
% lines.
% 
% \begin{proc}[util]{ddt2man}
%   This procedure takes a string in the \texttt{.ddt} format sketched 
%   above and returns the corresponding text with \textsf{doctools} 
%   \texttt{.man} markup. The syntax is
%   \begin{quote}
%     |docstrip::util::ddt2man| \word{text}
%   \end{quote}
%   
%    \begin{macrocode}
[call [cmd docstrip::util::ddt2man] [arg text]]
  The [cmd ddt2man] command reformats [arg text] from the general 
  [syscmd docstrip] format to [package doctools] [file .man] format 
  (Tcl Markup Language for Manpages). The different line types are 
  treated as follows:
  [list_begin definitions]
  [lst_item {comment and metacomment lines}]
    The '%' and '%%' prefixes are removed, the rest of the text is 
    kept as it is.
  [lst_item {empty lines}]
    These are kept as they are. (Effectively this means that they will 
    count as comment lines after a comment line and as code lines
    after a code line.)
  [lst_item {code lines}]
    [cmd example_begin] and [cmd example_end] commands are placed 
    at the beginning and end of every block of consecutive code 
    lines. Brackets in a code line are converted to [cmd lb] and 
    [cmd rb] commands.
  [lst_item {verbatim guards}]
    These are processed as usual, so they do not show up in the 
    result but every line in a verbatim block is treated as a code 
    line.
  [lst_item {other guards}]
    These are treated as code lines, except that the actual guard is 
    [cmd emph]asised.
  [list_end]

  At the time of writing, no project has employed [package doctools] 
  markup in master source files, so experience of what works well is 
  not available. A source file could however look as follows
[example {
%</utilman>
%<*utilman,gcdexample>
   % [manpage_begin gcd n 1.0]
   % [moddesc {Greatest Common Divisor}]
   % [require gcd [opt 1.0]]
   % [description]
   % 
   % [list_begin definitions]
   % [call [cmd gcd] [arg a] [arg b]]
   %   The [cmd gcd] procedure takes two arguments [arg a] and [arg b] which 
   %   must be integers and returns their greatest common divisor.
   proc gcd {a b} {
   %   The first step is to take the absolute values of the arguments.
   %   This relieves us of having to worry about how signs will be treated 
   %   by the remainder operation.
      set a [expr {abs($a)}]
      set b [expr {abs($b)}]
   %   The next line does all of Euclid's algorithm! We can make do 
   %   without a temporary variable, since $a is substituted before the 
   %   [lb]set a $b[rb] and thus continues to hold a reference to the 
   %   "old" value of [var a].
      while {$b>0} { set b [expr { $a % [set a $b] }] }
   %   In Tcl 8.3 we might want to use [cmd set] instead of [cmd return]
   %   to get the slight advantage of byte-compilation.
   %<tcl83>  set a
   %<!tcl83>   return $a
   }
   % [list_end]
   %
   % [manpage_end]
%</utilman,gcdexample>
%<*utilman>
}]
  If the above text is (suitably unindented and) fed through 
  [cmd docstrip::util::ddt2man] then the result will be a syntactically 
  correct [package doctools] manpage, even though its purpose is a 
  bit different.
  [nl]
  
  It is suggested that master source code files with [package doctools] 
  markup are given the suffix [file .ddt], hence the "ddt" in 
  [cmd ddt2man].

%</utilman>
%    \end{macrocode}
% 
%   The structure of this procedure is fairly similar to that of 
%   |extract|, although of course the processing of the lines is rather 
%   different. The main novelty is the variable |wascode|, which is 
%   true if the previous line was a code line of some sort.
%   \begin{tcl}
%<*utilpkg>
proc docstrip::util::ddt2man {text} {
   set wascode 0
   set verbatim 0
   set res ""
   foreach line [split $text \n] {
      if {$verbatim} then {
         if {$line eq $endverbline} then {
            set verbatim 0
         } else {
            append res [string map {[ [lb] ] [rb]} $line] \n
         }
      } else {
         switch -glob -- $line %%* {
            if {$wacode} then {
               append res {[example_end]} \n
               set wascode 0
            }
            append res [string range $line 2 end] \n
         } %<<* {
            if {!$wascode} then {
               append res {[example_begin]} \n
               set wascode 1
            }
            set endverbline "%[string range $line 3 end]"
            set verbatim 1
         } %<* {
            if {!$wascode} then {
               append res {[example_begin]} \n
               set wascode 1
            }
            set guard ""
            regexp -- {(^%<[^>]*>)(.*)$} $line "" guard line
            append res \[ [list emph $guard] \]\
              [string map {[ [lb] ] [rb]} $line] \n
         } %* {
            if {$wascode} then {
               append res {[example_end]} \n
               set wascode 0
            }
            append res [string range $line 1 end] \n
         } {\\endinput} {
           break
         } "" {
%   \end{tcl}
%   Experience showed that empty lines at the beginning and end of a
%   file were hard to avoid. In order to stop those from being marked 
%   up as examples, an empty line will not trigger a switch to code 
%   mode.
%   \begin{tcl}
            append res \n
         } default {
            if {!$wascode} then {
               append res {[example_begin]} \n
               set wascode 1
            }
            append res [string map {[ [lb] ] [rb]} $line] \n
         }
      }
   }
   if {$wascode} then {append res {[example_end]} \n}
   return $res
}
%</utilpkg>
%   \end{tcl}
%   There is no test of this procedure, since it is rather 
%   experimental. There is however an example below which one might 
%   develop into a test, if the need seems significant.
% \end{proc}
% 
% \begin{tcl}
%<utilman>[list_end]
% \end{tcl}
% 
% 
% \section{Closing material}
% 
% The packages need no particular ending, but the tests can do with an
% explicit cleanup.
% 
% \begin{tcl}
%<test>tcltest::cleanupTests
% \end{tcl}
% 
% The manpages require an explicit ending, and can do with some 
% keywords.
%    \begin{macrocode}
%<*man,utilman>

%<man>[see_also docstrip_util]
%<utilman>[see_also docstrip doctools doctools_fmt]

[keywords documentation source {literate programming} docstrip]
%<man>[keywords LaTeX .dtx]
%<utilman>[keywords doctools .ddt]
[manpage_end]
%</man,utilman>
%    \end{macrocode}
% There! That's it!
% 
% 
% \section{Development tools}
% 
% I have found the following code snippet useful for formatting 
% \texttt{docstrip.man}.
% \begin{tcl}
%<*devtest>
package require doctools
doctools::new man2html -format html
proc makehtml {{from docstrip.man} {to docstrip.html}} {
   set text [string map {\r \n}\
     [getText -w $from [minPos] [maxPos -w $from]]]
   set html [man2html format $text]
   replaceText -w $to [minPos] [maxPos -w $to]\
     [string map {\n \r} $html]
}
%</devtest>
% \end{tcl}
% It is included here so that I know where to find it, but it is
% normally no extracted.
% 
% \bigskip
% 
% The following block of code could be taken as the beginnings of a test 
% or example of the use of |ddt2man|. First extract the 
% \Module{gcdexample}.
% \begin{tcl}
%<*devtest2>
package require docstrip
set F [open tcldocstrip.dtx r]
set text [docstrip::extract [read $F] gcdexample]
close $F
% \end{tcl}
% Then unindent the lines so that they become the intended mixture of 
% code and comment lines.
% \begin{tcl}
regsub -all -lineanchor {^   } $text "" ddt
% \end{tcl}
% Now |ddt2html| can be applied:
% \begin{tcl}
package require docstrip::util
set man [docstrip::util::ddt2man $ddt]
% \end{tcl}
% Finally, format this code as something.
% \begin{tcl}
package require doctools
doctools::new man2html -format html
set html [man2html format $man]
%</devtest2>
% \end{tcl}
% 
% \begin{thebibliography}{6}
% \bibitem{tclldoc}
%   Lars Hellstr\"om:
%   \textit{The \textsf{tclldoc} package and class}, 
%   \LaTeXe\ package and document class,
%   \textsc{ctan}:\discretionary{}{}{\thinspace}\texttt{macros}\slash 
%   \texttt{latex}\slash \texttt{contrib}\slash \texttt{tclldoc}/.
% \bibitem{doctools_fmt}
%   Andreas Kupries:
%   \textit{Specification of a simple \Tcllogo\ Markup Language 
%   for Manpages}, manpage,
%   \texttt{tcllib} module \textsf{doctools}, 2002--;
%   \textsc{http}:/\slash \texttt{tcllib.sourceforge.net}\slash
%   \texttt{doc}\slash \texttt{doctools\_fmt.html}.
% \bibitem{docstrip}
%   Frank Mittelbach, Denys Duchier, Johannes Braams, Marcin 
%   Woli\'nski, and Mark Wooding: \textit{The \textsf{DocStrip} 
%   program},  The \LaTeX3 Project; 
%   \textsc{ctan}:\discretionary{}{}{\thinspace}\texttt{macros}\slash 
%   \texttt{latex}\slash \texttt{base}\slash \texttt{docstrip.dtx}.
% \bibitem{doc}
%   Frank Mittelbach, B.~Hamilton Kelly, Andrew Mills, Dave Love, and 
%   Joachim \mbox{Schrod}: \textit{The \textsf{doc} and 
%   \textsf{shortvrb} Packages}, The \LaTeX3 Project;
%   \textsc{ctan}:\discretionary{}{}{\thinspace}\texttt{macros}\slash 
%   \texttt{latex}\slash \texttt{base}\slash \texttt{doc.dtx}.
% \iffalse
% [enum]
%   Chapter 14 of
%   [emph {The LaTeX Companion}] (second edition),
%   Addison-Wesley, 2004; ISBN 0-201-36299-6.
% \fi
% \end{thebibliography}
% 
% 
\endinput

  