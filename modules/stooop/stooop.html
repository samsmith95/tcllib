<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<!-- Copyright (c) 2001 by Jean-Luc Fontaine <jfontain@free.fr> -->
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <title>stooop (Simple Tcl Only Object Oriented Programming)</title>
</head>
<body>

<center><!--$Id: stooop.html,v 1.2 2001/11/27 11:46:52 jfontain Exp $--></center>

<center>
<h1>
stooop</h1></center>

<center>
<h2>
(Simple Tcl Only Object Oriented Programming)</h2></center>
Stooop is an extension to the great Tcl language written in Tcl itself.
The object oriented features of stooop are modeled after the C++ programming
language while following the Tcl language philosophy.
<h3>
Contents</h3>

<ul>
<li>
<a href="#about">About this document</a></li>

<li>
<a href="#introduction">Introduction</a></li>

<li>
<a href="#simple">Simple example</a></li>

<li>
<a href="#conventions">Coding conventions</a></li>

<ul>
<li>
<a href="#definition">Class definition</a></li>

<li>
<a href="#procedures">Member procedures</a></li>

<ul>
<li>
<a href="#constructor">Constructor</a></li>

<li>
<a href="#destructor">Destructor</a></li>

<li>
<a href="#proceduresnonstatic">Non static</a></li>

<li>
<a href="#proceduresstatic">Static</a></li>

<li>
<a href="#copy">Copy constructor</a></li>
</ul>

<li>
<a href="#data">Member data</a></li>

<ul>
<li>
<a href="#datanonstatic">Non static</a></li>

<li>
<a href="#datastatic">Static</a></li>
</ul>
</ul>

<li>
<a href="#keywords">Commands</a></li>

<ul>
<li>
<a href="#class">class</a></li>

<li>
<a href="#new">new</a></li>

<li>
<a href="#delete">delete</a></li>

<li>
<a href="#virtual">virtual</a></li>

<li>
<a href="#classof">classof</a></li>
</ul>

<li>
<a href="#package">Package</a></li>

<ul>
<li>
<a href="#installation">Installation</a></li>

<li>
<a href="#creation">Creation</a></li>
</ul>

<li>
<a href="#examples">Examples</a></li>

<ul>
<li>
<a href="#parallel">Parallel with C++</a></li>

<li>
<a href="#graphical">Graphical demonstration</a></li>

<li>
<a href="#widget">Widget class</a></li>

<li>
<a href="#array">Member array</a></li>
</ul>

<li>
<a href="#utility">Utility classes</a></li>

<ul>
<li>
<a href="#switched">switched</a></li>
</ul>

<li>
<a href="#debugging">Debugging</a></li>

<ul>
<li>
<a href="#check">member check</a></li>

<ul>
<li>
<a href="#procedurecheck">procedure</a></li>

<li>
<a href="#datacheck">data</a></li>
</ul>

<li>
<a href="#trace">member trace</a></li>

<ul>
<li>
<a href="#proceduretrace">procedure</a></li>

<li>
<a href="#datatrace">data</a></li>
</ul>

<li>
<a href="#objects">objects</a></li>

<ul>
<li>
<a href="#objects.printing">printing</a></li>

<li>
<a href="#objects.recording">recording</a></li>

<li>
<a href="#objects.reporting">reporting</a></li>
</ul>
</ul>

<li>
<a href="#notes">Notes</a></li>

<ul>
<li>
<a href="#design">On design choices</a></li>

<li>
<a href="#implementation">On implementation</a></li>
</ul>

<li>
<a href="#misc">Miscellaneous information</a></li>
</ul>

<h3>
<a NAME="about"></a>About this document</h3>
This document contains general information, reference information and many
examples designed to help the programmer understand and use the stooop
extension (version 4.1.1 and above).
<p>A working knowledge of object oriented programming techniques and a
related programming language (C++, Java, ...) significantly helps understand
this document.
<h3>
<a NAME="introduction"></a>Introduction</h3>
After some time writing Tcl/Tk code, I felt that I needed a way to improve
the structure of my code, and why not use an object oriented approach,
since I knew (but does anybody really? :-) C++. As I have used Tcl quite
extensively in several commercial applications running on different operating
systems and hardware, I decided to use a strict Tcl implementation for
my object oriented extension. Consequently, stooop is compatible with all
the Tcl ports (UNIX, Windows, MacIntosh).
<p>Great care was taken so that this extension would no adverse impact
on performance. Furthermore, designing your code in an object oriented
should improve its performance, by focusing on well written pieces of reusable
code.
<p>Stooop only introduces a few new commands: <a href="#class">class</a>,
<a href="#new">new</a>,
<a href="#delete">delete</a>,
<a href="#virtual">virtual</a>
and <a href="#classof">classof</a>. Along with a few coding conventions,
that is basically all you need to know to use stooop. Stooop is meant to
be as simple to use as possible.
<p>Starting with stooop version 3.2, nested classes are supported (see
<a href="#class">class</a>),
whereas version 3.3 and above support procedure and data members checking
as well as tracing (see <a href="#debugging">debugging</a>).
<p>Tcl version 8.2 and above supports the empty name array syntax, as in:
<pre>set (m) 0 ;# set member m of array {} to 0
set n $(m) ;# which actually set n to 0</pre>
This feature greatly simplifies class member manipulation in stooop classes
and significantly improves performance. Stooop version 4.0 and above also
uses this feature internally for further improvements, without sacrificing
backward compatibility: code written against stooop versions 3.7 and below
still works with stooop version 4.0 and above, but can be gradually moved
to the simpler syntax when convenient.
<br>Stooop 4.1 and above will only work out of the box with Tcl 8.3 and
above.
<h3>
<a NAME="simple"></a>Simple example</h3>
Let us start with a code sample that will give you some feeling on how
stooop works:
<pre><tt>package require stooop 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;# load stooop package
namespace import stooop::*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;# and import class, new, ... commands</tt></pre>

<pre><tt>class shape {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;# base class definition
&nbsp;&nbsp;&nbsp; proc shape {this x y} {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;# base class constructor
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set ($this,x) $x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;# data member initialization
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set ($this,y) $y
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; proc ~shape {this} {}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;# base class destructor
&nbsp;&nbsp;&nbsp; # pure virtual draw: must be implemented in derived classes
&nbsp;&nbsp;&nbsp; virtual proc draw {this}
&nbsp;&nbsp;&nbsp; virtual proc rotate {this angle} {}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;# do nothing by default
}
proc shape::move {this x y} {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;# external member procedure definition
&nbsp;&nbsp;&nbsp; set ($this,x) $x
&nbsp;&nbsp;&nbsp; set ($this,y) $y
&nbsp;&nbsp;&nbsp; draw $this&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;# shape::draw invokes derived class implementation
}

class triangle {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;# class definition
&nbsp;&nbsp;&nbsp; proc triangle {this x y} shape {$x $y} {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;# derived from shape
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # triangle constructor implementation
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; proc ~triangle {this} {}
&nbsp;&nbsp;&nbsp; proc draw {this} {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # triangle specific implementation
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; proc rotate {this angle} {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # triangle specific implementation
&nbsp;&nbsp;&nbsp; }
}

class circle {}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;# empty class definition, procedures are defined outside
proc circle::circle {this x y} shape {$x $y} {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;# derived from shape
&nbsp;&nbsp;&nbsp; # circle constructor implementation
}
proc circle::~circle {this} {}
proc circle::draw {this} {
&nbsp;&nbsp;&nbsp; # circle specific implementation
}
# circle::rotate procedure is a noop, no need to overload

lappend shapes [new circle 20 20] [new triangle 80 20]
foreach object $shapes {
&nbsp;&nbsp;&nbsp; shape::draw $object
&nbsp;&nbsp;&nbsp; shape::rotate $object 45
}
eval delete $shapes</tt></pre>

<h3>
<a NAME="conventions"></a>Coding conventions</h3>
I have tried to make stooop Tcl code look like C++ code. There are exceptions
of course.
<h4>
<a NAME="definition"></a>Class definition</h4>
The syntax is very simple:
<p><tt>class className { ...</tt>
<p>The member procedures are then defined, inside or outside the class
definition (see below). Note that the base classes if any are defined within
the constructor declaration where they are required for eventually passing
constructor parameters, not in the actual class declaration where they
would then be redundant.
<p>As a class is a namespace, it is just as easy to nest classes as it
is namespaces.
<h4>
<a NAME="procedures"></a>Member procedures</h4>
They can be defined inside or outside their class definition. When defined
inside the class definition, the class name qualifier (<i>shape::</i> for
example) before the procedure name must be omitted (a class is a Tcl namespace).
When defined outside the class definition, the class name qualifier must
be present (same reason). You may notice that the class definition and
the related member procedures look very much like the Tcl <i>namespace</i>
feature: it is because classes are indeed namespaces with a few more features
added to support object orientation.
<p>Member procedures are named as in C++ (for example, the <i>rotate</i>
procedure of the class <i>shape</i> is referred to as <i>shape::rotate</i>
in the global namespace). They are defined using the Tcl <i>proc</i> command,
which is redefined by stooop in order to do some specific additional processing.
Of course, global level and other namespaces procedures are not affected
by stooop.
<h5>
<a NAME="constructor"></a>Constructor</h5>
A constructor is used to initialize an object of its class. The constructor
is invoked by the <a href="#new">new</a> operator when an object of the
class is created (instanciated in OO terms). The constructor is named as
in C++ (for example, the
<i>shape</i> constructor fully qualified name
is <i>shape::shape</i>).
<p>The constructor always takes the object identifier (a unique value generated
by the command new) as the first parameter, plus eventually additional
parameters as in the normal Tcl proc command. Arguments with default values
are allowed, and so are variable number of arguments (see below). In all
cases, the first parameter must be named <b>this</b>.
<p><i><b>Note</b>: the object identifier is a unique integer value which
is internally incremented by stooop each time a new object is created.
Consequently, the greater the object identifier, the younger the object.</i>
<p>Sample code of a constructor of a simple class with no base class:
<pre><tt>class shape {
&nbsp;&nbsp;&nbsp; proc shape {this x y} {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # implementation here
&nbsp;&nbsp;&nbsp; }
}</tt></pre>
If a class is derived from one or more base classes, the derived class
constructor defines the base classes and their constructor arguments before
the actual body of the constructor.
<p><i><b>Note</b>: base classes are not defined at the class command level,
because it would be redundant with the constructor definition, which is
mandatory.</i>
<p>The derived class constructor parameters are followed by "base class
names / constructor arguments" pairs. For each base class, there must be
a corresponding list of constructor arguments to be used when the object
is constructed when the new operator is invoked with the derived class
name as argument.
<p>Sample code for a class constructor with a single base class:
<pre><tt>class circle {}
proc circle::circle {this x y} shape {$x $y} {
&nbsp;&nbsp;&nbsp; # circle constructor implementation
}</tt></pre>
Sample code for a class constructor with multiple base classes:
<pre><tt>class hydroplane {
&nbsp;&nbsp;&nbsp; proc hydroplane {this wingspan length} plane {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $wingspan $length
&nbsp;&nbsp;&nbsp; } boat {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $length
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # constructor implementation
&nbsp;&nbsp;&nbsp; }
}</tt></pre>
The base class constructor arguments must be prefixed with dollar signs
since they will be evaluated at the time the object is constructed, right
before the base class constructor is invoked. This technique allows, as
in C++, some actual processing to be done on the base class arguments at
construction time. The <b>this</b> argument to the base class constructor
must not be specified for it is automatically generated by stooop.
<p>Sample code for a derived class constructor with base class constructor
arguments processing:
<pre><tt>class circle {
&nbsp;&nbsp;&nbsp; proc circle {this x y} shape {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [expr round($x)] [expr round($y)]
&nbsp;&nbsp;&nbsp; } {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # constructor implementation
&nbsp;&nbsp;&nbsp; }
}</tt></pre>
The base class(es) constructor(s) is(are) automatically invoked before
the derived class constructor body is evaluated. Thus layered object construction
occurs in the same order as in C++.
<p>Variable length arguments are a special case and depend on both the
derived class constructor arguments and those of the base class.
<p>If both derived and base class constructors take a variable number of
arguments (through the <i>args</i> special argument (see Tcl proc manual
page)), the base class constructor will also see the variable arguments
part as separate arguments. In other words, the following works as expected:
<pre><tt>class base {}
proc base::base {this parameter args} {
&nbsp;&nbsp;&nbsp; array set options $args
}
class derived {}
proc derived::derived {this parameter args} base {
&nbsp;&nbsp;&nbsp; $parameter $args
} {}
new derived someData -option value -otherOption otherValue</tt></pre>
Actually, if you want to get fancy, to allow some processing on the derived
class constructor variable arguments, the last element (and only the last)
of the derived class constructor arguments is considered variable if it
contains the string
<i>$args</i>. For example:
<pre><tt>class base {
&nbsp;&nbsp;&nbsp; proc base {this parameter args} {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; array set options $args
&nbsp;&nbsp;&nbsp; }
}
class derived {
&nbsp;&nbsp;&nbsp; proc derived {this parameter args} base {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $parameter [process $args]
&nbsp;&nbsp;&nbsp; } {}
&nbsp;&nbsp;&nbsp; proc process {arguments} {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # do some processing on arguments list
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return $arguments
&nbsp;&nbsp;&nbsp; }
}
new derived someData -option value -otherOption otherValue</tt></pre>

<h5>
<a NAME="destructor"></a>Destructor</h5>
The destructor is used to clean up an object before it is removed from
memory. The destructor is invoked by the <a href="#delete">delete</a> operator
when an object of the class is deleted. The destructor is named as in C++
(for example, the shape constructor fully qualified name is <i>shape::~shape</i>).
<p>The destructor always takes the object identifier (a unique value previously
generated and returned by the operator new) as the only parameter, which
must be named <b>this</b>.
<p>The base class(es) destructor(s) is(are) invoked at the end of the derived
class destructor body. Thus layered object destruction occurs in the same
order as in C++.
<p>Sample code of a class destructor:
<pre><tt>class shape {
&nbsp;&nbsp;&nbsp; proc ~shape {this} {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # implementation here
&nbsp;&nbsp;&nbsp; }
}</tt></pre>
Contrary to C++, a destructor cannot (nor does it need to) be <a href="#virtual">virtual</a>.
Even if it does nothing, a destructor <b>must</b> always be defined.
<h5>
<a NAME="proceduresnonstatic"></a>Non static</h5>
A <i>non static</i> member procedure performs some action on an object
of a class. The member procedure is named as a member function in C++ (for
example, the shape class move member procedure is known as <i>shape::move</i>
in the Tcl global namespace).
<p>The member procedure always takes the object identifier (a unique value
generated and returned by the operator new) as the first parameter, plus
eventually additional parameters as in the normal Tcl proc command. Arguments
with default values are allowed, and so are variable number of arguments.
In all cases, the first parameter must be named <b>this</b>.
<p>Sample code of a member procedure:
<pre><tt>proc shape::move {this x y} {
&nbsp;&nbsp;&nbsp; set ($this,x) $x
&nbsp;&nbsp;&nbsp; set ($this,y) $y
&nbsp;&nbsp;&nbsp; draw $this&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;# invoke another member procedure
}</tt></pre>
A non static member procedure may be a <a href="#virtual">virtual</a> procedure.
<h5>
<a NAME="proceduresstatic"></a>Static</h5>
A <i>static</i> member procedure performs some action independently of
the individual objects of a class. The member procedure is named as a member
function in C++ (for example, the shape class add static member procedure
is defined as <i>shape::add</i> outside its class definition, <i>add</i>
inside).
<p>However, with stooop, there is no static specifier: a member procedure
is considered static if its first parameter is not named <b>this</b>. Arguments
to the procedure are allowed as in the normal Tcl proc command. Arguments
with default values are also allowed, and so are variable number of arguments.
<p>Sample code of a static member procedure:
<pre><tt>proc shape::add {newShape} {
&nbsp;&nbsp;&nbsp; # append new shape to global list of shape
&nbsp;&nbsp;&nbsp; lappend ($shapes) $newShape
}</tt></pre>
Often, static member procedures access static member data (see <a href="#datastatic">Static
Member Data</a>).
<p>A static member procedure may not be a virtual procedure.
<h5>
<a NAME="copy"></a>Copy constructor</h5>
<i><b>Note</b>: if you never create objects by copying (which is generally
the case), you can skip this section.</i>
<p>Let us start by making it clear that stooop generates a default copy
constructor whenever a class main constructor is defined. This default
copy constructor just performs a simple per data member copy, as does C++.
<p>The user defined class copy constructor is optional as in C++. If it
exists, it will be invoked (instead of the default copy constructor) when
the operator <a href="#new">new</a> is invoked on an object of the class
or a derived class.
<p>The copy constructor takes 2 arguments: the <i>this</i> object identifier
used to initialize the data members of the object to be copied to, and
the <i>copy</i> identifier of the object to be copied from, as in:
<pre><tt>proc plane::plane {this copy} {
&nbsp;&nbsp;&nbsp; set ($this,wingspan) $($copy,wingspan)
&nbsp;&nbsp;&nbsp; set ($this,length) $($copy,length)
&nbsp;&nbsp;&nbsp; set ($this,engine) [new $($copy,engine)]
}</tt></pre>
As in regular member procedures, the first parameter name must be <b>this</b>,
whereas the second parameter must be named <b>copy</b> to differentiate
from the class constructor. In other words, the copy constructor always
takes 2 and only 2 arguments (named this and copy).
<p>The copy constructor must be defined when the default behavior (straightforward
data members copy) (see the <a href="#new">new operator</a>) is not sufficient,
as in the example above. It is most often used when the class object contains
sub objects. As in C++ when sub objects are referenced through pointers,
only the sub object identifiers (see them as pointers) are copied when
an object is copied, not the objects they point to. It is then necessary
to define a copy procedure that will actually create new sub objects instead
of just defaulting to copying identifiers.
<p>If the class has one or more base classes, then the copy constructor
must pass arguments to the base class(es) constructor(s), just as the main
constructor does, as in the following example:
<pre><tt>class ship {
&nbsp;&nbsp;&nbsp; proc ship {this length} {}
}
</tt>class carrier {}
<tt>proc carrier::carrier {this length} ship {$length} {}
proc carrier::carrier {this copy} ship {
&nbsp;&nbsp;&nbsp; $ship::($copy,length)
} {
&nbsp;&nbsp;&nbsp; set ship::($this,planes) {}
&nbsp;&nbsp;&nbsp; foreach plane $ship($copy,planes) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;# copy all the planes
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lappend ship($this,planes) [new $plane]
&nbsp;&nbsp;&nbsp; }
}</tt></pre>
The stooop library checks that the copy constructor properly initializes
the base class(es) through its(their) constructor(s) by using the regular
constructor as reference. Obviously and consequently, stooop also checks
that the regular constructor is defined prior to the copy constructor.
<p>If you use <a href="#array">member arrays</a>, you must copy them within
the copy constructor, as they are not automatically handled by stooop,
which only knows <a href="#data">member data</a> in the automatically generated
default copy constructor.
<h4>
<a NAME="data"></a>Member data</h4>
All class and object data is stored in an associative array local to the
class namespace (remember, a class is actually a namespace). The array
name is empty, and the corresponding Tcl variable declaration is automatically
inserted within class namespace and procedures (but you do not need to
worry about this transparent operation).
<p>Sample code:
<pre><tt>class shape {}
proc shape::shape {this x y} {
&nbsp;&nbsp;&nbsp; # set a few members of the class namespace empty named array
&nbsp;&nbsp;&nbsp; set ($this,x) $x
&nbsp;&nbsp;&nbsp; set ($this,y) $y
&nbsp;&nbsp;&nbsp; # now read them
&nbsp;&nbsp;&nbsp; puts "coordinates: $($this,x), $($this,y)"
}</tt></pre>
In order to access other classes data, whether they are base classes or
not, a fully qualified name is always required, whereas no special declaration
(global, variable, ...) is required.
<p>Sample code:
<pre><tt>proc circle::circle {this x y diameter} shape {$x $y} {
&nbsp;&nbsp;&nbsp; set ($this,diameter) $diameter
&nbsp;&nbsp;&nbsp; puts "coordinates: $shape::($this,x), $shape::($this,y)"
}</tt></pre>

<h5>
<a NAME="datanonstatic"></a>Non static</h5>
Non static data is indexed within the class array by prepending the object
identifier (return value of the <i>new</i> operator) to the actual member
name. A comma is used to separate the identifier and the member name.
<p>Much as an object pointer in C++ is unique, the object identifier in
<i>stooop</i>
is also unique. Access to any base class data is thus possible by directly
indexing the base class array.
<p>Sample code:
<pre><tt>proc shape::shape {this x y} {
&nbsp;&nbsp;&nbsp; set ($this,x) $x
&nbsp;&nbsp;&nbsp; set ($this,y) $y
}
proc circle::circle {this x y diameter} shape {$x $y} {
&nbsp;&nbsp;&nbsp; set ($this,diameter) $diameter
}
proc circle::print {this} {
&nbsp;&nbsp;&nbsp; puts "circle $this data:"
&nbsp;&nbsp;&nbsp; puts "diameter: $($this,diameter)"
&nbsp;&nbsp;&nbsp; puts "coordinates: $shape::($this,x), $shape::($this,y)"
}</tt></pre>

<h5>
<a NAME="datastatic"></a>Static</h5>
<i>Static</i> (as in C++) data members are simply stored without prepending
the object identifier to the member name, as in:
<pre><tt>proc shape::register {newShape} {
&nbsp;&nbsp;&nbsp; lappend (list) $newShape ;# append new shape to global list of shapes
}</tt></pre>

<h3>
<a NAME="keywords"></a>Commands</h3>
Only 4 new commands <a href="#class">class</a>, <a href="#new">new</a>,
<a href="#delete">delete</a>
and <a href="#virtual">virtual</a> need to be known in order to use <i>stooop</i>.
Furthermore, their meaning should be obvious to C++ programmers. There
is also a <a href="#classof">classof</a> command that you can use if you
need RTTI (runtime type identification).
<h4>
<a NAME="class"></a>class</h4>
The <b>class</b> command introduces a new class declaration.
<p>A class is also a namespace although you do not need to worry about
it, but it does have some nice side effects. The following code works as
expected:
<pre>class shape {
&nbsp;&nbsp;&nbsp; set (list) {} ;# initialize list of shapes, a static data member
&nbsp;&nbsp;&nbsp; proc shape {this x y} {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lappend (list) $this&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;# keep track of new shapes
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; ...
}</pre>
This works because all data for the class (static and non static) is held
in the empty named array, which the class command declares as a variable
(see the corresponding Tcl command) for the class namespace and within
every member procedure.
<p>Starting with version 3.2, nested classes are allowed, which makes the
following code possible:
<pre>class car {
&nbsp;&nbsp;&nbsp; proc car {this manufacturer type} {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set ($this,wheels) [list\
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [new wheel 18] [new wheel 18] [new wheel 18] [new wheel 18]\
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; ...
&nbsp;&nbsp;&nbsp; class part {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; class wheel {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; proc wheel {this diameter} car::part {} {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set ($this,diameter) $diameter
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; proc print {this} {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; puts "wheel of $($this,diameter) diameter"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
&nbsp;&nbsp;&nbsp; }
}</pre>
There is quite a lot to say about the example above.
<p>First, why would I use a nested class? Because it is cleaner that creating
<i>carPart</i>
and <i>carWheel</i> classes and saves on global namespace pollution.
<p>Second, why does "<i>new wheel</i>" work from inside the car constructor?
Because it invokes the <i>wheel::wheel</i> constructor, visible from the
car namespace.
<p>Third, why can't I simply derive wheel from <i>part</i> instead of <i>car::part</i>?
Well, you must fully qualify the class that you derive from because the
<i>part::part</i>
constructor is not visible from within the wheel namespace.
<p>Whenever you have a problem with nested classes, think in terms of namespaces,
as classes are indeed namespaces (it should be clear to you by now :-).
<h4>
<a NAME="new"></a>new</h4>
The <i>new</i> operator is used to create an object of a class, either
by explicit construction, or by copying an existing object.
<p>When explicitly creating an object, the first argument is the class
name and is followed by the arguments needed by the class constructor.
New when invoked generates a unique identifier for the object to be created.
This identifier is the value of the <b>this</b> parameter, first argument
to the class constructor, which is invoked by new.
<p>Sample code:
<pre><tt>proc shape::shape {this x y} {
&nbsp;&nbsp;&nbsp; set ($this,x) $x
&nbsp;&nbsp;&nbsp; set ($this,y) $y
}
set object [<b>new</b> shape 100 50]</tt></pre>
new generates a new object identifier, say 1234. shape constructor is then
called, as in:
<pre>shape::shape 1234 100 50</pre>
If the class is derived from one or more base classes, the base class(es)
constructor(s) will be automatically called in the proper order, as in:
<pre><tt>proc hydroplane::hydroplane {this wingspan length} plane {
&nbsp;&nbsp;&nbsp; $wingspan $length
} boat {
&nbsp;&nbsp;&nbsp; $length
} {}
set object [<b>new</b> hydroplane 10 7]</tt></pre>
new generates a new object identifier, say 1234, plane constructor is called,
as in:
<pre><tt>plane::plane 1234 10 7</tt></pre>
then boat constructor is called, as in:
<p><tt>boat::boat 1234 7</tt>
<p>finally hydroplane constructor is called, as in:
<p><tt>hydroplane::hydroplane 1234 10 7</tt>
<p>The new operator can also be used to copy objects when an object identifier
is its only argument. A new object of the same class is then created, copy
of the original object.
<p>An object is copied by copying all its data members (but not including
<a href="#array">member
arrays</a>) starting from the base class layers. If the copy constructor
procedure exists for any class layer, it is invoked by the <i>new</i> operator
<b>instead</b>
of the default data member copy procedure (see the <a href="#copy">copy
constructor</a> section for examples).
<p>Sample code:
<pre><tt>set plane [new plane 100 57 RollsRoyce]
set planes [list $plane [new $plane] [new $plane]]</tt></pre>

<h4>
<a NAME="delete"></a>delete operator</h4>
The <i>delete</i> operator is used to delete one or several objects. It
takes one or more object identifiers as argument(s). Each object identifier
is the value returned by <i>new</i> when the object was created. Delete
invokes the class destructor for each object to be deleted.
<p>Sample code:
<pre><tt>proc shape::shape {this x y} {}
proc shape::~shape {this} {

proc triangle::triangle {this x y} shape {$x $y} {}
proc triangle::~triangle {this} {}

proc circle::circle {this x y} shape {$x $y} {}
proc circle::~circle {this} {}

set circle [new circle 100 50]
set triangle [new triangle 200 50]
<b>delete</b> $circle $triangle</tt></pre>
circle identifier is set to, say 1234, triangle identifier is set to, say
1235. delete circle object first, circle destructor is invoked, as in:
<pre><tt>circle::~circle 1234</tt></pre>
then shape destructor is invoked, as in:
<p><tt>shape::~shape 1234</tt>
<p>then delete triangle object...
<p>For each object class, if it is derived from one or more base classes,
the base class(es) destructor(s) are automatically called in reverse order
of the construction order for base class(es) constructor(s), as in C++.
<p>If an error occurs during the deletion process, an error is returned
and the remaining delete argument objects are left undeleted.
<h4>
<a NAME="virtual"></a>virtual specifier</h4>
The <i>virtual</i> specifier may be used on member procedures to achieve
dynamic binding. A procedure in a base class can then be redefined (overloaded)
in the derived class(es).
<p>If the base class procedure is invoked on an object, it is actually
the derived class procedure which is invoked, if it exists<b>*</b>. If
the base class procedure has no body, then it is considered to be a pure
virtual and the derived class procedure is always invoked.
<p><b>*</b> <i>as in C++, virtual procedures invoked from the base class
constructor result in the base class procedure being invoked, not the derived
class procedure. In stooop, an error always occurs when pure virtual procedures
are invoked from the base class constructor (whereas in C++, behavior is
undefined).</i>
<br><i>* but there is a small difference with C++ behavior: for a virtual
procedure to keep his nature down the derived classes hierarchy, it must
be defined at each derivation level. That is, the virtual nature may be
lost, for example in indirectly derived classes (see example below). Fixing
this difference would have a non negligible impact on performance for a
small gain in usefulness.</i>
<p>Sample code:
<pre><tt>class shape {
&nbsp;&nbsp;&nbsp; proc shape {this x y} {}
&nbsp;&nbsp;&nbsp; # pure virtual draw: must be implemented in derived classes
&nbsp;&nbsp;&nbsp; <b>virtual</b> proc draw {this}
&nbsp;&nbsp;&nbsp; <b>virtual</b> proc transform {this x y} {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # base implementation
&nbsp;&nbsp;&nbsp; }
}
class circle {}
proc circle::circle {this x y} shape {$x $y} {}
proc circle::draw {this} {
&nbsp;&nbsp;&nbsp; # circle specific implementation
}
proc circle::transform {this} {
&nbsp;&nbsp;&nbsp; shape::_transform $this ;# use base class implementation
&nbsp;&nbsp;&nbsp; # add circle specific implementation here...
}

lappend shapes [new circle 100 50]
foreach object $shapes {
&nbsp;&nbsp;&nbsp; # draw and move each shape
&nbsp;&nbsp;&nbsp; shape::draw $object
&nbsp;&nbsp;&nbsp; shape::move $object 20 10
}</tt></pre>
It is possible to invoke a virtual procedure as a non virtual one, which
is handy when the derived class procedure must use the base class procedure.
In this case, directly invoking the virtual base class procedure would
result in an infinite loop. The non virtual base class procedure name is
simply the virtual procedure name with 1 underscore ( _ ) prepended to
the member procedure name (see sample code above).
<p>Constructors, destructors and static member procedures cannot be <i>virtual</i>.
<p>Sample code highlighting small difference with C++:
<pre>class A {
&nbsp;&nbsp;&nbsp; proc A {this} {}
&nbsp;&nbsp;&nbsp; proc ~A {this} {}
&nbsp;&nbsp;&nbsp; <b>virtual</b> proc p {this} {puts A}
}
class B {
&nbsp;&nbsp;&nbsp; proc B {this} A {} {}
&nbsp;&nbsp;&nbsp; proc ~B {this} {}
}
class C {
&nbsp;&nbsp;&nbsp; proc C {this} B {}{}
&nbsp;&nbsp;&nbsp; proc ~C {this} {}
&nbsp;&nbsp;&nbsp; <b>virtual</b> proc p {this} {puts C}
}

set object [new C]
A::p $object ;# prints "A" instead of "C"</pre>

<pre><b>virtual</b> proc B::p {this} {puts B}</pre>

<pre>A::p $object ;# now prints "C"</pre>

<h4>
<a NAME="classof"></a>classof operator</h4>
The <i>classof</i> command takes an object identifier as its only argument.
It returns the class name of the object (name used with new when the object
was created). Thus if needed, RTTI (runtime type identification) can be
used as in C++, for example to create "virtual constructors".
<pre>proc shape::shape {this x y} {}
set id [new shape 100 50]
puts "object $id class name is [<b>classof</b> $id]"</pre>

<h3>
<a NAME="package"></a>Package</h3>
For general information about the Tcl (version 7.5 and above) <i>package</i>
facilities, refer to the corresponding manual pages.
<h4>
<a NAME="installation"></a>Installation</h4>
A <i>pkgIndex.tcl</i> file is provided so that stooop and the <a href="#switched">switched</a>
class can be installed as a package. Refer to the <a href="INSTALL">INSTALL</a>
file for complete instructions and examples.
<h4>
<a NAME="creation"></a>Creation</h4>
Before creating a package that uses stooop, stooop itself <b>must</b> be
installed as a package (see above).
<p>If you have created an object oriented library which uses stooop, you
may want to make a package out of it. Unfortunately, using the default
Tcl <i>pkg_mkIndex</i> procedure (see the corresponding manual page) will
not work.
<p>Stooop checks that a base class constructor is defined before any of
its derived classes constructors. Thus, the first time a derived class
object is created, the base class definition file must be sourced to avoid
an error. The specific <i>mkpkgidx.tcl</i> utility handles such cases and
must be used to create stooop compatible package index files.
<p>Let us suppose that you created a library with different classes spread
in different source files: <i>lib1.tcl</i>, <i>lib2.tcl</i>, ..., <i>libn.tcl</i>.
Of course, some of these files may contain base classes for derived classes
in other files. As recommended in the pkg_mkIndex Tcl manual page, each
source file should contain a <b>package provide</b> command (although it
seems to be needed only in the first source file). For example, if your
package name is <i>foo</i> and the version <i>1.2</i>, the following line
should appear around the beginning of each of the libn.tcl files:
<pre>package provide foo 1.2</pre>
It is now time to create the <i>pkgIndex.tcl</i> file, which is the missing
piece for your foo package, with the <i>mkpkgidx.tcl</i> utility. The syntax
is:
<pre>interpreter mkpkgidx.tcl packageName file [file ...]</pre>
where <i>interpreter</i> can be either tclsh or wish depending on whether
your library uses Tk or not.
<p>Enter the following command in the directory where the libn.tcl files
reside:
<pre>$ tclsh mkpkgidx.tcl foo lib1.tcl lib2.tcl ... libn.tcl</pre>

<pre>or</pre>

<pre>$ wish mkpkgidx.tcl foo lib1.tcl lib2.tcl ... libn.tcl</pre>
For this to work, the source files must be ordered so that base classes
are defined before any of their derived classes. If not the case, such
errors are automatically caught by the stooop package index utility, which
uses the stooop library itself.
<p>If your package requires other packages and you do not wish to add the
corresponding "package require" to your package source files, use the -p
option, as in:
<pre>$ wish mkpkgidx.tcl -p ppp.1 -p qqq -p rrr.3.2 foo lib1.tcl lib2.tcl ... libn.tcl</pre>
Note that you may use as many -p option / value pairs as needed. Each package
name is optionally followed by its version number after a . separator.
If specified, the version number follows the same rules as the "package
require" Tcl command. Of course, each specified package must be installed
and working properly before attempting the mkpkgidx.tcl utility.
<p>Once this is done, a pkgIndex.tcl file will have been created in the
current directory. To install the package, enter for example:
<pre>$ mkdir /usr/local/lib/foo
$ cp pkgIndex.tcl lib1.tcl lib2.tcl ... libn.tcl /usr/local/lib/foo/</pre>
You may of course install the foo package in another directory: refer to
the pkg_mkIndex Tcl manual page for further instructions.
<p>Now in order to use your newly created packaged library in your application,
just insert the following 3 lines at the beginning of the application source
file:
<pre>package require stooop
namespace import stooop::*
package require foo 1.2</pre>

<h3>
<a NAME="examples"></a>Examples</h3>

<h4>
<a NAME="parallel"></a>Parallel with C++</h4>
For C++ programmers, this simple parallel with C++ may make things easier
to understand. First without virtual functions:
<p><b>C++:</b>
<pre><tt>&nbsp;&nbsp;&nbsp; class className {
&nbsp;&nbsp;&nbsp; public:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; someType someMember;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; className(someType parameter)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; someMember = parameter;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; className(className &amp;object)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; doSomething(someType parameter);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~className(void) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; };
&nbsp;&nbsp;&nbsp; someType className::doSomething(someType parameter)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; someType someValue;
&nbsp;&nbsp;&nbsp; className *someObject = new className(someValue);
&nbsp;&nbsp;&nbsp; someType a = someObject->doSomething(someValue);
&nbsp;&nbsp;&nbsp; someType b = someObject->someMember;
&nbsp;&nbsp;&nbsp; className *otherObject = new className(*someObject);
&nbsp;&nbsp;&nbsp; delete someObject;</tt></pre>
<b>(stooop'd up :) Tcl:</b>
<pre><tt>&nbsp;&nbsp;&nbsp; class className {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; proc className {this parameter} {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # new keeps track of object identifiers and passes a unique one
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # to the constructor
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set ($this,someMember) $parameter
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; proc className {this copy} {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # copy constructor
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; proc ~className {this} {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # delete invokes this procedure then takes care of deallocating
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # className array data members for this object identifier
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; proc className::doSomething {this parameter} {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; set someObject [new className $someValue]
&nbsp;&nbsp;&nbsp; # invokes className::className
&nbsp;&nbsp;&nbsp; set a [className::doSomething $someObject $someValue]
&nbsp;&nbsp;&nbsp; set b $className::($someObject,someMember)
&nbsp;&nbsp;&nbsp; # copy object, className copy constructor is invoked
&nbsp;&nbsp;&nbsp; set otherObject [new $someObject]
&nbsp;&nbsp;&nbsp; delete $someObject
&nbsp;&nbsp;&nbsp; # invokes className::~className then frees members data</tt></pre>
Now, with virtual functions:
<p><b>C++:</b>
<pre><tt>&nbsp;&nbsp;&nbsp; class baseClassName {
&nbsp;&nbsp;&nbsp; public:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void doSomething(someType) {}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; baseClassName(void) {}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual ~baseClassName(void) {}
&nbsp;&nbsp;&nbsp; };
&nbsp;&nbsp;&nbsp; class derivedClassName: public baseClassName {
&nbsp;&nbsp;&nbsp; public:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void doSomething(someType);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; derivedClassName(void) {}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~derivedClassName(void) {}
&nbsp;&nbsp;&nbsp; };
&nbsp;&nbsp;&nbsp; void derivedClassName::doSomething(someType parameter)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; derivedClassName *someObject = new derivedClassName();
&nbsp;&nbsp;&nbsp; someObject->doSomething(someValue);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // derived function actually called
&nbsp;&nbsp;&nbsp; cout &lt;&lt; typeid(*someObject).name() &lt;&lt; endl;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // print object class name
&nbsp;&nbsp;&nbsp; delete someObject;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // derived destructor called first</tt></pre>
<b>Tcl with stooop:</b>
<pre><tt>&nbsp;&nbsp;&nbsp; class baseClassName {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; proc baseClassName {this} {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # sub-class is remembered so that virtual procedures may be used
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; proc ~baseClassName {this} {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # cleanup at base level here...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual proc doSomething {this parameter} {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # derived class procedure with the same name may be invoked
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # any code that follows is not executed if this procedure is
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # overloaded in derived class
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; class derivedClassName {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; proc derivedClassName {this} baseClassName {} {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # base class constructor is automatically invoked
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; proc ~derivedClassName {this} {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # cleanup at derived level here...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # base class destructor is automatically invoked
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; proc derivedClassName::doSomething {this parameter} {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # code that follows is executed when base class procedure is called
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; set someObject [new derivedClassName]
&nbsp;&nbsp;&nbsp; # access object as base object, derived class procedure is actually invoked
&nbsp;&nbsp;&nbsp; baseClassName::doSomething $someObject $someValue
&nbsp;&nbsp;&nbsp; puts [classof $someObject]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;# print object class name
&nbsp;&nbsp;&nbsp; delete $someObject&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;# delete object</tt></pre>

<h4>
<a NAME="graphical"></a>Graphical demonstration</h4>
A demonstration using the Composite pattern from the great book Design
Patterns, Elements of Reusable Object Oriented Software, which I heartily
recommend.
<p>The pattern is used to define a class hierarchy of the graphic base
class, picture, oval and rectangle derived classes. A picture object can
contain any number of other graphic objects, thus allowing graphical composition.
<p>The following paragraphs drawn from the book best describe what the
Composite pattern does:
<blockquote><i>Compose objects into tree structures to represent part-whole
hierarchies. Composite lets clients treat individual objects and compositions
of objects uniformly.</i>
<p><i>The key to the Composite pattern is an abstract class that represents
both primitives and their containers. For the graphic system, this class
is Graphic. Graphic declares operations like Draw that are specific to
graphical objects. It also declares operations that all composite objects
share, such as operations for accessing and managing its children.</i>
<p><i>Gamma/Helm/Johnson/Vlissides, DESIGN PATTERNS, ELEMENTS OF REUSABLE
OBJECT-ORIENTED SOFTWARE, (c) 1995 by Addison-Wesley Publishing Company,
Reprinted by permission of Addison-Wesley Publishing Company, Inc.</i></blockquote>
Instructions:
<p>Run gdemo as in:
<pre>$ wish gdemo</pre>
Several buttons are placed below a canvas area. Picture, Rectangle and
Oval are used to create Graphic objects. Clear is used to delete all the
objects created so far, Exit is self explanatory.
<p>A Picture object can contain any number of Graphic objects, such as
other Picture objects, Rectangle objects, ...
<p>For each Graphic object, the point used for moving and for the object
coordinates is the upper left corner of the object.
<p>First create a Picture object by clicking on the Picture button. Move
the red rectangle that appears by drag clicking on any of its edges. Then
create a Rectangle object by clicking on the Rectangle button. Drag the
Rectangle object in the Picture object, it is then a child of the Picture
object.
<p>Move the Picture object to verify that its Rectangle child moves along.
<p>Create another Picture object and place an Oval object within.
<p>Move that Picture object to verify that its Oval child moves along.
<p>Now move the upper left corner of that last Picture within the first
Picture area.
<p>Then move that Picture to verify that all the Graphic objects move along.
<h4>
<a NAME="widget"></a>Widget class</h4>
A widget usually can take a variable number of option / value pairs as
arguments when created and any time later when configured. It is a good
application for the variable number of arguments technique.
<p>Sample code (without error checking):
<pre><tt>class widget {
&nbsp;&nbsp;&nbsp; proc widget {this parent args} {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # create Tk widget(s)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # set widget options default in an array
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; array set options {-background white -width 10}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; array set options $args&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;# then overwrite with user options
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eval configure $this [array get options]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;# then configure
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; virtual proc configure {this args} {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach {option value} $args {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch -- $option {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -background {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;# filter widget specific options here
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set ($this,background) $value
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # configure Tk widget(s)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; }
}

class gizmo {}
proc gizmo::gizmo {this parent args} widget {$parent $args} {
&nbsp;&nbsp;&nbsp; # create more Tk widget(s)
&nbsp;&nbsp;&nbsp; # set gizmo options default in an array
&nbsp;&nbsp;&nbsp; array set options {-spacetimecoordinates {0 0 0 now}}
&nbsp;&nbsp;&nbsp; array set options $args&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;# then overwrite with user options
&nbsp;&nbsp;&nbsp; eval ownConfigure $this [array get options]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;# then configure
}
proc gizmo::ownConfigure {this args} {
&nbsp;&nbsp;&nbsp; foreach {option value} $args {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch -- $option {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;# filter gizmo specific options here
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -spacetimecoordinates {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set ($this,location) $value
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # configure Tk widget(s)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; }
}
proc gizmo::configure {this args} {
&nbsp;&nbsp;&nbsp; eval ownConfigure $this $args&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;# configure at gizmo level
&nbsp;&nbsp;&nbsp; eval widget::_configure $this $args&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;# configure at widget level
}

new gizmo . -width 20 -spacetimecoordinates {1p 10ly 2p 24.2y}</tt></pre>
In this example, invalid (unknown) options are simply ignored.
<h4>
<a NAME="array"></a>Member array</h4>
You simply cannot use a member array, as member data is already held in
an array. But you can use a namespace array, with a name specific to the
object, including the object identifier. Just make sure the array is deleted
in the destructor.
<p>Sample code:
<pre><tt>class container {
&nbsp;&nbsp;&nbsp; proc container {this} {}
&nbsp;&nbsp;&nbsp; proc ~container {this} {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; variable ${this}data
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unset ${this}data
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; proc container::add {this item id} {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; variable ${this}data
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set ${this}data($id) $item
&nbsp;&nbsp;&nbsp; }
}</tt></pre>
Memory management of the array is the programmer's responsibility, as is
its duplication when copying objects. For example, use the following code
if you ever copy objects with member arrays:
<pre><tt>class container {
&nbsp;&nbsp;&nbsp; proc container {this} {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;# main constructor
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;# default copy constructor has been generated at this point
&nbsp;&nbsp;&nbsp; proc container {this copy} {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;# copy constructor (replaces default one)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; variable ${this}data
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; variable ${copy}data
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; array set ${this}data [array get ${copy}data]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;# copy member array
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; ...
}</tt></pre>

<h3>
<a NAME="utility"></a>Utility classes</h3>

<h4>
<a NAME="switched"></a>switched</h4>
<i><b>Note</b>: if you have been using scwoop (a stooop based mega widget
extension to the Tk widget library), you must certainly know about the
composite class. The switched class is a generic (not widget oriented)
derivative of the composite class.</i>
<p>Find the complete documentation <a href="switched.htm">here</a>.
<h3>
<a NAME="debugging"></a>Debugging</h3>
As stooop is meant to be lean and fast, no checking is done during run-time,
that is after all classes and their procedures have been defined.
<p>Starting from version 3.3, debugging aids were added to the stooop library
(still held in a single file). Member checking insures that basic object
oriented concepts and rules are applied. Tracing provides means for member
procedures and data access logging to a file or to the screen.
<p>The above features are triggered and configured using environment variables.
When not in use, they have absolutely no impact on stooop's performance
(however, if you are really picky, you could say that since the stooop.tcl
file has grown larger, load time got longer :).
<p>Please note that any stooop debugging environment variable must be set
<b>prior</b>
to the stooop library being loaded:
<pre>$ STOOOPTRACEDATA=stdout
$ export STOOOPTRACEDATA
$ tclsh myfile.tcl</pre>
around the beginning of myfile.tcl:
<pre>...
set env(STOOOPCHECKPROCEDURES) 1
source stooop.tcl
namespace import stooop::*
set env(STOOOPCHECKDATA) 1
...</pre>
In the example above, data tracing is enabled as well as procedure checking,
but data checking is not turned on.
<h4>
<a NAME="check"></a>Member check</h4>
Both procedure and data member checking can be activated by setting the
single environment variable STOOOPCHECKALL to any value. Of course only
one of those features can be activated as described below.
<p><i>Note: if you have an idea about any other thing that could be checked
in the following sections, please share it with <a href="mailto:jfontain@free.fr">me</a>.</i>
<h5>
<a NAME="procedurecheck"></a>Procedure</h5>
Procedure checking is activated by setting the environment variable STOOOPCHECKPROCEDURES
to any value. The stooop library will then generate an error while the
application is running in the following cases:
<ul>
<li>
an invalid <i>this</i> parameter (a non existing object identifier) is
passed as argument to a non static member procedure</li>

<li>
the object identified by the <i>this</i> parameter passed as argument to
a class non static member procedure is neither an instance of the procedure
class nor an instance of a derived class (at any level of derivation) of
the procedure class.</li>

<li>
a pure interface class (a class with at least 1 pure virtual member procedure)
is instanciated</li>
</ul>

<h5>
<a NAME="datacheck"></a>Data</h5>
Procedure checking is activated by setting the environment variable STOOOPCHECKDATA
to any value. The stooop library will then generate an error while the
application is running in the following cases:
<ul>
<li>
in a class namespace but outside a member procedure, a data member of another
class is written or unset</li>

<li>
in a class member procedure (static or not), a data member of another class
is written or unset</li>

<li>
in a non static member procedure, a data member of an object different
from the object identified by the <i>this</i> parameter passed as argument
is written or unset</li>
</ul>

<h4>
<a NAME="trace"></a>Member trace</h4>
Tracing is activated by setting a specific environment variable to either
<i>stdout</i>,
<i>stderr</i>
or any file name that can be created and written to by the user. Setting
the STOOOPTRACEALL variable enables both procedure and data tracing. Of
course only one of those features can be activated as described below.
<h5>
<a NAME="proceduretrace"></a>Procedure</h5>
Procedure tracing is activated by setting the environment variable STOOOPTRACEPROCEDURES
to either <i>stdout</i>, <i>stderr</i> or a file name. The stooop library
will then output to the specified channel 1 line of informational text
for each member procedure invocation.
<p>The user can define the output format by redefining the STOOOPTRACEPROCEDURESFORMAT
(look at the beginning of the stooop.tcl file for the default format).
The following substitutions will be performed prior to the output:
<ul>
<li>
<b>%C</b> by the fully qualified class name</li>

<li>
<b>%c</b> by the class name (tail of the fully qualified class name)</li>

<li>
<b>%P</b> by the fully qualified procedure name</li>

<li>
<b>%p</b> by the procedure name (tail of the fully qualified procedure
name)</li>

<li>
<b>%O</b> by the object identifier (<i>this</i> value)</li>

<li>
<b>%a</b> by the remaining procedure arguments (not including <i>this</i>)</li>
</ul>
At the time this document is being written, the default format is:
<pre>class: %C, procedure: %p, object: %O, arguments: %a</pre>
example output from the gdemo application:
<pre>class: picture, procedure: constructor, object: 1, arguments: .canvas
class: graphic, procedure: constructor, object: 1, arguments: .canvas 1
class: rectangle, procedure: constructor, object: 2, arguments: .canvas
class: graphic, procedure: constructor, object: 2, arguments: .canvas 2
class: graphic, procedure: moveTo, object: 2, arguments: 13 4
class: graphic, procedure: _moveTo, object: 2, arguments: 13 4
class: graphic, procedure: moveTo, object: 2, arguments: 18 9
class: graphic, procedure: add, object: 1, arguments: 2
class: picture, procedure: add, object: 1, arguments: 2
class: graphic, procedure: add, object: 2, arguments: 2
class: rectangle, procedure: add, object: 2, arguments: 2
class: picture, procedure: destructor, object: 1, arguments:
class: graphic, procedure: destructor, object: 1, arguments:
class: rectangle, procedure: destructor, object: 2, arguments:
class: graphic, procedure: destructor, object: 2, arguments:</pre>

<h5>
<a NAME="datatrace"></a>Data</h5>
Data tracing is activated by setting the environment variable STOOOPTRACEDATA
to either <i>stdout</i>, <i>stderr</i> or a file name. The stooop library
will then output to the specified channel 1 line of informational text
for each member data access. By default, all read, write and unsetting
accesses are reported, but the user can set the STOOOPTRACEDATAOPERATIONS
environment variable to any combination of the <i>r</i>, <i>w</i> and <i>u</i>
letters for more specific tracing (please refer to the <i>trace</i> Tcl
manual page for more information).
<p>Note that operations internal to the stooop library, such as automatic
unsetting of data members during objects destruction do not appear in the
trace.
<p>The user can define the output format by redefining the STOOOPTRACEDATAFORMAT
(look at the beginning of the stooop.tcl file for the default format).
The following substitutions will be performed prior to the output:
<ul>
<li>
<b>%C</b> by the fully qualified class name</li>

<li>
<b>%c</b> by the class name (tail of the fully qualified class name)</li>

<li>
<b>%P</b> by the fully qualified procedure name</li>

<li>
<b>%p</b> by the procedure name (tail of the fully qualified procedure
name)</li>

<li>
<b>%A</b> by the fully qualified array name</li>

<li>
<b>%m</b> by the data member name (right after the <i>this,</i> array name
part for a non static data member)</li>

<li>
<b>%O</b> by the object identifier (<i>this</i> value or empty for a static
procedure)</li>

<li>
<b>%o</b> by the access operation (<i>read</i>, <i>write</i> or <i>unset</i>)</li>

<li>
<b>%v</b> by the new or current value (empty for an <i>unset</i> operation)</li>
</ul>
At the time this document is being written, the default format is:
<pre>class: %C, procedure: %p, array: %A, object: %O, member: %m, operation: %o, value: %v</pre>
example output from the gdemo application:
<pre>class: graphic, procedure: constructor, array: graphic::, object: 1, member: canvas, operation: write, value: .canvas
class: graphic, procedure: constructor, array: graphic::, object: 1, member: item, operation: write, value: 1
class: picture, procedure: constructor, array: picture::, object: 1, member: graphics, operation: write, value:&nbsp;
class: picture, procedure: moveTo, array: graphic::, object: 1, member: canvas, operation: read, value: .canvas
class: picture, procedure: moveTo, array: graphic::, object: 1, member: item, operation: read, value: 1
class: picture, procedure: moveBy, array: picture::, object: 1, member: graphics, operation: read, value:&nbsp;
class: graphic, procedure: _moveBy, array: graphic::, object: 1, member: canvas, operation: read, value: .canvas
class: graphic, procedure: _moveBy, array: graphic::, object: 1, member: item, operation: read, value: 1
class: graphic, procedure: constructor, array: graphic::, object: 2, member: canvas, operation: write, value: .canvas
class: graphic, procedure: constructor, array: graphic::, object: 2, member: item, operation: write, value: 2
class: graphic, procedure: _moveTo, array: graphic::, object: 2, member: canvas, operation: read, value: .canvas
class: graphic, procedure: _moveTo, array: graphic::, object: 2, member: item, operation: read, value: 2
class: graphic, procedure: _moveTo, array: graphic::, object: 2, member: canvas, operation: read, value: .canvas
class: graphic, procedure: _moveTo, array: graphic::, object: 2, member: item, operation: read, value: 2
class: graphic, procedure: _moveTo, array: graphic::, object: 2, member: canvas, operation: read, value: .canvas
class: graphic, procedure: _moveTo, array: graphic::, object: 2, member: item, operation: read, value: 2
class: graphic, procedure: _moveTo, array: graphic::, object: 2, member: canvas, operation: read, value: .canvas
class: graphic, procedure: _moveTo, array: graphic::, object: 2, member: item, operation: read, value: 2
class: picture, procedure: add, array: graphic::, object: 1, member: canvas, operation: read, value: .canvas
class: picture, procedure: add, array: graphic::, object: 1, member: item, operation: read, value: 2
class: picture, procedure: add, array: graphic::, object: 1, member: canvas, operation: read, value: .canvas
class: picture, procedure: add, array: graphic::, object: 1, member: item, operation: read, value: 1
class: graphic, procedure: destructor, array: graphic::, object: 1, member: canvas, operation: read, value: .canvas
class: graphic, procedure: destructor, array: graphic::, object: 1, member: item, operation: read, value: 1
class: graphic, procedure: destructor, array: graphic::, object: 2, member: canvas, operation: read, value: .canvas
class: graphic, procedure: destructor, array: graphic::, object: 2, member: item, operation: read, value: 2</pre>

<h4>
<a NAME="objects"></a>Objects</h4>
Objects checking can be activated by setting the single environment variable
STOOOPCHECKOBJECTS to any value. The following stooop namespace procedures
then become available for debugging; <i>printObjects</i>, <i>record</i>
and <i>report</i>.
<p>Before outputting any data, all the object checking procedures print
which procedure they were invoked from, or the namespace name if invoked
from a namespace body or "<i>main script</i>" if invoked outside any procedure
or namespace.
<h5>
<a NAME="objects.printing"></a>Printing</h5>
The <i>stooop::printObjects</i> procedure when invoked prints an ordered
list of existing objects. The objects are printed in creation order, with
the oldest (lowest identifier) first. The printObjects procedure takes
an optional class pattern (as in the Tcl "<i>array names</i>" or "<i>string
match</i>" commands) for limiting the output to objects of certain classes,
as the following example shows (classes are assumed to exist and be valid):
<pre>% new foo
1
% stooop::printObjects
stooop::printObjects invoked from main script:
::foo(1) created in main script
% new bar
2
% stooop::printObjects
stooop::printObjects invoked from main script:
::foo(1) created in main script
::bar(2) created in main script
% new Foo
3
% stooop::printObjects ::?oo
stooop::printObjects invoked from main script:
::foo(1) created in main script
::Foo(3) created in main script
% new barmaid
4
% stooop::printObjects ::bar*
stooop::printObjects invoked from main script:
::bar(2) created in main script
::barmaid(4) created in main script</pre>
Please note that all object classes are always fully qualified, so do not
forget about the <b>::</b> header in the patterns.
<h5>
<a NAME="objects.recording"></a>Recording</h5>
By invoking the <i>stooop::record</i> procedure, you take a snapshot of
all existing stooop objects at the time of invocation. Reporting can then
be used at a later time to see which objects were created or deleted in
the interval.
<p>The record procedure does not take any arguments and it only prints
its context of invocation.
<h5>
<a NAME="objects.reporting"></a>Reporting</h5>
The <i>stooop::report</i> procedure prints the created and deleted objects
since the stooop::record procedure was invoked last. It optionally takes
a pattern argument in order to limit the output to a specific set of classes,
as for the printObjects procedure. A <b>+</b> sign is placed at the beginning
of each created object description line in the output trace. A <b>-</b>
sign is placed at the beginning of each deleted object description line
in the output trace.
<p>Reporting is typically used between 2 spots in the debugged application
code: the first spot where a bunch of objects (which can include sub objects)
are created, the second spot where all or most of these objects are supposed
to be deleted. On the first spot, stooop::record is invoked whereas on
the second spot, the stooop::report invocation will print the created and/or
deleted objects, in other words the "object difference" between the 2 spots.
In most cases, the programmer would expect a difference of 0 objects, sign
of a well behaved application, memory wise.
<p>Consider the following example:
<pre>class foo {
&nbsp;&nbsp;&nbsp; proc foo {this} {}
&nbsp;&nbsp;&nbsp; proc ~foo {this} {}
}
class bar {
&nbsp;&nbsp;&nbsp; proc bar {this} {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new foo
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; proc ~bar {this} {}
}
stooop::record
delete [new bar]
stooop::report
stooop::record
delete 2
stooop::report</pre>
It gives the following result:
<pre>stooop::record invoked from main script
stooop::report invoked from main script:
+ ::foo(2) created in ::bar::bar
stooop::record invoked from main script
stooop::report invoked from main script:
- ::foo(2) created in ::bar::bar</pre>
Examining the printout, one can see that the bar class does not properly
clean things up as the foo sub object is left undeleted.
<h3>
<a NAME="notes"></a>Notes</h3>

<h4>
<a NAME="design"></a>On design choices</h4>
Performance would have to as good as possible.
<p>A familiar C++ syntax should serve as a model (not all, though, I didn't
feel like writing 700 pages of documentation :-).
<p>Tcl being a non declarative language (which I really enjoy), stooop
would have to try to comply with that approach.
<p>Error checking would have to be strong with little impact on performance.
<h4>
<a NAME="implementation"></a>On implementation</h4>
For a Tcl only extension, I think performance is the main issue. The performance
/ functionality compromise was handled by moving as much processing as
possible to the preprocessing stage, handled by the proc and virtual commands.
Furthermore, all the costly error checking could be done there as well,
having no impact on runtime performance.
<p>The delete operation was greatly simplified, especially for classes
that would require a virtual destructor in C++, by storing in an array
the class of each object. It then became trivial to delete any object from
its identifier only. This approach has an impact on memory use, though,
but I consider that one is not very likely to create a huge number of objects
in a Tcl application. Furthermore, a classof RTTI operator was then added
with no effort.
<p>Stooop learns class hierarchies through the constructor definition which
serves as an implementation as well, thus (kind of) better fitting the
non declarative nature of Tcl.
<p>All member data is public but access control is somewhat enforced by
having to explicitly name the class layer of external data being accessed.
<p>Since, for performance reasons, the stooop library performs very little
checking during run-time (after all classes and their procedures were defined),
debugging aids are provided starting from version 3.3. They attempt to
insure that your code is well written in an object oriented sense. They
also provide means for tracing data access and procedures.
<h3>
<a NAME="misc"></a>Miscellaneous information</h3>
For downloading other Tcl software (such as scwoop, moodss, ...), visit
my <a href="http://jfontain.free.fr/">web page</a>.
<p>Send your comments, complaints, ... to <a href="mailto:jfontain@free.fr">Jean-Luc
Fontaine</a>.
</body>
</html>
