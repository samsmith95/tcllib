# me_util.test:  tests for the AST utilities -*- tcl -*-
#
# This file contains a collection of tests for one or more of the Tcl
# built-in commands.  Sourcing this file into Tcl runs the tests and
# generates output for errors.  No output means no errors were found.
#
# Copyright (c) 2005 Andreas Kupries <andreas_kupries@users.sourceforge.net>
# All rights reserved.
#
# RCS: @(#) $Id: me_util.test,v 1.1 2005/09/28 04:51:22 andreas_kupries Exp $

if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest 2.1
    namespace import ::tcltest::*
} elseif {![package vsatisfies [package present tcltest] 2.0]} {
    puts "Aborting tests for [file tail [info script]]"
    puts "Requiring tcltest 2.1, have [package present tcltest]"
    return	
}	

# ### ### ### ######### ######### #########
## Ensure we test _this_ local copy and one installed somewhere else.

package forget grammar::me::util
package forget struct::tree

catch {namespace delete ::grammar::me::util}

# We do not delete struct::tree, as it might come from a
# tcllibc. Beyond that this testsuite does not care which tree
# implementation is in use. In the future it might try to use all
# available implementations, as additional testing of them instead of
# the AST code.

set moddir [file dirname [file dirname [file join [pwd] [info script]]]]

if {[catch {source [file join $moddir grammar_me me_util.tcl]} msg]} {
    puts "skipped [file tail [info script]]: $msg"
    return
}
if {[catch {source [file join $moddir struct tree.tcl]} msg]} {
    puts "skipped [file tail [info script]] (tree.tcl): $msg"
    return
}

puts "- grammar::me::util [package provide grammar::me::util]"
puts "  - struct::tree [package provide struct::tree]"

# ### ### ### ######### ######### #########
## Pre-requisites. An AST value and various serializations of plain
## and extended tree representations of the same AST. Plus helper
## commands for the checking of trees for structural equality.

set ast {a 0 56 {{} 3 15} {b 16 40 {d 16 20} {{} 21 40}} {c 41 56}}

set serial_0 {
    root {} {}
    node0 0 {type nonterminal detail a range  {0 56}}
    node1 3 {type terminal             range  {3 15}}
    node2 3 {type nonterminal detail b range {16 40}}
    node3 3 {type nonterminal detail c range {41 56}}
    node4 9 {type nonterminal detail d range {16 20}}
    node5 9 {type terminal             range {21 40}}
}

set serial_0a {
    node0 {} {type nonterminal detail a range  {0 56}}
    node1  0 {type terminal             range  {3 15}}
    node2  0 {type nonterminal detail b range {16 40}}
    node3  0 {type nonterminal detail c range {41 56}}
    node4  6 {type nonterminal detail d range {16 20}}
    node5  6 {type terminal             range {21 40}}
}

set serial_1 {
    root  {} {}
    foo    0 {}
    node0  3 {type nonterminal detail a range  {0 56}}
    node1  6 {type terminal             range  {3 15}}
    node2  6 {type nonterminal detail b range {16 40}}
    node3  6 {type nonterminal detail c range {41 56}}
    node4 12 {type nonterminal detail d range {16 20}}
    node5 12 {type terminal             range {21 40}}
}

set serial_2 {
    root {} {}
    node0 0 {type nonterminal detail a range  {0 56} range_lc  {{l0 c0} {l56 c56}}}
    node1 3 {type terminal             range  {3 15} range_lc  {{l3 c3} {l15 c15}} detail {{T3 l3 c3 L3} {T4 l4 c4 L4} {T5 l5 c5 L5} {T6 l6 c6 L6} {T7 l7 c7 L7} {T8 l8 c8 L8} {T9 l9 c9 L9} {T10 l10 c10 L10} {T11 l11 c11 L11} {T12 l12 c12 L12} {T13 l13 c13 L13} {T14 l14 c14 L14} {T15 l15 c15 L15}}}
    node2 3 {type nonterminal detail b range {16 40} range_lc {{l16 c16} {l40 c40}}}
    node3 3 {type nonterminal detail c range {41 56} range_lc {{l41 c41} {l56 c56}}}
    node4 9 {type nonterminal detail d range {16 20} range_lc {{l16 c16} {l20 c20}}}
    node5 9 {type terminal             range {21 40} range_lc {{l21 c21} {l40 c40}} detail {{T21 l21 c21 L21} {T22 l22 c22 L22} {T23 l23 c23 L23} {T24 l24 c24 L24} {T25 l25 c25 L25} {T26 l26 c26 L26} {T27 l27 c27 L27} {T28 l28 c28 L28} {T29 l29 c29 L29} {T30 l30 c30 L30} {T31 l31 c31 L31} {T32 l32 c32 L32} {T33 l33 c33 L33} {T34 l34 c34 L34} {T35 l35 c35 L35} {T36 l36 c36 L36} {T37 l37 c37 L37} {T38 l38 c38 L38} {T39 l39 c39 L39} {T40 l40 c40 L40}}}
}

set serial_2a {
    node0 {} {type nonterminal detail a range  {0 56}}
    node1  0 {type terminal             range  {3 15}}
    node2  0 {type nonterminal detail b range {16 40}}
    node3  0 {type nonterminal detail c range {41 56}}
    node4  6 {type nonterminal detail d range {16 20}}
    node5  6 {type terminal             range {21 40}}
}

set serial_3 {
    root  {} {}
    foo    0 {}
    node0  3 {type nonterminal detail a range  {0 56} range_lc  {{l0 c0} {l56 c56}}}
    node1  6 {type terminal             range  {3 15} range_lc  {{l3 c3} {l15 c15}} detail {{T3 l3 c3 L3} {T4 l4 c4 L4} {T5 l5 c5 L5} {T6 l6 c6 L6} {T7 l7 c7 L7} {T8 l8 c8 L8} {T9 l9 c9 L9} {T10 l10 c10 L10} {T11 l11 c11 L11} {T12 l12 c12 L12} {T13 l13 c13 L13} {T14 l14 c14 L14} {T15 l15 c15 L15}}}
    node2  6 {type nonterminal detail b range {16 40} range_lc {{l16 c16} {l40 c40}}}
    node3  6 {type nonterminal detail c range {41 56} range_lc {{l41 c41} {l56 c56}}}
    node4 12 {type nonterminal detail d range {16 20} range_lc {{l16 c16} {l20 c20}}}
    node5 12 {type terminal             range {21 40} range_lc {{l21 c21} {l40 c40}} detail {{T21 l21 c21 L21} {T22 l22 c22 L22} {T23 l23 c23 L23} {T24 l24 c24 L24} {T25 l25 c25 L25} {T26 l26 c26 L26} {T27 l27 c27 L27} {T28 l28 c28 L28} {T29 l29 c29 L29} {T30 l30 c30 L30} {T31 l31 c31 L31} {T32 l32 c32 L32} {T33 l33 c33 L33} {T34 l34 c34 L34} {T35 l35 c35 L35} {T36 l36 c36 L36} {T37 l37 c37 L37} {T38 l38 c38 L38} {T39 l39 c39 L39} {T40 l40 c40 L40}}}
}

proc tree_equal {ta tb} {
    set tna [llength [$ta nodes]]
    set tnb [llength [$tb nodes]]

    if {$tna != $tnb}  {
	puts "sizes: $ta n = $tna != $tnb = $tb n"
	return 0
    }
    node_equal $ta $tb [$ta rootname] [$tb rootname]
}

proc node_equal {ta tb na nb} {
    if {[dictsort [$ta getall $na]] ne [dictsort [$tb getall $nb]]} {
	puts "attr delta $ta $na: [dictsort [$ta getall $na]]\n           $tb $nb: [dictsort [$tb getall $nb]]"
	return 0
    }
    if {[$ta numchildren $na] != [$tb numchildren $nb]} {
	puts "#c $na / $nb: [$ta numchildren $na] != [$tb numchildren $nb]"
	return 0
    }
    foreach ca [$ta children $na] cb [$tb children $nb] {
	if {![node_equal $ta $tb $ca $cb]} {
	    return 0
	}
    }
    return 1
}

proc dictsort {dict} {
    array set a $dict
    set out [list]
    foreach key [lsort [array names a]] {
	lappend out $key $a($key)
    }
    return $out
}

proc tsdump {ser} {
    set line {}
    foreach {a b c} $ser {
	lappend line [list $a $b $c]
    }
    return \t[join $line \n\t]
}

# ### ### ### ######### ######### #########
## Suite 1: Values to tree objects.

test ast2tree-1.0 {Call without enough arguments} \
    -returnCodes error \
    -body {
	grammar::me::util::ast2tree
    } -result {wrong # args: should be "grammar::me::util::ast2tree ast tree ?root?"}

test ast2tree-1.1 {Call with to many arguments} \
    -returnCodes error \
    -body {
	grammar::me::util::ast2tree a b c d
    } -result {wrong # args: should be "grammar::me::util::ast2tree ast tree ?root?"}

test ast2tree-1.2 {Call with bad tree object} \
    -returnCodes error \
    -body {
	grammar::me::util::ast2tree {a 1 2} foo
    } -result {invalid command name "foo"}

test ast2tree-1.3 {Call with bad node in tree} \
    -returnCodes error \
    -setup {
	struct::tree t
    } -cleanup {
	t destroy
    } -body {
	grammar::me::util::ast2tree {a 1 2} t blub
    } -result {parent node "blub" does not exist in tree "::t"}

test ast2tree-1.4 {Call with bad AST, terminal node with children} \
    -returnCodes error \
    -setup {
	struct::tree t
    } -cleanup {
	t destroy
    } -body {
	grammar::me::util::ast2tree {{} 1 2 {a 3 4} {c 5 6}} t
    } -result {Terminal node "{} 1 2" has children}

foreach {n range} {
    0 {0  a}
    1 {0 -1}
    2 {a  0}
    3 {-1 0}
    4 {a  b}
    5 {a -1}
    6 {-1 b}
    7 {-1 -1}
} {
    test ast2tree-1.5.$n {Call with bad AST, bad location information} \
	-returnCodes error \
	-setup {
	    struct::tree t
	} -cleanup {
	    t destroy
	} -body {
	    grammar::me::util::ast2tree [linsert $range 0 {}] t
	} -result "Bad range information \"[lrange $range 0 end]\""
}

foreach {n node} {
    0 {}
    1 {{}}
    2 {{} 0}
} {
    test ast2tree-1.6.$n {Call with bad AST, node representation too short} \
	-returnCodes error \
	-setup {
	    struct::tree t
	} -cleanup {
	    t destroy
	} -body {
	    grammar::me::util::ast2tree $node t
	} -result "Bad node \"[lrange $node 0 end]\", not enough elements"
}



test ast2tree-2.0 {Regular conversion} \
    -setup {
	struct::tree t
	struct::tree tex deserialize $serial_0
    } -cleanup {
	t   destroy
	tex destroy
    } -body {
	grammar::me::util::ast2tree $ast t
	tree_equal t tex
    } -result 1

test ast2tree-2.1 {Regular conversion under non-root root} \
    -setup {
	struct::tree t
	t insert root end foo
	struct::tree tex deserialize $serial_1
    } -cleanup {
	t   destroy
	tex destroy
    } -body {
	grammar::me::util::ast2tree $ast t foo
	tree_equal t tex
    } -result 1

# ### ### ### ######### ######### #########
## Suite 2: Values to extended tree objects

proc tinfo {cmd args} {
    # 'tinfo lc 0' is a nice check that things work.
    switch -exact -- $cmd {
	lc  {
	    return [list l[lindex $args 0] c[lindex $args 0]]
	}
	tok {
	    foreach {s e} $args break
	    set res {}
	    for {set i $s} {$i <= $e} {incr i} {
		lappend res [list T$i l$i c$i L$i]
	    }
	    return $res
	}
    }
    return -code error BOGUS
}

test ast2etree-1.0 {Call without enough arguments} \
    -returnCodes error \
    -body {
	grammar::me::util::ast2etree
    } -result {wrong # args: should be "grammar::me::util::ast2etree ast mcmd tree ?root?"}

test ast2etree-1.1 {Call with to many arguments} \
    -returnCodes error \
    -body {
	grammar::me::util::ast2etree a b c d e
    } -result {wrong # args: should be "grammar::me::util::ast2etree ast mcmd tree ?root?"}

test ast2etree-1.2 {Call with bad tree object} \
    -returnCodes error \
    -body {
	grammar::me::util::ast2etree {a 1 2} tinfo foo
    } -result {invalid command name "foo"}

test ast2etree-1.3 {Call with bad info callback} \
    -returnCodes error \
    -setup {
	struct::tree t
    } -cleanup {
	t destroy
    } -body {
	grammar::me::util::ast2etree {a 1 2} foo t
    } -result {invalid command name "foo"}

test ast2etree-1.4 {Call with bad node in tree} \
    -returnCodes error \
    -setup {
	struct::tree t
    } -cleanup {
	t destroy
    } -body {
	grammar::me::util::ast2etree {a 1 2} tinfo t blub
    } -result {parent node "blub" does not exist in tree "::t"}

test ast2etree-1.6 {Call with bad AST, terminal node with children} \
    -returnCodes error \
    -setup {
	struct::tree t
    } -cleanup {
	t destroy
    } -body {
	grammar::me::util::ast2etree {{} 1 2 {a 3 4} {c 5 6}} tinfo t
    } -result {Terminal node "{} 1 2" has children}

foreach {n range} {
    0 {0  a}
    1 {0 -1}
    2 {a  0}
    3 {-1 0}
    4 {a  b}
    5 {a -1}
    6 {-1 b}
    7 {-1 -1}
} {
    test ast2etree-1.7.$n {Call with bad AST, bad location information} \
	-returnCodes error \
	-setup {
	    struct::tree t
	} -cleanup {
	    t destroy
	} -body {
	    grammar::me::util::ast2etree [linsert $range 0 {}] tinfo t
	} -result "Bad range information \"[lrange $range 0 end]\""
}

foreach {n node} {
    0 {}
    1 {{}}
    2 {{} 0}
} {
    test ast2tree-1.8.$n {Call with bad AST, node representation too short} \
	-returnCodes error \
	-setup {
	    struct::tree t
	} -cleanup {
	    t destroy
	} -body {
	    grammar::me::util::ast2etree $node tinfo t
	} -result "Bad node \"[lrange $node 0 end]\", not enough elements"
}



test ast2etree-2.0 {Regular conversion} \
    -setup {
	struct::tree t
	struct::tree tex deserialize $serial_2
    } -cleanup {
	t   destroy
	tex destroy
    } -body {
	grammar::me::util::ast2etree $ast tinfo t
	tree_equal t tex
    } -result 1

test ast2etree-2.1 {Regular conversion under non-root root} \
    -setup {
	struct::tree t
	t insert root end foo
	struct::tree tex deserialize $serial_3
    } -cleanup {
	t   destroy
	tex destroy
    } -body {
	grammar::me::util::ast2etree $ast tinfo t foo
	tree_equal t tex
    } -result 1

# ### ### ### ######### ######### #########
## Suite 3: Tree objects to values.

test tree2ast-1.0 {Call without enough arguments} \
    -returnCodes error \
    -body {
	grammar::me::util::tree2ast
    } -result {wrong # args: should be "grammar::me::util::tree2ast tree ?root?"}

test tree2ast-1.1 {Call with to many arguments} \
    -returnCodes error \
    -body {
	grammar::me::util::tree2ast a b c
    } -result {wrong # args: should be "grammar::me::util::tree2ast tree ?root?"}

test tree2ast-1.2 {Call with bad tree object} \
    -returnCodes error \
    -body {
	grammar::me::util::tree2ast foo
    } -result {invalid command name "foo"}

test tree2ast-1.3 {Call with bad node in tree} \
    -returnCodes error \
    -setup {
	struct::tree t
    } -cleanup {
	t destroy
    } -body {
	grammar::me::util::tree2ast t blub
    } -result {node "blub" does not exist in tree "::t"}

test tree2ast-1.4 {Call with broken tree, missing type} \
    -returnCodes error \
    -setup {
	struct::tree t deserialize {root {} {range {0 2} detail x}}
    } -cleanup {
	t destroy
    } -body {
	grammar::me::util::tree2ast t
    } -result {Bad node "root", type information is missing}

test tree2ast-1.5.0 {Call with broken tree, missing range, nonterminal} \
    -returnCodes error \
    -setup {
	struct::tree t deserialize {root {} {type nonterminal detail x}}
    } -cleanup {
	t destroy
    } -body {
	grammar::me::util::tree2ast t
    } -result {Bad node "root", range information is missing}

test tree2ast-1.5.1 {Call with broken tree, missing range, terminal} \
    -returnCodes error \
    -setup {
	struct::tree t deserialize {root {} {type terminal}}
    } -cleanup {
	t destroy
    } -body {
	grammar::me::util::tree2ast t
    } -result {Bad node "root", range information is missing}

test tree2ast-1.6 {Call with broken tree, missing detail} \
    -returnCodes error \
    -setup {
	struct::tree t deserialize {root {} {type nonterminal range {0 2}}}
    } -cleanup {
	t destroy
    } -body {
	grammar::me::util::tree2ast t
    } -result {Bad node "root", nonterminal detail is missing}

foreach {n range} {
     0 {0  a}
     1 {0 -1}
     2 {a  0}
     3 {-1 0}
     4 {a  b}
     5 {a -1}
     6 {-1 b}
     7 {-1 -1}
     8 {}
     9 {1}
    10 {1 2 3}
} {
    test tree2ast-1.7.$n {Call with broken tree, bad location, terminal} \
	-returnCodes error \
	-setup {
	    struct::tree t deserialize [list root {} [list type terminal range $range]]
	} -cleanup {
	    t destroy
	} -body {
	    grammar::me::util::tree2ast t
	} -result "Bad node \"root\", bad range information \"$range\""

    test tree2ast-1.8.$n {Call with broken tree, bad location, nonterminal} \
	-returnCodes error \
	-setup {
	    struct::tree t deserialize [list root {} [list type nonterminal detail x range $range]]
	} -cleanup {
	    t destroy
	} -body {
	    grammar::me::util::tree2ast t
	} -result "Bad node \"root\", bad range information \"$range\""
}



test tree2ast-2.0 {Regular conversion} \
    -setup {
	struct::tree t deserialize $serial_0a
    } -cleanup {
	t destroy
    } -body {
	grammar::me::util::tree2ast t
    } -result $ast

test tree2ast-2.1 {Regular conversion under non-root root} \
    -setup {
	struct::tree t deserialize $serial_1
    } -cleanup {
	t destroy
    } -body {
	grammar::me::util::tree2ast t node0
    } -result $ast

test tree2ast-2.2 {Regular conversion, of extended tree} \
    -setup {
	struct::tree t deserialize $serial_2a
    } -cleanup {
	t destroy
    } -body {
	grammar::me::util::tree2ast t
    } -result $ast

test tree2ast-2.3 {Regular conversion under non-root root} \
    -setup {
	struct::tree t deserialize $serial_3
    } -cleanup {
	t destroy
    } -body {
	grammar::me::util::tree2ast t node0
    } -result $ast

# ### ### ### ######### ######### #########
## Cleanup and statistics.

rename tree_equal {}
::tcltest::cleanupTests
