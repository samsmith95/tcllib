# -*- tcl -*-
# Tests for the find function.
#
# Sourcing this file into Tcl runs the tests and generates output for errors.
# No output means no errors were found.
#
# Copyright (c) 1998-2000 by Ajuba Solutions.
# Copyright (c) 2001 by ActiveState Tool Corp.
# Copyright (c) 2005-2007 by Andreas Kupries <andreas_kupries@users.sourceforge.net>
# All rights reserved.
#
# RCS: @(#) $Id: find.test,v 1.4 2007/08/08 04:33:20 andreas_kupries Exp $

# -------------------------------------------------------------------------

source [file join \
	[file dirname [file dirname [file join [pwd] [info script]]]] \
	devtools testutilities.tcl]

testsNeedTcl     8.2
testsNeedTcltest 1.0

testing {
    useLocal fileutil.tcl fileutil
}

# -------------------------------------------------------------------------

# Build a sample tree to search
# Structure
#
#	dir
#	+--{find 1}
#          +--{find 2}
#          |  +--{file* 2}  (This file is unix only)
#          +--{file 1}
#
#       dir2
#       +-- dotfiles
#           +-- .foo
#           +-- foo

proc f_setup {} {
    makeDirectory            {find 1}
    makeDirectory [file join {find 1} {find 2}]
    makeFile ""   [file join {find 1} {file [1]}]

    if {[string equal $::tcl_platform(platform) windows]} return

    makeFile "test" [file join {find 1} {find 2} {file* 2}]
    return
}

proc f_cleanup {} {
    removeDirectory {find 1}
    return
}

# Extend the previous sample tree with circular symbolic
# links. Unix-only.
#
#	dir
#	+--{find 1}
#          +--{find 2}          <----------+
#          |  +--{file* 2}		   |
#          |  +--{file 3} --> ../{find 2} -+
#          +--{file [1]}

proc f_setupcircle {} {
    f_setup

    set fthree [file join {find 1} {find 2} {file 3}]
    set path   [makeFile "" $fthree]
    removeFile $fthree

    # Can't use 'file link' for two reasons. For one it is not
    # available in Tcl 8.[23], and for two it always creates absolute
    # links.

    exec ln -s [file join .. {find 2}] $fthree
    return
}

proc f_setupdot {} {
    makeDirectory          dotfiles
    makeFile "" [file join dotfiles foo]
    makeFile "" [file join dotfiles .foo]
    return
}

proc f_cleanupdot {} {
    removeDirectory dotfiles
    return
}

proc f_setupnostat {} {
    # Finding inaccessible directories (unix only) (I do not know howe
    # make the directory inaccessible on Windows, and then
    # reaccessible again).

    makeDirectory find3
    makeDirectory find3/find4
    makeFile {}   find3/find4/file5

    if {[string equal $::tcl_platform(platform) windows]} return
    exec chmod -x [tempPath find3/find4]
    return
}

proc f_cleanupnostat {} {
    if {![string equal $::tcl_platform(platform) windows]} {
	exec chmod +x [tempPath find3/find4]
    }
    removeDirectory find3
    return
}

proc f_cleanall {} {
    rename f_setup          {}
    rename f_cleanup        {}
    rename f_setupcircle    {}
    rename f_setupdot       {}
    rename f_cleanupdot     {}
    rename f_setupnostat    {}
    rename f_cleanupnostat  {}
    rename f_cleanall       {}
    rename fileIsBiggerThan {}
    unset ::res
    return
}

# -------------------------------------------------------------------------

proc fileIsBiggerThan {s f} {
    expr {
	  ![file isdirectory $f] &&
	  ([file size $f] > $s)
    }
}

# -------------------------------------------------------------------------

test find-1.1 {standard recursive find} {macOrUnix} {
    f_setup
    set res [lsort [fileutil::find [tempPath {find 1}]]]
    f_cleanup
    set res
} [list [tempPath {find 1/file [1]}] \
	[tempPath {find 1/find 2}] \
	[tempPath {find 1/find 2/file* 2}]]

test find-1.2 {standard recursive find} {win} {
    f_setup
    set res [lsort [fileutil::find [tempPath {find 1}]]]
    f_cleanup
    set res
} [list [tempPath {find 1/file [1]}] \
	[tempPath {find 1/find 2}]]

test find-1.3 {find directories} {
    f_setup
    set res [fileutil::find [tempPath {find 1}] {file isdirectory}]
    f_cleanup
    set res
} [list [tempPath {find 1/find 2}]]

test find-1.4 {find files bigger than a given size} {macOrUnix} {
    f_setup
    set res [fileutil::find [tempPath {find 1}] {fileIsBiggerThan 1}]
    f_cleanup
    set res
} [list [tempPath {find 1/find 2/file* 2}]]

test find-1.5 {handling of circular links} {unix} {
    # Find has to skip '{file 3}'. Actually not. It should include
    # {file 3} itself in the result, but must not follow it further.
    f_setupcircle
    set res [lsort [fileutil::find [tempPath {find 1}]]]
    f_cleanup
    set res
} [list [tempPath {find 1/file [1]}] \
	[tempPath {find 1/find 2}] \
	[tempPath {find 1/find 2/file 3}] \
	[tempPath {find 1/find 2/file* 2}]]

test find-1.6 {find file} {
    f_setup
    set res [::fileutil::find [tempPath {find 1/file [1]}]]
    f_cleanup
    set res
} [list [tempPath {find 1/file [1]}]]

test find-1.7 {find file with filter} {
    f_setup
    set res [::fileutil::find [tempPath {find 1/file [1]}] {file isfile}]
    f_cleanup
    set res
} [list [tempPath {find 1/file [1]}]]

test find-1.8 {find file with filter - negative} {
    f_setup
    set res [::fileutil::find [tempPath {find 1/file [1]}] {file isdirectory}]
    f_cleanup
    set res
} {}

# Behaviour of find with regard to dot-files.

test find-1.9 {find file dot-files} {
    f_setupdot
    set res [lsort [::fileutil::find [tempPath dotfiles]]]
    f_cleanupdot
    set res
} [list [tempPath dotfiles/.foo] \
	[tempPath dotfiles/foo]]

# -------------------------------------------------------------------------

test find-2.0 {find by pattern} {
    list [catch {
        ::fileutil::findByPattern [tempPath {}] -glob {fil*} foo
    } err] $err
} {1 {wrong#args for "::fileutil::findByPattern", should be "::fileutil::findByPattern basedir ?-regexp|-glob? ?--? patterns"}}

test find-2.1 {find by pattern} {
    list [catch {
        ::fileutil::findByPattern [tempPath {}] -glob
    } err] $err
} {1 {wrong#args for "::fileutil::findByPattern", should be "::fileutil::findByPattern basedir ?-regexp|-glob? ?--? patterns"}}

test find-2.2 {find by pattern} {macOrUnix} {
    f_setupcircle
    set res [lsort [::fileutil::findByPattern [tempPath {find 1}] -glob {fil*}]]
    f_cleanup
    set res
} [list [tempPath {find 1/file [1]}] \
	[tempPath {find 1/find 2/file 3}] \
	[tempPath {find 1/find 2/file* 2}]]

test find-2.3 {find by pattern} {win} {
    f_setup
    set res [lsort [::fileutil::findByPattern [tempPath {find 1}] -glob {fil*}]]
    f_cleanup
    set res
} [list [tempPath {find 1/file [1]}]]

test find-2.4 {find by pattern} {
    f_setup
    set res [lsort [::fileutil::findByPattern [tempPath {find 1}] -regexp {.*\\[1\\]$}]]
    f_cleanup
    set res
} [list [tempPath {find 1/file [1]}]]

# -------------------------------------------------------------------------

test find-3.0 {inaccessible directory} {unix notRoot} {
    f_setupnostat
    set res [lsort [fileutil::find [tempPath find3]]]
    f_cleanupnostat
    set res
} [list [tempPath find3/find4]]

test find-3.1 {inaccessible directory} {unix notRoot} {
    f_setupnostat
    set res [lsort [fileutil::find [tempPath find3/find4]]]
    f_cleanupnostat
    set res
} {}

# -------------------------------------------------------------------------

f_cleanall
testsuiteCleanup
return
