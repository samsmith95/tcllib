#!/usr/bin/env tclsh
# -*- tcl -*-

package require Tcl 8.5
# activate commands below for execution from within the pt directory
set self    [file normalize [info script]]
set selfdir [file dirname $self]
lappend auto_path $selfdir [file dirname $selfdir]
# When debugging package loading trouble, show the search paths
#puts [join $auto_path \n]

# # ## ### ##### ######## ############# #####################

package require pt::pgen
package require fileutil

namespace eval ::pt::app {
    namespace export generate help
    namespace ensemble create
}

# # ## ### ##### ######## ############# #####################

proc main {} {
    global argv argv0 errorInfo
    if {![llength $argv]} { lappend argv help }
    if {[catch {
	set status [::pt::app {*}$argv]
    } msg]} {
	set elines [split $errorInfo \n]
	if {[llength $elines] == 3} {
	    if {[string match *unknown* $msg]} {
		#puts stderr "$argv0 $msg"
		::pt::app help
		exit 1
	    } elseif {[string match {*wrong # args*} $msg]} {
		#puts $msg
		# Extracting the command name from the error message,
		# because there a prefix will have been expanded to
		# the actual command.  <lindex argv 0> OTOH would be a
		# possible prefix, without a properly matching topic.
		puts stderr Usage:
		::pt::app help [lindex $msg 5 1]
		exit 1
	    }
	}
	set prefix {INTERNAL ERROR :: }
	puts ${prefix}[join $elines \n$prefix]
	exit 1
    }
    exit $status
}

# # ## ### ##### ######## ############# #####################

proc ::pt::app::helpHelp {} {
    return {
	@ help ?TOPIC?

	Provides general help, or specific to the given topic.
    }
}
proc ::pt::app::help {{topic {}}} {
    global argv0
    if {[llength [info level 0]] == 1} {
	puts stderr "Usage: $argv0 command ...\n\nKnown commands:\n"
	foreach topic [Topics] {
	    ::pt::app help $topic
	}
    } elseif {$topic ni [Topics]} {
	puts stderr "$argv0: Unknown help topic '$topic'"
	puts stderr "\tUse one of [linsert [join [Topics] {, }] end-1 or]"
	puts stderr ""
    } else {
	puts stderr \t[join [split [string map [list @ $argv0] [string trim [::pt::app::${topic}Help]]] \n] \n\t]
	puts stderr ""
    }
    return 0
}

proc ::pt::app::Topics {} {
    namespace eval ::TEMP { namespace import ::pt::app::* }
    set commands [info commands ::TEMP::*]
    namespace delete ::TEMP

    set res {}
    foreach c $commands {
	lappend res [regsub ^::TEMP:: $c {}]
    }
    proc ::pt::app::Topics {} [list return $res]
    return $res
}

# # ## ### ##### ######## ############# #####################

proc ::pt::app::generateHelp {} {
    return {
	@ generate PFORMAT ?-option value...? PFILE INFORMAT GFILE

	Generate data in format PFORMAT and write it to PFILE.  Read
	the grammar to be processed from GFILE (assuming the format
	GFORMAT). Use any options to configure the generator. The are
	dependent on PFORMAT.
    }
}
proc ::pt::app::generate {args} {
    # args = parserformat ?...? parserfile grammarformat grammarfile 

    if {[llength $args] < 4} {
	# Just enough that the help code can extract the method name
	return -code error "wrong # args, should be \"@ generate ...\""
    }

    set args [lassign $args parserformat]
    lassign [lrange $args end-2 end] \
	parserfile grammarformat grammarfile
    set args [Template [lrange $args 0 end-3]]
    lappend args -file $grammarfile

    set grammar [fileutil::cat $grammarfile]

    if {[catch {
	set parser [::pt::pgen $grammarformat $grammar $parserformat {*}$args]
    } msg o]} {
	# Parse errors are shown here, anything else gets rethrown.
	if {![IsPE $msg]} { return {*}$o $msg }
	ShowPE $msg $grammar
	return 1
    }

    fileutil::writeFile $parserfile $parser
    return 0
}

## NOTE: These should all be made into some utility function
proc ::pt::app::IsPE {msg} {
    string match {pt::rde *} $msg
}

proc ::pt::app::ShowPE {msg text} {
    lassign $msg _ location msgs
    lassign [Position $location $text] l c

    lappend map \n \\n
    lappend map \r \\r
    lappend map \t \\t

    # Get 10 chars before and after the failure point.  Depending on
    # the relative position of input beginning and end we may get less
    # back of either.  Special characters in the input (line endings,
    # tabs) are quoted to keep this on a single line.
    set prefix [string map $map [string range $text ${location}-10 $location]]
    set suffix [string map $map [string range $text ${location}+1 ${location}+10]]

    # Construct a line pointing to the failure position. By using the
    # transformed prefix as our source (length) no complex
    # calculations are required. It is implicit in the prefix/suffix
    # separation above.
    set  n [string length $prefix]
    incr n -1
    set point [string repeat - $n]
    append point ^

    # Print our results.
    puts "Parse error at position $location (Line $l, column $c)."
    puts "... ${prefix}${suffix} ..."
    puts "    $point"
    puts "Expected one of"
    puts "* [join [Readables $msgs] "\n* "]"
    puts ""
    return
}

proc ::pt::app::Position {location text} {
    incr location -1

    set prefix [string range $text 0 $location]
    set lines  [split $prefix \n]
    set line   [llength $lines]
    set col    [string length [lindex $lines end]]

    return [list $line $col]
}

proc ::pt::app::Readables {codes} {
    set r {}
    foreach c $codes {
	lappend r [Readable $c]
    }
    return [lsort -dict $r]
}

proc ::pt::app::Readable {code} {
    set details [lassign $code tag]
    switch -exact -- $tag {
	t        { set m "The character '$details'" }
	n        { set m "The symbol $details" }
	..       { set m "A character in range '[join $details '-']'" }
	str      { set m "A string \"$details\"" }
	cl       { set m "A characters in set \[$details\]" }
	alpha    { set m "A unicode alphabetical character" }
	alnum    { set m "A unicode alphanumerical character" }
	ascii    { set m "An ascii character" }
	digit    { set m "A unicode digit character" }
	graph    { set m "A unicode printing character, but not space" }
	lower    { set m "A unicode lower-case alphabetical character" }
	print    { set m "A unicode printing character, including space" }
	control  { set m "A unicode control character" }
	punct    { set m "A unicode punctuation character" }
	space    { set m "A unicode space character" }
	upper    { set m "A unicode upper-case alphabetical character" }
	wordchar { set m "A unicode word character (alphanumerics + connectors)" }
	xdigit   { set m "A hexadecimal digit" }
	ddigit   { set m "A decimal digit" }
	dot      { set m "Any character" }
	default { set m [string totitle $tag] }
    }
    return $m
}

# Lift template specifications from file paths to the file's contents.

proc ::pt::app::Template {optiondict} {
    set res {}
    foreach {option value} $optiondict {
	if {$option eq "-template"} {
	    set value [fileutil::cat $value]
	}
	lappend res $option $value
    }
    return $res
}

# # ## ### ##### ######## ############# #####################

main
exit
