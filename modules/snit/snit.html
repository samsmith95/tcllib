<html><head>
    <title>Snit -- Snit's Not Incr Tcl</title>
</head>

<BODY>

<h1>Snit -- Snit's Not Incr Tcl</h1>

<ul>
  <li> <a href="#synopsis">SYNOPSIS</a>
  <li> <a href="#overview">OVERVIEW</a>
  <li> <a href="#reference">REFERENCE</a>
       <ul>
         <li> <a href="#type_and_widget_definitions">Type and Widget Definitions</a>
         <li> <a href="#the_type_command">The Type Command</a>
         <li> <a href="#standard_type_methods">Standard Type Methods</a>
         <li> <a href="#the_instance_command">The Instance Command</a>
         <li> <a href="#standard_instance_methods">Standard Instance Methods</a>
         <li> <a href="#commands_for_use_in_object_code">Commands for use in Object Code</a>
         <li> <a href="#components_and_delegation">Components and Delegation</a>
         <li> <a href="#the_tk_option_database">The Tk Option Database</a>
       </ul>
  <li> <a href="#history">HISTORY</a>
  <li> <a href="#credits">CREDITS</a>
</ul>

<h2><a name="synopsis">SYNOPSIS</a></h2>

<pre>
    package require snit 0.84
    ::snit::type <i>name</i> <i>definition</i>
    ::snit::widget <i>name</i> <i>definition</i>
    ::snit::widgetadaptor <i>name</i> <i>definition</i>
</pre><p>

<h2><a name="overview">OVERVIEW</a></h2>

Snit is yet another pure Tcl object and megawidget system.  It's
unique among Tcl object systems (so far as I know) in that it's a
system based not on inheritance but on delegation.  Object systems
based on inheritance only allow you to inherit from classes defined
using the same system, and that's a shame.  In Tcl, an object
is anything that acts like an object; it shouldn't matter how the
object was implemented.  I designed Snit to help me build applications
out of the materials at hand; thus, Snit is designed to be able to
incorporate and build on any object, whether it's a hand-coded object,
a Tk widget, an Incr Tcl object, a BWidget or almost anything else.<p>

This man page is intended to be a reference only; see the accompanying
<a href="faq.html">Snit FAQ list</a> for a gentler, more tutorial
introduction to Snit concepts.<p>


<h2><a name="reference">REFERENCE</a></h2>

<h3><a name="type_and_widget_definitions">Type and Widget Definitions</a></h3>

<dl>
  <dt> <code><a name="snit::type">snit::type <i>name</i> <i>definition</i></a></code>
  <dd> Defines a new abstract data type called
       <i>name</i>.  If <i>name</i> is not a fully qualified command
       name, it is assumed to be a name in the namespace in which the
       <code>snit::type</code> command appears (usually the global namespace).  It
       returns the fully qualified type name.<p>

       The type name is then a command which is used to
       create objects of the new type, along with other
       activities.<p>

       The <code>snit::type</code> <i>definition</i> block may contain the
       following definitions:<p>

       <dl>
         <dt> <code><a name="typevariable">typevariable <i>name</i> ?<i>value</i>?</a></code>
         <dd> Defines a type variable with the specified name, and
              optionally the specified value.  Type variables are
              shared by all instances of the type.  This definition
              can be used to define array variables, but cannot
              initialize their elements.<p>
       
         <dt> <code><a name="typemethod">typemethod <i>name</i> <i>arglist</i> <i>body</i></a></code>
         <dd> Defines a type method with the specified name, argument
              list, and body.  The variable "type" is automatically defined in
              the <i>body</i> to the type's fully-qualified name.<p>

              The <i>arglist</i> is a normal Tcl argument list and may
              contain default arguments and the "args" argument;
              however, it may not contain the argument names "type",
              "self", "selfns", or "win".<p>

              Type variables defined in the type <i>definition</i> are
              automatically visible in the <i>body</i> of every type method.<p>
              
         <dt> <code><a name="typeconstructor">typeconstructor <i>body</i></a></code>
         <dd> The type constructor's <i>body</i> is executed once when the
              type is first defined; it is typically used to
              initialize array-valued type-variables and to add
              entries to the Tk option database.<p>

              The variable "type" is
              automatically defined in the <i>body</i> to the type's
              fully-qualified name.<p>

              Type variables defined in the type <i>definition</i> are
              automatically visible in the <i>body</i> of every type method.<p>

              A type may define at most one type constructor.<p>

         <dt> <code><a name="option">option <i>namespec</i> ?<i>defaultValue</i>?</a></code>
         <dd> Defines an option for instances of this type, and
              optionally gives it an initial value.  (The option's
              value defaults to "" if no initial value is specified.)
              An option defined in this way is said to be "locally
              defined".<p>

              The <i>namespec</i> is a list defining the option's
              name, resource name, and class name, e.g.:<p>

              <pre>option {-font font Font} {Courier 12}</pre><p>

              The option name must begin with a hyphen, and must not
              contain any upper case letters. The resource name and
              class name are optional; if not specified, the resource
              name defaults to the option name, minus the hyphen, and
              the class name defaults to the resource name with the
              first letter capitalized.  Thus, the following
              statement is equivalent to the previous example:<p>

              <pre>option -font {Courier 12}</pre><p>
              
              See
              <a href="#the_tk_option_database">The Tk Option
              Database</a> for more information about resource and
              class names.<p>
              
              Options are normally set and retrieved using the
              standard <code><a href="#configure">configure</a></code>
              and <code><a href="#cget">cget</a></code> instance
              methods.<p>

         <dt> <code><a name="variable">variable <i>name</i> ?<i>value</i>?</a></code>
         <dd> Defines an instance variable, a private variable
              associated with each instance of this type, and
              optionally its initial value.  This definition can be
              used to define array instance variables, but cannot
              initialize their elements.<p>

              Note that the <code>delegate</code> statement implicitly
              defines an instance variable for the named component.<p>
       
         <dt> <code><a name="method">method <i>name</i> <i>arglist</i> <i>body</i></a></code>
         <dd> Defines an instance method, a subcommand of each
              instance of this type, with the specified name, argument list
              and body.  The <i>arglist</i> is a standard Tcl argument
              list, and may contain default values and the
              <code>args</code> 

              The <i>arglist</i> is a normal Tcl argument list and may
              contain default arguments and the "args" argument.  In
              addition, the method is implicitly passed the following
              arguments as well: "type", which contains the
              fully-qualified type name; "self", which contains the
              current instance command name; "selfns", which contains
              the name of the instance's private namespace; and
              "win", which contains the original instance name.
              Consequently, the <i>arglist</i> may not contain the
              argument names "type", "self", "selfns", or "win".<p>

              An instance method defined in this way is said to be
              "locally defined".<p>

              Type and instance variables defined in the type
              <i>definition</i> are automatically visible in all
              instance methods.  If the type has locally defined
              options, the "options" array is also visible.<p>

         <dt> <code><a name="constructor">constructor <i>arglist</i> <i>body</i></a></code>
         <dd> The constructor definition specifies a <i>body</i> of
              code to be executed when a new instance is created.<p>

              The <i>arglist</i> is a normal Tcl argument list and may
              contain default arguments and the "args" argument.
              As with methods, the arguments "type",
              "self", "selfns", and "win", are defined implicitly.<p>

              If the constructor is not defined, it defaults to this:<p>

              <pre>
              constructor {args} {
                  $self configurelist $args
              }
              </pre><p>

              For standard Tk widget behavior (or to achieve the
              behavior of previous versions of snit) the argument list
              should be the single name "args", as shown.<p>

         <dt> <code><a name="destructor">destructor <i>body</i></a></code>
         <dd> The destructor is used to code any actions which must
              take place when an instance of the type is destroyed:
              typically, the destruction of anything created in the
              constructor.<p>

              As with arguments, the parameters "type",
              "self", "selfns", and "win", are defined implicitly.<p>
              
         <dt> <code><a name="onconfigure">onconfigure <i>name</i> <i>arglist</i> <i>body</i></a></code>
         <dd> Every locally-defined option has an "onconfigure"
              handler which is called when the option is set to a new
              value by the "configure" or "configurelist" instance
              method.<p>

              The <i>arglist</i> may contain exactly one
              argument name. As with methods, the arguments "type",
              "self", "selfns", and "win", are defined implicitly.<p>

              If no explicit onconfigure handler is defined for an
              option, the handler is defined as follows:<p>

              <pre>
              onconfigure <i>name</i> {value} {
                  set options(<i>name</i>) $value
              }
              </pre>

              If an explicit onconfigure handler is defined, the
              options array will be updated with the new value only if
              the handler so updates it.<p>
              
         <dt> <code><a name="oncget">oncget <i>name</i> <i>body</i></a></code>
         <dd> Every locally-defined option has an "oncget" handler
              which is called when the option's value is retrieved.

              Although there is no explicit argument list, the
              arguments "type", "self", "selfns", and "win", are
              defined implicitly, just as they are for methods.<p> 

              The variables "type", "self", "selfns", and "win" are
              defined as usual in the handler's <i>body</i>.  Whatever
              the handler returns will be the return value of the call
              to the <code><a href="#cget">cget</a></code> instance method.<p>

              If no explicit oncget handler is defined for an option,
              the handler is defined as follows:<p>

              <pre>
              oncget <i>name</i> {
                  return $options(<i>name</i>)
              }
              </pre>
              
         <dt> <code><a name="proc">proc <i>name</i> <i>args</i> <i>body</i></a></code>
         <dd> Defines a new Tcl procedure in the type's namespace.
              The new proc differs from a normal Tcl proc in that
              all type variables defined in the type
              <i>definition</i> are automatically
              visible.<p>

              Although they are not implicitly defined for procs, the
              argument names "type", "self", "selfns", and "win"
              should be avoided.<p>
              
         <dt> <code><a name="delegate">delegate method <i>name</i> to <i>comp</i> ?as <i>compmethod compargs...</i>?</a></code>
         <dd> Defines a delegated instance method.  When instance
              method <i>name</i> is used with an instance of this
              type, it will automatically be delegated to the named
              component as though the method were defined as follows:<p>

              <pre>
              method <i>name</i> {<i>args...</i>} {
                  $<i>comp</i> mymethod <i>args...</i>
              }
              </pre>

              If desired, the delegated method may target a method
              with a different name by using the "as" clause; it may
              also add arguments to the beginning of the argument
              list.  In that case, it's as though the delegated method
              were defined as follows:<p>

              <pre>
              method <i>name</i> {<i>args...</i>} {
                  $<i>comp</i> <i>compmethod</i> \
                      <i>compargs...</i>  <i>args...</i>
              }
              </pre>

              If the specified method <i>name</i> is "*", then all
              unknown method names passed to the instance will be
              passed along to the specified <i>comp</i>.  In this
              case, the "as" clause is not allowed.<p>

              A method cannot be both locally defined and delegated.<p>
              
         <dt> <code><a name="delegate">delegate option <i>namespec</i> to <i>comp</i> ?as <i>compoption</i>?</a></code>
         <dd> Defines a delegated option; the <i>namespec</i> is
              defined as for the <code><a href="#option">option</a></code>
              statement.   When the
              <code><a href="#configure">configure</a></code>,
              <code><a href="#configurelist">configurelist</a></code>, or
              <code><a href="#cget">cget</a></code> instance method is used to set or
              retrieve the option's value, the equivalent configure or
              cget command will be applied to the component as though
              these <code><a href="#onconfigure">onconfigure</a></code> and
              <code><a href="#oncget">oncget</a></code> handlers were
              defined, where <i>name</i> is the option name from the
              <i>namespec</i>:<p>

              <pre>
              onconfigure <i>name</i> {value} {
                  $<i>comp</i> configure <i>compoption</i> $value
              }
              
              oncget <i>name</i> {
                  return [$<i>comp</i> cget <i>compoption</i>]
              }
              </pre>

              If the "as" clause is omitted, the <i>compoption</i>
              name is the same as <i>name</i>.<p>

              Warning: options can only be delegated to a component if
              it supports the "configure" and "cget" instance methods.<p>
       </dl>
  <dt> <code><a name="snit::widget">snit::widget <i>name</i> <i>definition</i></a></code>
  <dd> This command defines a Snit megawidget type with the specified
       <i>name</i>.  The <i>definition</i> is defined identically to
       that for <code>snit::type</code>.  A <code>snit::widget</code>
       differs from a <code>snit::type</code> in these ways:<p>

       <ul>
         <li> Every snit::widget instance has an automatically-created
              component called <code>hull</code>, which is normally
              a Tk frame widget.  Other widgets created as part of the megawidget
              will be created within this frame.<p>

              The hull component is initially created with the
              requested widget name; then Snit does some magic,
              renaming the hull component and installing its own
              instance command in its place.  The hull component's new
              name is saved in an instance variable called
              <code>hull</code>.<p>

         <li> The name of an instance must be valid Tk window name,
              and the parent window must exist.<p>
       </ul>

       A <code>snit::widget</code> definition can include any of
       statements allowed in a <code>snit::type</code> definition,
       and may also include these as well:<p>

       <dl>
         <dt> <code><a name="widgetclass">widgetclass <i>name</i></a></code>
         <dd> Sets the <code>snit::widget</code>'s widget class
              to <i>name</i>, overriding the default.  See
              <a href="#the_tk_option_database">The Tk Option
              Database</a> for more information.<p>

         <dt> <code><a name="hulltype">hulltype <i>type</i></a></code>
         <dd> Determined the kind of widget used as the
              <code>snit::widget</code>'s hull.  The <i>type</i> may
              be <code>frame</code> (the default) or
              <code>toplevel</code>.<p>
       </dl>
       
  <dt> <code><a name="snit::widgetadaptor">snit::widgetadaptor <i>name</i> <i>definition</i></a></code>
  <dd> This command defines a Snit megawidget type with the specified
       name.  It differs from <code>snit::widget</code> in that the
       instance's <code>hull</code> component is not created
       automatically, but is created in the constructor and installed
       using the <code><a href="#installhull">installhull</a></code> command.  Once the hull is
       installed, its instance command is renamed and replaced as with
       normal <code>snit::widgets</code>.  The original command is
       again accessible in the instance variable <code>hull</code>.<p>

       Note that in general it is not possible to change the
       <a href="#widgetclass">widget class</a> of a
       <code>snit::widgetadaptor</code>'s hull widget.  See
       <a href="#the_tk_option_database">The Tk Option Database</a>
       for information on how <code>snit::widgetadaptors</code>
       interact with the option database.<p>
</dl>

<h3><a name="the_type_command">The Type Command</a></h3>

A type or widget definition creates a type command, which is used to
create instances of the type.  The type command this form.<p>

<dl>
  <dt> <code>$type <i>typemethod</i> <i>args....</i></code>
  <dd> The <i>typemethod</i> can be any of the standard type methods
       defined in the next section, or any type method defined in the
       type definition.  The subsequent <i>args</i> depend on the
       specific <i>typemethod</i> chosen.<p>
</dl>

<h3><a name="standard_type_methods">Standard Type Methods</a></h3>

In addition to any typemethods in the type's definition, all types and
widgets will have at least the following method:<p>

<dl>
  <dt> <code><a name="$type">$type create <i>name</i> ?<i>option</i> <i>value</i> ...?</a></code>
  <dd> Creates a new instance of the type, giving it the specified
       <i>name</i> and calling the type's constructor.<p>

       For <code>snit::types</code>, if <i>name</i> is not a fully-qualified
       command name, it is assumed to be a name in the namespace in
       which the call to <code>snit::type</code> appears.  The method returns the
       fully-qualified instance name.<p>

       For <code>snit::widgets</code> and
       <code>snit::widgetadaptors</code>, <i>name</i> must be a valid
       widget name; the method returns the widget name.<p>

       So long as <i>name</i> does not conflict with any defined type
       method name, the "create" keyword may be omitted.<p>

       If the <i>name</i> includes the string "%AUTO%", it will be
       replaced with the string "$type$counter" where "$type" is the
       type name and "$counter" is a counter that increments each time
       "%AUTO%" is used for this type.<p>

       By default, any arguments following the <i>name</i> will be a
       list of <i>option</i> names and their <i>value</i>s; however, a
       type's constructor can specify a different argument list.<p>

  <dt> <code><a name="$type">$type info typevars</a></code>
  <dd> Returns a list of the type's type variables (excluding Snit
       internal variables); all variable names are fully-qualified.<p>

  <dt> <code><a name="$type">$type info instances</a></code>
  <dd> Returns a list of the type's instances.  For <code>snit::type</code>s, it
       will be a list of fully-qualified instance names; for
       snit::widgets, it will be a list of Tk widget names.<p>

  <dt> <code><a name="$type">$type destroy</a></code>
  <dd> Destroys the type's instances, the type's namespace, and the
       type command itself.<p>
</dl>

<h3><a name="the_instance_command">The Instance Command</a></h3>

A Snit type or widget's <code><a href="#create">create</a></code> type method creates
objects of the type; each object has a unique name which is also a
Tcl command.  This command is used to access the object's methods and
data, and has this form:<p>

<dl>
  <dt> <code>$object <i>method</i> <i>args...</i></code>
  <dd> The <i>method</i> can be any of the standard instance methods
       defined in the next section, or any instance method defined in
       the type definition. The subsequent <i>args</i> depend on the
       specific <i>method</i> chosen.<p>
</dl>

<h3><a name="standard_instance_methods">Standard Instance Methods</a></h3>

In addition to any delegated or locally-defined instance methods in
the type's definition, all Snit objects will have at least the
following methods:<p>

<dl>
  <dt> <code><a name="$object">$object configure ?<i>option</i>? ?<i>value</i>? ...</a></code>
  <dd> Assigns new values to one or more options.  If called with one
       argument, an <i>option</i> name, returns a list describing the
       option, as Tk widgets do; if called with no arguments, returns
       a list of lists describing all options, as Tk widgets do.<p>

       Warning: this information will be available for
       delegated options only if the component to which they are
       delegated has a "configure" method that returns this same kind
       of information.<p>

  <dt> <code><a name="$object">$object configurelist <i>optionlist</i></a></code>
  <dd> Like <code><a href="#configure">configure</a></code>, but takes
       one argument, a list of options and 
       their values.  It's mostly useful in the type constructor, but
       can be used anywhere.<p>

  <dt> <code><a name="$object">$object cget <i>option</i></a></code>
  <dd> Returns the option's value.<p>

  <dt> <code><a name="$object">$object destroy</a></code>
  <dd> Destroys the object, calling the <code><a href="#destructor">destructor</a></code> and
       freeing all related memory.<p>

       <b>Note:</b> The "destroy" method isn't defined for
       <code><a href="#snit::widget">snit::widget</a></code> or
       <code><a href="#snit::widgetadaptor">snit::widgetadaptor</a></code> 
       objects; instances of these are destroyed by calling the Tk
       "destroy" command, just as a normal widget is.<p>

  <dt> <code><a name="$object">$object info type</a></code>
  <dd> Returns the instance's type.<p>

  <dt> <code><a name="$object">$object info vars</a></code>
  <dd> Returns a list of the object's instance variables (excluding
       Snit internal variables).  The names are fully qualified.<p>

  <dt> <code><a name="$object">$object info typevars</a></code>
  <dd> Returns a list of the object's type's type variables (excluding
       Snit internal variables).  The names are fully qualified.<p>

  <dt> <code><a name="$object">$object info options</a></code>
  <dd> Returns a list of the object's option names.  This always
       includes local options and explicitly delegated options.  If
       unknown options are delegated as well, and if the component to
       which they are delegated responds to "$object configure" like Tk
       widgets do, then the result will include all possible unknown
       options which could be delegated to the component.<p>

       Note that the return value might be different for different
       instances of the same type, if component object types can vary
       from one instance to another.<p>
</dl>

<h3><a name="commands_for_use_in_object_code">Commands for use in Object Code</a></h3>

Snit defines the following commands for use in object code:
type methods, instance methods, constructors, destructors, onconfigure
handlers, oncget handlers, and procs.  They do not reside in the
::snit:: namespace; instead, they are created with the type, and are
directly available.

<dl>
  <dt> <code><a name="varname">varname <i>name</i></a></code>
  <dd> Given an instance variable name, returns the fully qualified
       name.  Use this if you're passing the variable to some other
       object, e.g., as a -textvariable to a Tk label widget.<p>

  <dt> <code><a name="typevarname">typevarname <i>name</i></a></code>
  <dd> Given an type variable name, returns the fully qualified
       name.  Use this if you're passing the variable to some other
       object, e.g., as a -textvariable to a Tk label widget.<p>

  <dt> <code><a name="codename">codename <i>name</i></a></code>
  <dd> Given the name of a proc (but not a type or instance
       method), returns the fully-qualified command name,
       suitable for passing as a callback.<p>

  <dt> <code><a name="from">from <i>argvName</i> <i>option</i> ?<i>defvalue</i>?</a></code>
  <dd> The <code><a href="#from">from</a></code> command plucks an
       option value from a list of options and their values, such as
       is passed into a type's
       <code><a href="#constructor">constructor</a></code>.
       <i>argvName</i> must be the name of a variable containing such
       a list; <i>option</i> is the name of the specific option.<p>

       <code><a href="#from">from</a></code> looks for <i>option</i> in the option list.  If
       it is found, it and its value are removed from the list, and
       the value is returned.  If <i>option</i> doesn't appear in the
       list, then the <i>defvalue</i> is returned.  If the option is a
       normal (undelegated) option, and <i>defvalue</i> is not
       specified, then the option's default value as specified in the
       type definition will be returned instead.<p>
       
  <dt> <code><a name="variable">variable <i>name</i></a></code>
  <dd> Normally, instance variables are defined in the type definition
       along with the options, methods, and so forth; such instance
       variables are automatically visible in all instance-specific
       code.  However, instance code (e.g., method bodies) can declare
       such variables explicitly using the
       <code><a href="#variable">variable</a></code> command, if
       desired; or, instance code can use the
       <code><a href="#variable">variable</a></code>
       command to declare instance variables that don't appear in the
       type definition.<p>

       It's generally best to define all instance variables in the
       type definition, and omit declaring them in methods and so forth.<p>

       Note that this is not the same as the standard Tcl "::variable"
       command.<p>

  <dt> <code><a name="typevariable">typevariable <i>name</i></a></code>
  <dd> Normally, type variables are defined in the type definition,
       along with the instance variables; such type variables are
       automatically visible in all of the type's code.  However, type
       methods, instance methods and so forth can use
       <code><a href="#typevariable">typevariable</a></code> to
       declare type variables explicitly, if
       desired; or, they can use <code><a href="#typevariable">typevariable</a></code>
       to declare type variables that don't appear in the type definition.<p>

       It's generally best to declare all type variables in the type
       definition, and omit declaring them in methods, type methods,
       and so forth.<p>

  <dt> <code><a name="install">install <i>compName</i> using
       <i>objType</i> <i>objName</i> <i>args...</i></a></code>
  <dd> Creates a new object and installs it as a component, as
       described under <a href="#components_and_delegation">Components
       and Delegation.</a><p>

       If this is a <code>snit::type</code>, then the following two
       commands are equivalent:<p>

       <pre>
       install myComp using myObjType $self.myComp <i>options...</i>
       
       set myComp [myObjType $self.myComp <i>options...</i>]
       </pre>

       Note that whichever method is used, <i>compName</i> must still
       be declared in the type definition using <i>variable</i>, or
       must be referenced in at least one <code>delegate</code> statement.<p>
       
       If this is a <code>snit::widget</code> or
       <code>snit::widgetadaptor</code>, and if options have been
       delegated to component <i>compName</i>, then those options
       will receive default values from the Tk option database.  Note
       that it doesn't matter whether the component to be installed is
       a widget or not.  See <a href="#the_tk_option_database">The Tk
       Option Database</a> for more information.<p>

  <dt> <code>installhull using <i>widgetType</i> <i>args...</i></a></code>
  <dt> <code><a name="installhull">installhull <i>name</i></a></code>
  <dd> The constructor of a <code><a
       href="#snit::widgetadaptor">snit::widgetadaptor</a></code> must
       create a widget to be the object's hull component; the widget is
       installed as the hull component using this command.<p>

       This command has two forms.  The first form specifies the
       <i>widgetType</i> and the <i>args...</i> (that is, the
       hardcoded option list) to use in creating the hull.  Given
       this form, <code>installhull</code> creates the hull widget,
       and initializes any options delegated to the hull from the Tk
       option database.<p>

       In the second form, the hull widget has already been created;
       note that its name must be "$win".  In this case, the Tk
       option database is <b>not</b> queried for any options
       delegated to the hull.  See <a
       href="#the_tk_option_database">The Tk Option Database</a> for
       more information about <code>snit::widgetadaptors</code> and
       the option database.<p>

       The longer form is preferred; however, the shorter form allows
       the programmer to adapt a widget created elsewhere, which is
       sometimes useful.  For example, it can be used to adapt a
       "page" widget created by a BWidgets tabbed notebook or pages
       manager widget.<p>
</dl>

<h3><a name="components_and_delegation">Components and Delegation</a></h3>

When an object includes other objects, as when a toolbar contains
buttons or a GUI object contains an object that references a database,
the included object is called a component.  The standard way to handle
component objects owned by a Snit object is to assign their names to a
instance variable.  In the following example, a <code>dog</code> object
has a <code>tail</code> object:<p>

<pre>
snit::type dog {
    variable mytail

    constructor {args} {
        set mytail [tail %AUTO% -partof $self]
        $self configurelist $args
    }

    method wag {} {
        $mytail wag
    }
}

snit::type tail {
    option -length 5
    option -partof
    method wag {} { return "Wag, wag, wag."}
}
</pre>

Because the <code>tail</code> object's name is stored in an instance
variable, it's easily accessible in any method.<p>

As of Snit 0.84, the <code><a href="#install">install</a></code>
command provides an alternate way to create and install the
component:<p>

<pre>
snit::type dog {
    variable mytail

    constructor {args} {
        install mytail using tail %AUTO% -partof $self
        $self configurelist $args
    }

    method wag {} {
        $mytail wag
    }
}
</pre>

For <code>snit::types</code>, the two methods are equivalent; for
<code>snit::widgets</code> and <code>snit::widgetadaptors</code>,
the "install" command properly initializes delegated options by
querying <a href="#the_tk_option_database">the Tk option database</a>.

In the above examples, the <code>dog</code> object's "wag" method
simply calls the <code>tail</code> component's "wag" method.  In OO
circles, this is called delegation.  Snit provides an easier way to do
this, as shown:<p>

<pre>
snit::type dog {
    delegate method wag to mytail

    constructor {args} {
        set mytail [tail %AUTO% -partof $self]
        $self configurelist $args
    }
}
</pre>

The <code>delegate</code> statement in the type definition implicitly
defines the instance variable <code>mytail</code> to hold the
component's name; it also defines the <code>dog</code> object's "wag"
method, delegating it to the <code>tail</code> component.<p>

If desired, all otherwise unknown methods can be delegated to a
specific component:<p>

<pre>
snit::type dog {
    delegate method * to mytail

    constructor {args} {
        set mytail [tail %AUTO% -partof $self]
        $self configurelist $args
    }

    method bark { return "Bark, bark, bark!" }
}
</pre>

In this case, a <code>dog</code> object will handle its own
"bark" method; but "wag" will be passed along to <code>mytail</code>.
Any other method, being recognized by neither <code>dog</code> nor
<code>tail</code>, will simply raise an error.<p>

Option delegation is similar to method delegation, except for the
interactions with the Tk option database; this is described in the
next section.<p>

<h3><a name="the_tk_option_database">The Tk Option Database</a></h3>

This section describes how Snit interacts with the Tk option
database, and assumes the reader has a working knowledge of the option
database and its uses.  The book <i>Practical Programming in Tcl and
Tk</i> by Welch et al has a good introduction to the option database,
as does <i>Effective Tcl/Tk Programming</i><p>

Snit is implemented so that most of the time it will simply do the
right thing with respect to the option database, provided that the
widget developer does the right thing by Snit.  The body of this
section goes into great deal about what Snit requires.  The following
is a brief statement of the requirements, for reference.<p>

<ul>
  <li> If the widget's default widget class is not what is desired, set it
       explicitly using <code><a
       href="#widgetclass">widgetclass</a></code> in the widget
       definition.<p>

  <li> When defining or delegating options, specify the resource and
       class names explicitly when necessary.<p>

  <li> Use <code><a href="#installhull">installhull
       using</a></code> to install the hull for
       <code>snit::widgetadaptors</code>.<p>

  <li> Use <code><a href="#install">install</a></code> to install all
       other components.<p>
</ul>

The interaction of Tk widgets with the option database is a complex
thing; the interaction of Snit with the option database is even more
so, and repays attention to detail.<p>

<b>Setting the widget class:</b> Every Tk widget has a widget class.
For Tk widgets, the widget class name is the just the widget type name
with an initial capital letter, e.g., the widget class for
<code>button</code> widgets is "Button".<p>

Similarly, the widget class of a <code>snit::widget</code> defaults
to the unqualified type name with the first letter capitalized.  For
example, the widget class of<p>

<pre>snit::widget ::mylibrary::scrolledText { ... }</pre><p>

is "ScrolledText".  The widget class can also be set explicitly using
the <a href="#widgetclass">widgetclass</a> statement within the
<code>snit::widget</code> definition.<p>

Note that only <code>frame</code> and <code>toplevel</code> widgets
allow the user to change the widget class name, which is why they are
the allowable hull types for normal <code>snit::widgets</code>.<p>

The widget class of a <code>snit::widgetadaptor</code> is just the
widget class of its hull widget; this cannot be changed unless the
hull widget is a <code>frame</code> or <code>toplevel</code>, in
which case it will usually make more sense to use
<code>snit::widget</code> rather than
<code>snit::widgetadaptor</code>.<p>

<b>Setting option resource names and classes:</b>  In Tk, every
option has three names: the option name, the resource name, and
the class name.  The option name begins with a hyphen is all
lowercase; it's used when creating widgets, and with the
<code>configure</code> and <code>cget</code> commands.<p>

The resource and class names are used to initialize option
default values by querying the Tk option database.
The resource name is usually just the option
name minus the hyphen, but may contain uppercase letters at word
boundaries; the class name is usually just the resource
name with an initial capital, but not always.  For example, here are
the option, resource, and class names for several <code>text</code>
widget options:<p>

<pre>
-background         background         Background 
-borderwidth        borderWidth        BorderWidth 
-insertborderwidth  insertBorderWidth  BorderWidth 
-padx               padX               Pad 
</pre>

As is easily seen, sometimes the resource and class names can be
inferred from the option name, but not always.<p>

Snit options also have a resource name and a class name.  By
default, these names follow the rule given above: the resource name
is the option name without the hyphen, and the class name is the
resource name with an initial capital.  This is true for both
locally-defined options and explicitly delegated options:<p>

<pre>
snit::widget mywidget {
    option -background
    delegate option -borderwidth to hull
    delegate option * to text
    # ...
}
</pre>

In this case, the widget class name is "Mywidget".  The widget has the
following options: -background, which is locally defined,
-borderwidth, which is explicitly delegated; all other widgets are
delegated to a component called "text", which is probably a Tk
<code>text</code> widget.  If so, <code>mywidget</code> has all the
same options as a <code>text</code> widget.  The
option, resource, and class names are as follows:<p>

<pre>
-background  background  Background
-borderwidth borderwidth Borderwidth
-padx        padX        Pad
</pre>

Note that the locally defined option, "-background", happens to have
the same three names as the standard Tk "-background" option; and
"-pad", which is delegated implicitly to the "text" component has the
same three names for <code>mywidget</code> as it does for the
<code>text</code> widget.  "-borderwidth", on the other hand, has
different resource and class names than usual, because the internal
word "width" isn't capitalized.  For consistency, it should be; this
is done as shown:<p>

<pre>
snit::widget mywidget {
    option -background
    delegate option {-borderwidth borderWidth} to hull
    delegate option * to text
    # ...
}
</pre>

The class name will default to "BorderWidth", as expected.<p>

Suppose, however, that <code>mywidget</code> also delegated
"-padx" and -pady to the hull.  In this case, both the resource name
and the class name must be specified explicitly:<p>

<pre>
snit::widget mywidget {
    option -background
    delegate option {-borderwidth borderWidth} to hull
    delegate option {-padx padX Pad} to hull
    delegate option {-pady padY Pad} to hull
    delegate option * to text
    # ...
}
</pre>

<b>Querying the option database:</b> If you set your widgetclass and
option names as described above, Snit will query the option database
when each instance is created, and will generally do the right
thing when it comes to querying the option database.  The remainder
of this section goes into the gory details.<p>

<b>Initializing locally defined options:</b>

When an instance of a snit::widget is created, its locally
defined options are initialized as follows:  each option's resource
and class names are used to query the Tk option database.  If the
result is non-empty, it is used as the option's default; otherwise,
the default hardcoded in the type definition is used.  In either
case, the default can be overridden by the caller.  For example,

<pre>
option add *Mywidget.texture pebbled

snit::widget mywidget {
     option -texture smooth
     # ...
}

mywidget .mywidget -texture greasy
</pre>

Here, "-texture" would normally default to "smooth", but because of
the entry added to the option database it defaults to "pebbled".
However, the caller has explicitly overridden the default, and so the
new widget will be "greasy".<p>

<b>Initializing options delegated to the hull:</b>

A <code>snit::widget</code>'s hull is a widget, and given that its
class has been set it is expected to query the option database for
itself.  The only exception concerns options that are delegated to it
with a different name.  Consider the following code:<p>

<pre>
option add *Mywidget.borderWidth 5
option add *Mywidget.relief sunken
option add *Mywidget.hullbackground red
option add *Mywidget.background green

snit::widget mywidget {
    delegate option -borderwidth to hull
    delegate option -hullbackground to hull as -background
    delegate option * to hull
    # ...
}

mywidget .mywidget

set A [.mywidget cget -relief]
set B [.mywidget cget -hullbackground]
set C [.mywidget cget -background]
set D [.mywidget cget -borderwidth]
</pre>

The question is, what are the values of variables A, B, C and D?<p>

The value of A is "sunken".  The hull is a Tk frame which has been
given the widget class "Mywidget"; it will automatically query the
option database and pick up this value.  Since the -relief option
is implicitly delegated to the hull, Snit takes no action.<p>

The value of B is "red".  The hull will automatically pick up the
value "green" for its -background option, just as it picked up the
-relief value.  However, Snit knows that -hullbackground is mapped
to the hull's  -background option; hence, it queries the option
database for -hullbackground and gets "red" and updates the hull
accordingly.<p>

The value of C is also "red", because -background is implicitly
delegated to the hull; thus, retrieving it is the same as retrieving
-hullbackground.  Note that this case is unusual; in practice,
-background would probably be explicitly delegated to some other
component.<p>

The value of D is "5", but not for the reason you think.  Note that
as it is defined above, the resource name for -borderwidth defaults
to "borderwidth", whereas the option database entry is "borderWidth".
As with -relief, the hull picks up its own "-borderwidth" option
before Snit does anything.  Because the option is delegated under its
own name, Snit assumes that the correct thing has happened, and
doesn't worry about it any further.<p>

For <code>snit::widgetadaptors</code>, the case is somewhat altered.
Widget adaptors retain the widget class of their hull, and the
hull is not created automatically by Snit.  Instead, the
<code>snit::widgetadaptor</code> must call
<code><a href="#installhull">installhull</a></code> in its
constructor.  The normal way to do this is as follows:<p>

<pre>
snit::widgetadaptor mywidget {
    # ...
    constructor {args} {
        # ...
        installhull using text -foreground white
        #
    }
    #...
}
</pre>

In this case, the <code><a href="#installhull">installhull</a></code>
command will create the hull using a command like this:<p>

<pre>
    set hull [text $win -foreground white]
</pre>

The hull is a <code>text</code> widget, so its widget class
is "Text".  Just as with <code>snit::widget</code> hulls,
Snit assumes that it will pick up all of its normal option values
automatically; options delegated from a different name are
initialized from the option database in the same way.<p>

<b>Initializing options delegated to other components:</b>

Non-hull components are matched against the option database
in two ways.  First, a component widget remains a widget still,
and therefore is initialized from the option database in the usual
way.  Second, the option database is queried for all options delegated
to the component, and the component is initialized
accordingly--provided that the <code><a
href="#install">install</a></code>
command is used to create it.<p>

Before option database support was added to Snit, the usual way to
create a component was to simply create it in the constructor and
assign its command name to the component variable:<p>

<pre>
snit::widget mywidget
    delegate option -background to myComp

    constructor {args} {
        set myComp [text $win.text -foreground black]
    }
}
</pre>

The drawback of this method is that Snit has no opportunity to
initialize the component properly.  Hence, the following approach is
now used:<p>

<pre>
snit::widget mywidget
    delegate option -background to myComp

    constructor {args} {
        install myComp using text $win.text -foreground black
    }
}
</pre>

The <code><a href="#install">install</a></code> command does the
following:<p>

<ul>
  <li> Builds a list of the options explicitly included in the
       <code><a href="#install">install</a></code> command--in this
       case, -foreground.<p>
       
  <li> Queries the option database for all options delegated
       explicitly to the named component.<p>

  <li> Creates the component using the specified command, after
       inserting into it a list of options and values read from the
       option database.  Thus, the explicitly include options
       (-foreground) will override anything read from the option
       database.<p>

  <li> If the widget definition implicitly delegated options to the
       component using "delegate option *", then Snit calls the newly
       created component's <code><a
       href="#configure">configure</a></code> method to receive a
       list of all of the component's options.  From this Snit builds
       a list of options implicitly delegated to the component which
       were not explicitly included in the
       <code><a href="#install">install</a></code> command.  For all
       such options, Snit queries the option database and configures
       the component accordingly.       
</ul>

<b>Non-widget components:</b>  The option database is never queried
for <code>snit::types</code>, since it can only be queried given a Tk
widget name.  However, <code>snit::widgets</code> can have non-widget
components.  And if options are delegated to those components, and if
the <code><a href="#install">install</a></code> command is used to
install those components, then they will be initialized from the
option database just as widget components are.<p>

<h2><a name="known_bugs">KNOWN BUGS</a></h2>

<ul>
  <li> Error stack traces returned by Snit are extremely ugly and
       typically contain far too much information about Snit internals.<p>
</ul>

<h2><a name="history">HISTORY</a></h2>

During the course of developing
<a href="http://www.wjduquette.com/notebook">Notebook</a>, my Tcl-based personal
notebook application, I found I was writing it as a collection of
objects.  I wasn't using any particular object-oriented framework; I
was just writing objects in pure Tcl following the guidelines in my
<a href="http://www.wjduquette.com/tcl/objects.html">Guide to Object Commands</a>,
along with a few other tricks I'd picked up since.  And it was working
very well.  But on the other hand, it was getting tiresome.  Writing
objects in pure Tcl is straightforward, once you figure it out, but
there's a fair amount of boilerplate code to write for each one,
especially if you're trying to create megawidgets or create objects
with options, like Tk widgets have..<p>

So that was one thing--tedium is a powerful motivator.  But the other
thing I noticed is that I wasn't using inheritance at all, and I
wasn't missing it.  Instead, I was using delegation: objects that
created other objects and delegated methods to them.<p>

And I said to myself, "This is getting tedious...there has got to be
a better way."  And one afternoon, on a whim, I started working on Snit,
an object system that works the way Tcl works.  Snit doesn't support
inheritance, but it's great at delegation, and it makes creating
megawidgets easy.<p>

I should add, I'm not particularly down on Incr Tcl.  But "Snit's Not
Incr Tcl" occurred to me while I was casting about for a name, and I
guess there was a certainly inevitability about it.<p>

If you have any comments or suggestions (or bug reports!) don't
hesitate to send me e-mail at <a href="mailto:will@wjduquette.com">will@wjduquette.com</a>.  In
addition, there's now a Snit mailing list; you can find out more about
it at the Snit home page, <a
href="http://www.wjduquette.com/snit">http://www.wjduquette.com/snit</a>.
Finally, Snit is now part of tcllib, the standard Tcl library; you can
also add bug reports to the tcllib bug database at SourceForge.<p>

<h2><a name="credits">CREDITS</a></h2>

Snit has been designed and implemented from the very beginning by
William H. Duquette.  However, much credit belongs to the following
people for using Snit and providing me with valuable feedback: Rolf
Ade, Colin McCormack, Jose Nazario, Jeff Godfrey, Maurice Diamanti,
Egon Pasztor, David S. Cargo, Tom Krehbiel, Michael Cleverly, and
Andreas Kupries.


<p><hr><p>
Copyright &copy; 2003, by William H. Duquette.  All rights reserved.<p>


</body>
</html>
