
<html><head>
<title>huddle - HUDDLE</title>
<style type="text/css"><!--
    HTML {
	background: 	#FFFFFF;
	color: 		black;
    }
    BODY {
	background: 	#FFFFFF;
	color:	 	black;
    }
    DIV.doctools {
	margin-left:	10%;
	margin-right:	10%;
    }
    DIV.doctools H1,DIV.doctools H2 {
	margin-left:	-5%;
    }
    H1, H2, H3, H4 {
	margin-top: 	1em;
	font-family:	sans-serif;
	font-size:	large;
	color:		#005A9C;
	background: 	transparent;
	text-align:		left;
    }
    H1.doctools_title {
	text-align: center;
    }
    UL,OL {
	margin-right: 0em;
	margin-top: 3pt;
	margin-bottom: 3pt;
    }
    UL LI {
	list-style: disc;
    }
    OL LI {
	list-style: decimal;
    }
    DT {
	padding-top: 	1ex;
    }
    UL.doctools_toc,UL.doctools_toc UL, UL.doctools_toc UL UL {
	font:		normal 12pt/14pt sans-serif;
	list-style:	none;
    }
    LI.doctools_section, LI.doctools_subsection {
	list-style: 	none;
	margin-left: 	0em;
	text-indent:	0em;
	padding: 	0em;
    }
    PRE {
	display: 	block;
	font-family:	monospace;
	white-space:	pre;
	margin:		0%;
	padding-top:	0.5ex;
	padding-bottom:	0.5ex;
	padding-left:	1ex;
	padding-right:	1ex;
	width:		100%;
    }
    PRE.doctools_example {
	color: 		black;
	background: 	#f5dcb3;
	border:		1px solid black;
    }
    UL.doctools_requirements LI, UL.doctools_syntax LI {
	list-style: 	none;
	margin-left: 	0em;
	text-indent:	0em;
	padding:	0em;
    }
    DIV.doctools_synopsis {
	color: 		black;
	background: 	#80ffff;
	border:		1px solid black;
	font-family:	serif;
	margin-top: 	1em;
	margin-bottom: 	1em;
    }
    UL.doctools_syntax {
	margin-top: 	1em;
	border-top:	1px solid black;
    }
    UL.doctools_requirements {
	margin-bottom: 	1em;
	border-bottom:	1px solid black;
    }
--></style>
</head>
<! -- Generated from file 'huddle.man' by tcllib/doctools with format 'html'
   -->
<! -- Copyright &copy; 2008 KATO Kanryu &lt;kanryu6@users.sourceforge.net&gt;
   -->
<! -- huddle.n
   -->
<body><hr> [
   <a href="../../../../../../../../home">Tcllib Home</a>
| <a href="../../../../toc.html">Main Table Of Contents</a>
| <a href="../../../toc.html">Table Of Contents</a>
| <a href="../../../../index.html">Keyword Index</a>
| <a href="../../../../toc0.html">Categories</a>
| <a href="../../../../toc1.html">Modules</a>
| <a href="../../../../toc2.html">Applications</a>
 ] <hr>
<div class="doctools">
<h1 class="doctools_title">huddle(n) 0.1.6 tcllib &quot;HUDDLE&quot;</h1>
<div id="name" class="doctools_section"><h2><a name="name">Name</a></h2>
<p>huddle - Create and manipulate huddle object</p>
</div>
<div id="toc" class="doctools_section"><h2><a name="toc">Table Of Contents</a></h2>
<ul class="doctools_toc">
<li class="doctools_section"><a href="#toc">Table Of Contents</a></li>
<li class="doctools_section"><a href="#synopsis">Synopsis</a></li>
<li class="doctools_section"><a href="#section1">Description</a></li>
<li class="doctools_section"><a href="#section2">COMMANDS</a></li>
<li class="doctools_section"><a href="#section3">TYPE NAMESPACE</a></li>
<li class="doctools_section"><a href="#section4">How to add type</a></li>
<li class="doctools_section"><a href="#section5">WORKING SAMPLE</a></li>
<li class="doctools_section"><a href="#section6">LIMITATIONS</a></li>
<li class="doctools_section"><a href="#section7">Bugs, Ideas, Feedback</a></li>
<li class="doctools_section"><a href="#see-also">See Also</a></li>
<li class="doctools_section"><a href="#keywords">Keywords</a></li>
<li class="doctools_section"><a href="#copyright">Copyright</a></li>
</ul>
</div>
<div id="synopsis" class="doctools_section"><h2><a name="synopsis">Synopsis</a></h2>
<div class="doctools_synopsis">
<ul class="doctools_requirements">
<li>package require <b class="pkgname">Tcl 8.4</b></li>
<li>package require <b class="pkgname">huddle <span class="opt">?0.1.6?</span></b></li>
</ul>
<ul class="doctools_syntax">
<li><a href="#1"><b class="cmd">huddle create</b> <i class="arg">key</i> <i class="arg">value</i> <span class="opt">?<i class="arg">key value ...</i>?</span></a></li>
<li><a href="#2"><b class="cmd">huddle list</b> <span class="opt">?<i class="arg">value value ...</i>?</span></a></li>
<li><a href="#3"><b class="cmd">huddle number</b> <i class="arg">number</i></a></li>
<li><a href="#4"><b class="cmd">huddle string</b> <i class="arg">string</i></a></li>
<li><a href="#5"><b class="cmd">huddle boolean</b> <i class="arg">expression to evaluate as true or false</i></a></li>
<li><a href="#6"><b class="cmd">huddle true</b></a></li>
<li><a href="#7"><b class="cmd">huddle false</b></a></li>
<li><a href="#8"><b class="cmd">huddle null</b></a></li>
<li><a href="#9"><b class="cmd">huddle get</b> <i class="arg">object</i> <i class="arg">key</i> <span class="opt">?<i class="arg">key ...</i>?</span></a></li>
<li><a href="#10"><b class="cmd">huddle get_stripped</b> <i class="arg">object</i> <i class="arg">key</i> <span class="opt">?<i class="arg">key ...</i>?</span></a></li>
<li><a href="#11"><b class="cmd">huddle set</b> <i class="arg">objectVar</i> <i class="arg">key</i> <span class="opt">?<i class="arg">key ...</i>?</span> <i class="arg">value</i></a></li>
<li><a href="#12"><b class="cmd">huddle remove</b> <i class="arg">objectVar</i> <i class="arg">key</i> <span class="opt">?<i class="arg">key ...</i>?</span></a></li>
<li><a href="#13"><b class="cmd">huddle removed</b> <i class="arg">object</i> <i class="arg">key</i> <span class="opt">?<i class="arg">key ...</i>?</span></a></li>
<li><a href="#14"><b class="cmd">huddle combine</b> <i class="arg">object1</i> <i class="arg">object2</i> <span class="opt">?<i class="arg">object3 ...</i>?</span></a></li>
<li><a href="#15"><b class="cmd">huddle equal</b> <i class="arg">object1</i> <i class="arg">object2</i></a></li>
<li><a href="#16"><b class="cmd">huddle update_children</b> <i class="arg">objectVar</i> <i class="arg">key</i> <i class="arg">value</i> <span class="opt">?<i class="arg">key value ...</i>?</span></a></li>
<li><a href="#17"><b class="cmd">huddle lappend</b> <i class="arg">listVar</i> <i class="arg">value</i> <span class="opt">?<i class="arg">value ...</i>?</span></a></li>
<li><a href="#18"><b class="cmd">huddle keys</b> <i class="arg">object</i></a></li>
<li><a href="#19"><b class="cmd">huddle llength</b> <i class="arg">object</i></a></li>
<li><a href="#20"><b class="cmd">huddle type</b> <i class="arg">object</i> <span class="opt">?<i class="arg">key key...</i>?</span></a></li>
<li><a href="#21"><b class="cmd">huddle strip</b> <i class="arg">object</i></a></li>
<li><a href="#22"><b class="cmd">huddle json_dump</b> <i class="arg">object</i> <span class="opt">?<i class="arg">offset</i>?</span> <span class="opt">?<i class="arg">newline</i>?</span> <span class="opt">?<i class="arg">begin_offset</i>?</span></a></li>
<li><a href="#23"><b class="cmd">huddle compile</b> <i class="arg">spec</i> <i class="arg">data</i></a></li>
<li><a href="#24"><b class="cmd">huddle is_huddle</b> <i class="arg">object</i></a></li>
<li><a href="#25"><b class="cmd">huddle check_huddle</b> <i class="arg">object</i></a></li>
<li><a href="#26"><b class="cmd">huddle argument_to_node</b> <i class="arg">object</i> <span class="opt">?<i class="arg">tag</i>?</span></a></li>
<li><a href="#27"><b class="cmd">huddle wrap</b> <i class="arg">tag</i> <i class="arg">src</i></a></li>
<li><a href="#28"><b class="cmd">huddle call</b> <i class="arg">tag</i> <i class="arg">command</i> <i class="arg">args</i></a></li>
<li><a href="#29"><b class="cmd">huddle add_type</b> <i class="arg">namespace</i></a></li>
<li><a href="#30"><b class="cmd"><a href="../../../../index.html#key301">Set</a></b> <i class="arg">src_var</i> <i class="arg">key</i> <i class="arg">value</i></a></li>
<li><a href="#31"><b class="cmd">Strip</b> <i class="arg">src</i></a></li>
<li><a href="#32"><b class="cmd">Exists</b> <i class="arg">src</i> <i class="arg">key</i></a></li>
<li><a href="#33"><b class="cmd"><a href="../../../../index.html#key559">Equal</a></b> <i class="arg">src1</i> <i class="arg">src2</i></a></li>
<li><a href="#34"><b class="cmd">Update_children</b> <i class="arg">src_var</i> <i class="arg">items</i></a></li>
<li><a href="#35"><b class="cmd">Get_subnode</b> <i class="arg">src</i> <i class="arg">key</i></a></li>
<li><a href="#36"><b class="cmd">Combine</b> <i class="arg">list_of_src</i></a></li>
<li><a href="#37"><b class="cmd">Strip</b> <i class="arg">src</i></a></li>
<li><a href="#38"><b class="cmd"><a href="../../../../index.html#key301">Set</a></b> <i class="arg">src</i> <i class="arg">key</i> <i class="arg">value</i></a></li>
<li><a href="#39"><b class="cmd"><a href="../../../../index.html#key228">Remove</a></b> <i class="arg">src</i> <i class="arg">key</i> <i class="arg">value</i></a></li>
</ul>
</div>
</div>
<div id="section1" class="doctools_section"><h2><a name="section1">Description</a></h2>
<p>Huddle provides a generic Tcl-based serialization/intermediary format.
Currently, each node is wrapped in a tag with simple type information.</p>
<p>When converting huddle-notation to other serialization formats like
JSON or YAML this type information is used to select the proper notation.
And when going from JSON/YAML/... to huddle their notation can be used
to select the proper huddle type.</p>
<p>In that manner huddle can serve as a common intermediary format.</p>
<pre class="doctools_example">
huddle-format: &gt;
  {HUDDLE {huddle-node}}
huddle-node: &gt;
  {tag content}
each content of tag means:
  s: (content is a) string
  L: list, each sub node is a huddle-node
  D: dict, each sub node is a huddle-node
confirmed:
  - JSON
  - YAML(generally, but cannot discribe YAML-tags)
limitation:
  - cannot discribe aliases from a node to other node.
</pre>
<p>The <b class="package">huddle</b> package returns
data as a Tcl <b class="cmd"><a href="../../../../index.html#key704">dict</a></b>.  Either the <b class="package"><a href="../../../../index.html#key704">dict</a></b> package or Tcl 8.5 is
required for use.</p>
</div>
<div id="section2" class="doctools_section"><h2><a name="section2">COMMANDS</a></h2>
<dl class="doctools_definitions">
<dt><a name="1"><b class="cmd">huddle create</b> <i class="arg">key</i> <i class="arg">value</i> <span class="opt">?<i class="arg">key value ...</i>?</span></a></dt>
<dd><p>Create a huddle object as a dict. It can contain other huddle objects.</p></dd>
<dt><a name="2"><b class="cmd">huddle list</b> <span class="opt">?<i class="arg">value value ...</i>?</span></a></dt>
<dd><p>Create a huddle object as a list. It can contain other huddle objects.</p></dd>
<dt><a name="3"><b class="cmd">huddle number</b> <i class="arg">number</i></a></dt>
<dd><p>Create a huddle object as a number.</p></dd>
<dt><a name="4"><b class="cmd">huddle string</b> <i class="arg">string</i></a></dt>
<dd><p>Create a huddle object as a string.</p></dd>
<dt><a name="5"><b class="cmd">huddle boolean</b> <i class="arg">expression to evaluate as true or false</i></a></dt>
<dd><p>Create a huddle object as a boolean evaluating an expression as true or false-</p></dd>
<dt><a name="6"><b class="cmd">huddle true</b></a></dt>
<dd><p>Create a huddle object as a boolean true.</p></dd>
<dt><a name="7"><b class="cmd">huddle false</b></a></dt>
<dd><p>Create a huddle object as a boolean false.</p></dd>
<dt><a name="8"><b class="cmd">huddle null</b></a></dt>
<dd><p>Create a huddle object as a null.</p></dd>
<dt><a name="9"><b class="cmd">huddle get</b> <i class="arg">object</i> <i class="arg">key</i> <span class="opt">?<i class="arg">key ...</i>?</span></a></dt>
<dd><p>Almost the same as <b class="cmd">dict get</b>.
Get a sub-object from the huddle object.
<i class="arg">key</i> can be used to huddle-list's index.</p></dd>
<dt><a name="10"><b class="cmd">huddle get_stripped</b> <i class="arg">object</i> <i class="arg">key</i> <span class="opt">?<i class="arg">key ...</i>?</span></a></dt>
<dd><p>Get a sub-object from the huddle object, stripped.</p></dd>
<dt><a name="11"><b class="cmd">huddle set</b> <i class="arg">objectVar</i> <i class="arg">key</i> <span class="opt">?<i class="arg">key ...</i>?</span> <i class="arg">value</i></a></dt>
<dd><p>Almost the same as <b class="cmd">dict set</b>.
Set a sub-object from the huddle object.
<i class="arg">key</i> can be used to huddle-list's index.</p></dd>
<dt><a name="12"><b class="cmd">huddle remove</b> <i class="arg">objectVar</i> <i class="arg">key</i> <span class="opt">?<i class="arg">key ...</i>?</span></a></dt>
<dd><p>Almost the same as <b class="cmd">dict remove</b>.
Remove in place a sub-object from the huddle object.
<i class="arg">key</i> can be used to huddle-list's index.</p></dd>
<dt><a name="13"><b class="cmd">huddle removed</b> <i class="arg">object</i> <i class="arg">key</i> <span class="opt">?<i class="arg">key ...</i>?</span></a></dt>
<dd><p>Makes a copy of the huddle object and remove the indicated sub-object.
This is more efficient than making first a clone and then use <b class="cmd">huddle remove</b> for removing the desired sub-object.</p></dd>
<dt><a name="14"><b class="cmd">huddle combine</b> <i class="arg">object1</i> <i class="arg">object2</i> <span class="opt">?<i class="arg">object3 ...</i>?</span></a></dt>
<dd><p>Merging huddle objects given.  The objects should be of the same type.</p>
<pre class="doctools_example">
% set aa [huddle create a b c d]
HUDDLE {D {a {s b} c {s d}}}
% set bb [huddle create a k l m]
HUDDLE {D {a {s k} l {s m}}}
% huddle combine $aa $bb
HUDDLE {D {a {s k} c {s d} l {s m}}}
</pre>
</dd>
<dt><a name="15"><b class="cmd">huddle equal</b> <i class="arg">object1</i> <i class="arg">object2</i></a></dt>
<dd><p>Comparing two huddle objects recursively.
When to equal, returns 1, otherwise 0.</p>
<pre class="doctools_example">
% set aa [huddle create a b c d]
HUDDLE {D {a {s b} c {s d}}}
% set bb [huddle create c d a b]
HUDDLE {D {c {s d} a {s b}}}
% huddle equal $aa $bb
1
</pre>
</dd>
<dt><a name="16"><b class="cmd">huddle update_children</b> <i class="arg">objectVar</i> <i class="arg">key</i> <i class="arg">value</i> <span class="opt">?<i class="arg">key value ...</i>?</span></a></dt>
<dd><p>Update child elements. Lists only allow update indexes that are in its range.</p></dd>
<dt><a name="17"><b class="cmd">huddle lappend</b> <i class="arg">listVar</i> <i class="arg">value</i> <span class="opt">?<i class="arg">value ...</i>?</span></a></dt>
<dd><p>Append new children to a list.</p>
<pre class="doctools_example">
% set aa [huddle create a b c d]
HUDDLE {D {a {s b} c {s d}}}
% huddle append aa a k l m
HUDDLE {D {a {s k} c {s d} l {s m}}}
% set bb [huddle list i j k l]
HUDDLE {L {{s i} {s j} {s k} {s l}}}
% huddle append bb g h i
HUDDLE {L {{s i} {s j} {s k} {s l} {s g} {s h} {s i}}}
</pre>
</dd>
<dt><a name="18"><b class="cmd">huddle keys</b> <i class="arg">object</i></a></dt>
<dd><p>The same as <b class="cmd">dict keys</b>.</p></dd>
<dt><a name="19"><b class="cmd">huddle llength</b> <i class="arg">object</i></a></dt>
<dd><p>The same as <b class="cmd">llength</b>.</p></dd>
<dt><a name="20"><b class="cmd">huddle type</b> <i class="arg">object</i> <span class="opt">?<i class="arg">key key...</i>?</span></a></dt>
<dd><p>Return the element type of specified by keys.
if <span class="opt">?key?</span> is not given, returns the type of root node.</p>
<dl class="doctools_options">
<dt><b class="option"><b class="const">string</b></b></dt>
<dd><p>the node is a tcl's string.</p></dd>
<dt><b class="option"><b class="const">dict</b></b></dt>
<dd><p>the node is a dict.</p></dd>
<dt><b class="option"><b class="const">list</b></b></dt>
<dd><p>the node is a list.</p></dd>
<dt><b class="option"><b class="const">number</b></b></dt>
<dd><p>the node is a number.</p></dd>
<dt><b class="option"><b class="const">boolean</b></b></dt>
<dd><p>the node is a boolean.</p></dd>
<dt><b class="option"><b class="const">null</b></b></dt>
<dd><p>the node is a null.</p></dd>
</dl>
<pre class="doctools_example">
% huddle type {HUDDLE {s str}}
string
% huddle type {HUDDLE {L {{s a} {s b} {s c}}}}
list
% huddle type {HUDDLE {D {aa {s b} cc {s d}}}} cc
string
</pre>
</dd>
<dt><a name="21"><b class="cmd">huddle strip</b> <i class="arg">object</i></a></dt>
<dd><p>Stripped all tags. Converted to normal Tcl's list/dict.</p></dd>
<dt><a name="22"><b class="cmd">huddle json_dump</b> <i class="arg">object</i> <span class="opt">?<i class="arg">offset</i>?</span> <span class="opt">?<i class="arg">newline</i>?</span> <span class="opt">?<i class="arg">begin_offset</i>?</span></a></dt>
<dd><p>dump a json-stream from the huddle-object.</p>
<dl class="doctools_options">
<dt><b class="option"><b class="const">offset</b> &quot;&quot;</b></dt>
<dd><p>begin offset as spaces &quot;  &quot;.</p></dd>
</dl>
<pre class="doctools_example"># normal output has some indents. some strings are escaped.
% huddle json_dump {HUDDLE {L {{L {{s i} {s baa} {s \\k} {L {{s 1.0} {s true} {s /g} {s h}}} {L {{s g}}}}} {s t}}}}
[
  [
    &quot;i&quot;,
    &quot;baa&quot;,
    &quot;\\k&quot;,
    [
      1.0,
      true,
      &quot;\/g&quot;,
      &quot;h&quot;
    ],
    [&quot;g&quot;]
  ],
  &quot;t&quot;
]
# stripped output
% huddle json_dump {HUDDLE {D {dd {D {bb {D {a {s baa} c {s {d
a}}}} cc {D {g {s h}}}}} ee {D {i {s j} k {s 1} j {s { m\a}}}}}}} &quot;&quot; &quot;&quot;
{&quot;dd&quot;: {&quot;bb&quot;: {&quot;a&quot;: &quot;baa&quot;,&quot;c&quot;: &quot;d\na&quot;},&quot;cc&quot;: {&quot;g&quot;: &quot;h&quot;}},&quot;ee&quot;: {&quot;i&quot;: &quot;j&quot;,&quot;k&quot;: 1,&quot;j&quot;: &quot; m\\a&quot;}}
</pre>
</dd>
<dt><a name="23"><b class="cmd">huddle compile</b> <i class="arg">spec</i> <i class="arg">data</i></a></dt>
<dd><p>construct a huddle object from plain old tcl values.
<i class="arg">spec</i> is defined as follows:</p>
<dl class="doctools_definitions">
<dt><b class="const">string</b></dt>
<dd><p>data is simply a string</p></dd>
<dt><b class="const">list</b></dt>
<dd><p>data is a tcl list of strings</p></dd>
<dt><b class="const">dict</b></dt>
<dd><p>data is a tcl dict of strings</p></dd>
<dt>list list</dt>
<dd><p>data is a tcl list of lists</p></dd>
<dt>list dict</dt>
<dd><p>data is a tcl list of dicts</p></dd>
<dt>dict xx list</dt>
<dd><p>data is a tcl dict where the value of key xx is a tcl list</p></dd>
<dt>dict * list</dt>
<dd><p>data is a tcl dict of lists
<i class="arg">data</i> is plain old tcl values</p></dd>
</dl>
<pre class="doctools_example">% huddle compile {dict * list} {a {1 2 3} b {4 5}}
HUDDLE {D {a {L {{s 1} {s 2} {s 3}}} b {L {{s 4} {s 5}}}}}
% huddle compile {dict * {list {dict d list}}} {a {{c 1} {d {2 2 2} e 3}} b {{f 4 g 5}}}
HUDDLE {D {a {L {{D {c {s 1}}} {D {d {L {{s 2} {s 2} {s 2}}} e {s 3}}}}} b {L {{D {f {s 4} g {s 5}}}}}}}
</pre>
</dd>
<dt><a name="24"><b class="cmd">huddle is_huddle</b> <i class="arg">object</i></a></dt>
<dd><p>if <i class="arg">object</i> is a huddle, returns 1. Otherwise, returns 0.</p></dd>
<dt><a name="25"><b class="cmd">huddle check_huddle</b> <i class="arg">object</i></a></dt>
<dd><p>raise an error if <i class="arg">object</i> is not huddle.</p></dd>
<dt><a name="26"><b class="cmd">huddle argument_to_node</b> <i class="arg">object</i> <span class="opt">?<i class="arg">tag</i>?</span></a></dt>
<dd><p>for type-callbacks.</p>
<p>if <i class="arg">object</i> is a huddle, returns root-node. the other, returns <b class="cmd">[list s $object]</b>.</p>
<pre class="doctools_example">
% huddle argument_to_node str
s str
% huddle argument_to_node str !!str
!!str str
% huddle argument_to_node {HUDDLE {s str}}
s str
% huddle argument_to_node {HUDDLE {l {a b c}}}
l {a b c}
</pre>
</dd>
<dt><a name="27"><b class="cmd">huddle wrap</b> <i class="arg">tag</i> <i class="arg">src</i></a></dt>
<dd><p>for type-callbacks.</p>
<p>Create a huddle object from <i class="arg">src</i> with specified <i class="arg">tag</i>.</p>
<pre class="doctools_example">
% huddle wrap &quot;&quot; str
HUDDLE str
% huddle wrap s str
HUDDLE {s str}
</pre>
</dd>
<dt><a name="28"><b class="cmd">huddle call</b> <i class="arg">tag</i> <i class="arg">command</i> <i class="arg">args</i></a></dt>
<dd><p>for type-callbacks.</p>
<p>devolving <i class="arg">command</i> to default <i class="arg">tag</i>-callback</p></dd>
<dt><a name="29"><b class="cmd">huddle add_type</b> <i class="arg">namespace</i></a></dt>
<dd><p>add a user-specified-type/tag to the huddle library.
To see &quot;Additional Type&quot;.</p>
<dl class="doctools_options">
<dt><b class="option">namespace</b></dt>
<dd><p>name of namespace with the definition of the new type.</p></dd>
</dl></dd>
</dl>
</div>
<div id="section3" class="doctools_section"><h2><a name="section3">TYPE NAMESPACE</a></h2>
<p>There is two kind of types:</p>
<dl class="doctools_definitions">
<dt>Containers</dt>
<dd><p>It can contain other huddle object</p></dd>
<dt>Not containers</dt>
<dd><p>It can not contain other huddle object</p></dd>
</dl>
<p>All the types require a variable named settings. This variable has these attributes related to the type:</p>
<dl class="doctools_definitions">
<dt><b class="const">isContainer</b> boolean_flag</dt>
<dd><p>a boolean value indicating whether the new type is a container</p></dd>
<dt><b class="const">superclass</b> name_of_superclass</dt>
<dd><p>this is optional. It indicantes what is the super class of these type. All the methods of the super class are inherited.</p></dd>
<dt><b class="const">publicMethods</b> {method1 method2 method3 ...}</dt>
<dd><p>method list as huddle subcommand. Then, you can call <b class="cmd">[huddle method1 ...]</b></p></dd>
<dt><b class="const">map</b> {huddle_subcommand1 proc_name1 huddle_subcommand2 proc_name2 ...}</dt>
<dd><p>it defines a map bettween huddle subcommands and the associated proc inside the type namespace.</p></dd>
<dt><b class="const">tag</b> tag_name</dt>
<dd><p>a tag representing the type</p></dd>
</dl>
<p>There is some required procs in a container type:</p>
<dl class="doctools_definitions">
<dt><a name="30"><b class="cmd"><a href="../../../../index.html#key301">Set</a></b> <i class="arg">src_var</i> <i class="arg">key</i> <i class="arg">value</i></a></dt>
<dd><p>set a subnode in the guiven variable containing a subnode content</p></dd>
<dt><a name="31"><b class="cmd">Strip</b> <i class="arg">src</i></a></dt>
<dd><p>returns the node content stripped</p></dd>
<dt><a name="32"><b class="cmd">Exists</b> <i class="arg">src</i> <i class="arg">key</i></a></dt>
<dd><p>returns a boolean value indicating whether the key exists in the node content</p></dd>
<dt><a name="33"><b class="cmd"><a href="../../../../index.html#key559">Equal</a></b> <i class="arg">src1</i> <i class="arg">src2</i></a></dt>
<dd><p>returns a boolean vlaue indicating whether the two node contents are equal</p></dd>
<dt><a name="34"><b class="cmd">Update_children</b> <i class="arg">src_var</i> <i class="arg">items</i></a></dt>
<dd><p>udpate several subnodes at the same time for performance</p></dd>
<dt><a name="35"><b class="cmd">Get_subnode</b> <i class="arg">src</i> <i class="arg">key</i></a></dt>
<dd><p>returns a sub node specified by <i class="arg">key</i>.</p></dd>
<dt><a name="36"><b class="cmd">Combine</b> <i class="arg">list_of_src</i></a></dt>
<dd><p>returns a combined node content using the content of several nodes of the same type</p></dd>
<dt><a name="37"><b class="cmd">Strip</b> <i class="arg">src</i></a></dt>
<dd><p>returns stripped node contents. if the type has child nodes, every node must be stripped.</p></dd>
<dt><a name="38"><b class="cmd"><a href="../../../../index.html#key301">Set</a></b> <i class="arg">src</i> <i class="arg">key</i> <i class="arg">value</i></a></dt>
<dd><p>sets a sub-node from the tagged-content, and returns self.</p></dd>
<dt><a name="39"><b class="cmd"><a href="../../../../index.html#key228">Remove</a></b> <i class="arg">src</i> <i class="arg">key</i> <i class="arg">value</i></a></dt>
<dd><p>removes a sub-node from the tagged-content, and returns self.</p></dd>
</dl>
<pre class="doctools_example">
# callback sample for my-dict
proc my_dict_setting {command args} {
    switch -- $command {
        setting { ; # type definition
            return {
                type dict
                method {create keys}
                tag {d child D parent}
                constructor create
                str s
            }
            # type:   the type-name
            # method: add methods to huddle's subcommand.
            #          &quot;get_sub/strip/set/remove/equal/append&quot; called by huddle module.
            #          &quot;strip&quot; must be defined at all types.
            #          &quot;get_sub&quot; must be defined at container types.
            #          &quot;set/remove/equal/append&quot; shuould be defined, if you call them.
            # tag:    tag definition(&quot;child/parent&quot; word is maybe obsoleted)
        }
        get_subnode { ; # get a sub-node specified by &quot;key&quot; from the tagged-content
            foreach {src key} $args break
            return [dict get $src $key]
        }
        strip { ; # strip from the tagged-content
            foreach {src nop} $args break
            foreach {key val} $src {
                lappend result $key [huddle strip $val]
            }
            return $result
        }
        set { ; # set a sub-node from the tagged-content
            foreach {src key value} $args break
            dict set src $key $value
            return $src
        }
        remove { ; # remove a sub-node from the tagged-content
            foreach {src key value} $args break
            return [dict remove $src $key]
        }
        equal { ; # check equal for each node
            foreach {src1 src2} $args break
            if {[llength $src1] != [llength $src2]} {return 0}
            foreach {key1 val1} $src1 {
                if {![dict exists $src2 $key1]} {return 0}
                if {![huddle _equal_subs $val1 [dict get $src2 $key1]]} {return 0}
            }
            return 1
        }
        append { ; # append nodes
            foreach {str src list} $args break
            if {[llength $list] % 2} {error {wrong # args: should be &quot;huddle append objvar ?key value ...?&quot;}}
            set resultL $src
            foreach {key value} $list {
                if {$str ne &quot;&quot;} {
                    lappend resultL $key [huddle argument_to_node $value $str]
                } else {
                    lappend resultL $key $value
                }
            }
            return [eval dict create $resultL]
        }
        create { ; # $args: all arguments after &quot;huddle create&quot;
            if {[llength $args] % 2} {error {wrong # args: should be &quot;huddle create ?key value ...?&quot;}}
            set resultL {}
            foreach {key value} $args {
                lappend resultL $key [huddle argument_to_node $value]
            }
            return [huddle wrap D $resultL]
        }
        keys {
            foreach {src nop} $args break
            return [dict keys [lindex [lindex $src 1] 1]]
        }
        default {
            error &quot;$command is not callback for dict&quot;
        }
    }
}
</pre>
<pre class="doctools_example">
# inheritance sample from default dict-callback
proc ::yaml::_huddle_mapping {command args} {
    switch -- $command {
        setting { ; # type definition
            return {
                type dict
                method {mapping}
                tag {!!map parent}
                constructor mapping
                str !!str
            }
        }
        mapping { ; # $args: all arguments after &quot;huddle mapping&quot;
            if {[llength $args] % 2} {error {wrong # args: should be &quot;huddle mapping ?key value ...?&quot;}}
            set resultL {}
            foreach {key value} $args {
                lappend resultL $key [huddle argument_to_node $value !!str]
            }
            return [huddle wrap !!map $resultL]
        }
        default { ; # devolving to default dict-callback
            return [huddle call D $command $args]
        }
    }
}
</pre>
</div>
<div id="section4" class="doctools_section"><h2><a name="section4">How to add type</a></h2>
<p>You can add huddle-node types e.g. a special type for dates.
To do so, first, define a namespace for additional tagged-type.
The namespace require a variable named settings indicating the options associated to this type.</p>
<p>And, execute the proc <b class="cmd">add_type</b> <i class="arg">namespace_of_the_type</i>
to register this new type.</p>
<pre class="doctools_example">
huddle add_type type_name
</pre>
<p>If the new type is a container of other types, the namespace will require the definition of these procs as mentioned before:</p>
<ul class="doctools_itemized">
<li><p>Set</p></li>
<li><p>Strip</p></li>
<li><p>Remove</p></li>
<li><p>Equal</p></li>
<li><p>Exists</p></li>
<li><p>Get_subnode</p></li>
<li><p>Update_children</p></li>
<li><p>Combine</p></li>
</ul>
</div>
<div id="section5" class="doctools_section"><h2><a name="section5">WORKING SAMPLE</a></h2>
<pre class="doctools_example">
# create as a dict
% set bb [huddle create a b c d]
HUDDLE {D {a {s b} c {s d}}}
# create as a list
% set cc [huddle list e f g h]
HUDDLE {L {{s e} {s f} {s g} {s h}}}
% set bbcc [huddle create bb $bb cc $cc]
HUDDLE {D {bb {D {a {s b} c {s d}}} cc {L {{s e} {s f} {s g} {s h}}}}}
% set folding [huddle list $bbcc p [huddle list q r] s]
HUDDLE {L {{D {bb {D {a {s b} c {s d}}} cc {L {{s e} {s f} {s g} {s h}}}}} {s p} {L {{s q} {s r}}} {s s}}}
# normal Tcl's notation
% huddle strip $folding
{bb {a b c d} cc {e f g h}} p {q r} s
# get a sub node
% huddle get $folding 0 bb
HUDDLE {D {a {s b} c {s d}}}
% huddle gets $folding 0 bb
a b c d
# overwrite a node
% huddle set folding 0 bb c kkk
HUDDLE {L {{D {bb {D {a {s b} c {s kkk}}} cc {L {{s e} {s f} {s g} {s h}}}}} {s p} {L {{s q} {s r}}} {s s}}}
# remove a node
% huddle remove $folding 2 1
HUDDLE {L {{D {bb {D {a {s b} c {s kkk}}} cc {L {{s e} {s f} {s g} {s h}}}}} {s p} {L {{s q}}} {s s}}}
% huddle strip $folding
{bb {a b c kkk} cc {e f g h}} p {q r} s
# dump as a JSON stream
% huddle json_dump $folding
[
  {
    &quot;bb&quot;: {
      &quot;a&quot;: &quot;b&quot;,
      &quot;c&quot;: &quot;kkk&quot;
    },
    &quot;cc&quot;: [
      &quot;e&quot;,
      &quot;f&quot;,
      &quot;g&quot;,
      &quot;h&quot;
    ]
  },
  &quot;p&quot;,
  [
    &quot;q&quot;,
    &quot;r&quot;
  ],
  &quot;s&quot;
]
</pre>
</div>
<div id="section6" class="doctools_section"><h2><a name="section6">LIMITATIONS</a></h2>
<p>now printing.</p>
</div>
<div id="section7" class="doctools_section"><h2><a name="section7">Bugs, Ideas, Feedback</a></h2>
<p>This document, and the package it describes, will undoubtedly contain
bugs and other problems.
Please report such in the category <em>huddle</em> of the
<a href="http://core.tcl.tk/tcllib/reportlist">Tcllib Trackers</a>.
Please also report any ideas for enhancements you may have for either
package and/or documentation.</p>
</div>
<div id="see-also" class="doctools_section"><h2><a name="see-also">See Also</a></h2>
<p><a href="yaml.html">yaml</a></p>
</div>
<div id="keywords" class="doctools_section"><h2><a name="keywords">Keywords</a></h2>
<p><a href="../../../../index.html#key205">data exchange</a>, <a href="../../../../index.html#key204">exchange format</a>, <a href="../../../../index.html#key587">huddle</a>, <a href="../../../../index.html#key206">json</a>, <a href="../../../../index.html#key26">parsing</a>, <a href="../../../../index.html#key192">text processing</a>, <a href="../../../../index.html#key588">yaml</a></p>
</div>
<div id="copyright" class="doctools_section"><h2><a name="copyright">Copyright</a></h2>
<p>Copyright &copy; 2008 KATO Kanryu &lt;kanryu6@users.sourceforge.net&gt;</p>
</div>
</div></body></html>
