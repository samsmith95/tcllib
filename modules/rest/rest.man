[comment {-*- tcl -*- doctools manpage}]
[vset VERSION 1.0.1]
[manpage_begin rest n [vset VERSION]]
[moddesc   {A framework for RESTful web services}]
[titledesc {define REST web APIs and call them inline or asychronously}]
[require Tcl 8.5]
[require rest [opt [vset VERSION]]]
[description]

There are two types of usage this package supports: [term {simple calls}],
and complete [term interfaces].

In an [term interface] you specify a set of rules and then the package
builds the commands which correspond to the REST methods. These
commands can have many options such as input and output
transformations and data type specific formatting. This results in a
cleaner and simpler script.

On the other hand, while a [term {simple call}] is easier and quicker
to implement it is also less featureful. It takes the url and a few
options about the command and returns the result directly. Any
formatting or checking is up to rest of the script.

[section {Simple usage}]

In simple usage you make calls using the http method procedures and
then check or process the returned data yourself

[comment {= = == === ===== ======== ============= =====================}]
[comment {= = == === ===== ======== ============= =====================}]
[list_begin definitions]
[call [cmd ::rest::simple] [arg url] [arg query] [opt [arg config]] [opt [arg body]]]
[call [cmd ::rest::get]    [arg url] [arg query] [opt [arg config]] [opt [arg body]]]
[call [cmd ::rest::post]   [arg url] [arg query] [opt [arg config]] [opt [arg body]]]
[call [cmd ::rest::head]   [arg url] [arg query] [opt [arg config]] [opt [arg body]]]
[call [cmd ::rest::put]    [arg url] [arg query] [opt [arg config]] [opt [arg body]]]
[call [cmd ::rest::delete] [arg url] [arg query] [opt [arg config]] [opt [arg body]]]

[para] These commands are all equivalent except for the http method
used.

If you use [cmd simple] then the method should be specified as an
option in the [arg config] dictionary. If that is not done it defaults
to [const get]. If a [arg body] is needed then the [arg config]
dictionary must be present, however it is allowed to be empty.

[para] The [arg config] dictionary supports the following keys

[list_begin definitions]
[def [const auth]]
[def [const content-type]]
[def [const cookie]]
[def [const format]]
[def [const headers]]
[def [const method]]

[comment {-- TODO -- describe the meaning of the various keys -- }]
[list_end]

[para] Two quick examples:

[para] Example 1, Yahoo Boss:
[comment {--- --- --- --- -- ---- --- --- ---}][example {
    set appid APPID
    set search tcl
    set res [rest::get http://boss.yahooapis.com/ysearch/web/v1/$search [list appid $appid]]
    set res [rest::format_json $res]
}][comment {--- --- --- --- -- ---- --- --- ---}]

[para] Example 2, Twitter:
[comment {--- --- --- --- -- ---- --- --- ---}][example {
    set url   http://twitter.com/statuses/update.json
    set query [list status $text]
    set res [rest::simple $url $query {
        method post
        auth   {basic user password}
        format json
    }]
}][comment {--- --- --- --- -- ---- --- --- ---}]

[list_end]

[section {Interface usage}]

An interface to a REST API consists of a series of definitions of REST
calls contained in an array.

The name of that array becomes a namespace containing the defined
commands. Each key of the array specifies the name of the call, with
the associated configuration a dictionary, i.e. key/value pairs.

These keys are the defined configuration options described below.
After creating the definitions calling [cmd rest::create_interface]
with the array as argument will then create the commands.

[para] Example, Yahoo Weather:
[comment {--- --- --- --- --- --- --- --- ---}][example {
    package require rest

    set yweather(forecast) {
       url      http://weather.yahooapis.com/forecastrss
       req_args { p: }
       opt_args { u: }
    }
    rest::create_interface yweather
    puts [yweather::forecast -p 94089]
}][comment {--- --- --- --- -- ---- --- --- ---}]

[comment { -- TODO -- figure out what these are ! standard methods ?
::${name}::basic_auth [arg u] [arg p]
::${name}::set_static_args [opt args]]
}]

[comment {= = == === ===== ======== ============= =====================}]
[comment {= = == === ===== ======== ============= =====================}]
[list_begin definitions]

[comment {= = == === ===== ======== ============= =====================}]
[call [cmd ::rest::save] [arg name] [arg file]]

This command saves a copy of the dynamically created procedures for
all the API calls specified in the array variable [arg name] to the
[arg file], for later loading.

[para] The result of the command is the empty string

[comment {= = == === ===== ======== ============= =====================}]
[call [cmd ::rest::describe] [arg name]]

This command prints a description of all API calls specified in the array
variable [arg name] to the channel [const stdout].

[para] The result of the command is the empty string.

[comment {= = == === ===== ======== ============= =====================}]
[call [cmd ::rest::parameters] [arg url] [opt args]]

This command parses an [arg url] query string into a dictionary and
returns said dictionary as its result.

[para] -- TODO -- document the args/options? --

[comment {= = == === ===== ======== ============= =====================}]
[call [cmd ::rest::parse_opts] [arg static] [arg required] [arg optional] [arg string]]

-- TODO -- document this command --

[call [cmd ::rest::substitute] [arg string] [opt var]]

This command takes a [arg string], substitutes real values for any
option identifiers found inside and returns the modified string as its
results.

[para] -- TODO -- document the var --

[comment {= = == === ===== ======== ============= =====================}]
[call [cmd ::rest::create_interface] [arg name]]

This command creates procedures for all the API calls specified in the
array variable [arg name].

[para] -- TODO -- document the names and signatures of these procedures.

TOKENS
     the value is substituted into the url at call time. tokens in the form of %name:default_value% will be an optional argument with a default value.

[list_end]


[section {Declaration Keys}]

In this section we explain the set of keys allowed in interface declarations, and their meanings.

[list_begin definitions]
[comment @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@]
[def [const url]]

The target of the http request. Required.

[comment @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@]
[def [const description]]

A short string which describes the call.
Used only by [cmd ::rest::describe], see above.

[comment @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@]
[def [const body]]

indicates if arguments are required for the request body or
not. should be one of none, optional, required, argument or
mime_multipart. default is optional.  if [const argument] is used then
the option is parsed as a list where the second value is the name of a
option. the body will then be used as the value for that option.  if
the value is [const mime_multipart] then the body is required and
interpreted as each argument representing one part of a mime multipart
document. each argument should be a 2 item list with the first being a
list of header keys and values, and the second being the mime part
body.

[comment @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@]
[def [const method]]

The HTTP method to call on the url. The default is GET.

[comment @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@]
[def [const copy]]

this copies the definition of a previously defined call. after copying
you can override selected options by defining them again.

[comment @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@]
[def [const unset]]

removes the named option. useful when using copy of another definition.

[comment @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@]
[def [const headers]]

the value must be another dict containing header fields and their
values. The default is to not add any additional headers.

[comment @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@]
[def [const content-type]]

Specifies the content type for the request data.

[comment @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@]
[def [const req_args]]

a list of the required arguments. names ending in a colon will require
a value.

[comment @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@]
[def [const opt_args]]

arguments that may be present but are not required.

[comment @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@]
[def [const static_args]]

arguments that are always the same. no sense in troubling the user
with these. A leading - is allowed but not required to maintain
consistancy with the command line.

[comment @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@]
[def [const auth]]

should be one of basic or sign. if basic is used you can configure
basic auth with the proc auth_basic which takes 2 arguments, the
username and password.

if sign is specified then the value must be a list with the second
element being the name of a proc which will be called to perform the
request signing.

[comment @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@]
[def [const callback]]

If this option is present then the method will be created as an async
call. An async call will return immediately with the value of the http
token. The event loop must be active to use this option. The value of
this option is the name of a proc which is invoked when the HTTP call
is complete. The proc receives three arguments, the name of the
calling procedure, the status of the result (one of OK or ERROR), and
the data associated with the result.

the http request header is available via [cmd {upvar token token}]

[comment @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@]
[def [const cookie]]

a list of cookies to be passed in the http header. this is just a
shortcut to the headers option

[comment @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@]
[def [const input_transform]]

commands which take the variable $query and transform it in some
manner before returning a new value. return value must be a dict which
will be passed to http::formatQuery

the request body is accessible via [cmd {upvar body body}]

[comment @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@]
[def [const format]]

defines the format of the returned data. should be one of discard,
raw, json, xml, or tdom. the default is auto which should auto detect
between xml and json. rss is formated as a special case of xml.

[comment @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@]
[def [const pre_transform]]

this value takes the form of a proc which should perform some action
on $result and return a value. it is run on the result before the
output (xml/json/etc) transformation is done.

the http request header is available via [cmd {upvar token token}]

[comment @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@]
[def [const result]]

may have the value xml, json, tdom, raw, or auto. the default is auto
and should auto detect json or xml results and transform them into a
tcl list. this is here if you want to specify it explicitly.

[comment @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@]
[def [const post_transform]]

this value takes the form of a proc which should perform some action
on $result and return a value. it is run on the result after the
output transformation but before returning the value to the calling
procedure.

the http request header is available via [cmd {upvar token token}]

[comment @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@]
[def [const check_result]]

this value should be a list of 2 expressions either of which may be
empty. the first expression is checks the OK condition, it must return
true when the result is satisfactory. the second expression is the
error condition, it must return false unless there is an error.

[comment @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@]
[list_end]


[section Examples]

[para] Yahoo Geo:
[comment {--- --- --- --- -- ---- --- --- ---}][example {
set ygeo(parse) {
    url http://wherein.yahooapis.com/v1/document
    method post
    body { arg documentContent }
}
ygeo::parse "san jose ca"
# "san jose ca" will be interpreted as if it were specified as the -documentContent option
}][comment {--- --- --- --- -- ---- --- --- ---}]

[para] Google Docs:
[comment {--- --- --- --- -- ---- --- --- ---}][example {
set gdocs(upload) {
    url http://docs.google.com/feeds/default/private/full
    body mime_multipart
}
gdocs::upload [list {Content-Type application/atom+xml} $xml] [list {Content-Type image/jpeg} $filedata]
}][comment {--- --- --- --- -- ---- --- --- ---}]

[para] Delicious:
[comment {--- --- --- --- -- ---- --- --- ---}][example {
set delicious(updated) {
    url https://api.del.icio.us/v1/posts/update
    auth basic
}

rest::create_interface flickr

flickr::basic_auth username password
}][comment {--- --- --- --- -- ---- --- --- ---}]

[para] Flickr:
[comment {--- --- --- --- -- ---- --- --- ---}][example {
set flickr(auth.getToken) {
   url http://api.flickr.com/services/rest/
   req_args { api_key: secret: }
   auth { sign do_signature }
}

rest::create_interface flickr

proc ::flickr::do_signature {query} {
    # perform some operations on the query here
    return $query
}
}][comment {--- --- --- --- -- ---- --- --- ---}]

[section INCLUDED]

The package provides functional but incomplete implementations for the following services:

[list_begin definitions]
[def [const del.icio.us]]
[def [const facebook]]
[def [const flickr]]
[def [const twitter]]
[def [const {google calendar}]]
[def [const {yahoo boss}]]
 [def [const {yahoo weather}]]
[list_end]

Please either read the package's implementation, or use
[cmd rest::describe] after loading it for their details.

[para] Do not forget developers' documentation on the respective sites either.

[include ../common-text/tls-security-notes.inc]

[vset CATEGORY rest]
[include ../doctools2base/include/feedback.inc]
[manpage_end]
