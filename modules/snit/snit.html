<html><head>
    <title>Snit -- Snit's Not Incr Tcl</title>
</head>

<BODY>

<h1>Snit -- Snit's Not Incr Tcl</h1>

<ul>
  <li> <a href="#synopsis">SYNOPSIS</a>
  <li> <a href="#overview">OVERVIEW</a>
  <li> <a href="#reference">REFERENCE</a>
       <ul>
         <li> <a href="#type_and_widget_definitions">Type and Widget Definitions</a>
         <li> <a href="#the_type_command">The Type Command</a>
         <li> <a href="#standard_type_methods">Standard Type Methods</a>
         <li> <a href="#the_instance_command">The Instance Command</a>
         <li> <a href="#standard_instance_methods">Standard Instance Methods</a>
         <li> <a href="#commands_for_use_in_object_code">Commands for use in Object Code</a>
         <li> <a href="#components_and_delegation">Components and Delegation</a>
       </ul>
  <li> <a href="#history">HISTORY</a>
  <li> <a href="#credits">CREDITS</a>
</ul>

<h2><a name="synopsis">SYNOPSIS</a></h2>

<pre>
    package require snit 0.81
    ::snit::type <i>name</i> <i>definition</i>
    ::snit::widget <i>name</i> <i>definition</i>
    ::snit::widgetadaptor <i>name</i> <i>definition</i>
</pre><p>

<h2><a name="overview">OVERVIEW</a></h2>

Snit is yet another pure Tcl object and megawidget system.  It's
unique among Tcl object systems (so far as I know) in that it's a
system based not on inheritance but on delegation.  Object systems
based on inheritance only allow you to inherit from classes defined
using the same system, and that's a shame.  In Tcl, an object
is anything that acts like an object; it shouldn't matter how the
object was implemented.  I designed Snit to help me build applications
out of the materials at hand; thus, Snit is designed to be able to
incorporate and build on any object, whether it's a hand-coded object,
a Tk widget, an Incr Tcl object, a BWidget or almost anything else.<p>

This man page is intended to be a reference only; see the accompanying
<a href="faq.html">Snit FAQ list</a> for a gentler, more tutorial
introduction to Snit concepts.<p>


<h2><a name="reference">REFERENCE</a></h2>

<h3><a name="type_and_widget_definitions">Type and Widget Definitions</a></h3>

<dl>
  <dt> <code><a name="snit::type">snit::type <i>name</i> <i>definition</i></a></code>
  <dd> Defines a new abstract data type called
       <i>name</i>.  If <i>name</i> is not a fully qualified command
       name, it is assumed to be a name in the namespace in which the
       snit::type command appears (usually the global namespace).  It
       returns the fully qualified type name.<p>

       The type name is then a command which is used to
       create objects of the new type, along with other
       activities.<p>

       The snit::type <i>definition</i> block may contain the
       following definitions:<p>

       <dl>
         <dt> <code><a name="typevariable">typevariable <i>name</i> ?<i>value</i>?</a></code>
         <dd> Defines a type variable with the specified name, and
              optionally the specified value.  Type variables are
              shared by all instances of the type.  This definition
              can be used to define array variables, but cannot
              initialize their elements.<p>
       
         <dt> <code><a name="typemethod">typemethod <i>name</i> <i>arglist</i> <i>body</i></a></code>
         <dd> Defines a type method with the specified name, argument
              list, and body.  The variable "type" is automatically defined in
              the <i>body</i> to the type's fully-qualified name.<p>

              The <i>arglist</i> is a normal Tcl argument list and may
              contain default arguments and the "args" argument;
              however, it may not contain the argument names "type",
              "self", "selfns", or "win".<p>

              Type variables defined in the type <i>definition</i> are
              automatically visible in the <i>body</i> of every type method.<p>
              
         <dt> <code><a name="option">option <i>name</i> ?<i>defaultValue</i>?</a></code>
         <dd> Defines an option for instances of this type, and
              optionally gives it an initial value.  (The option's
              value defaults to "" if no initial value is specified.)
              The option's <i>name</i> must begin with a hyphen, "-".
              Options are normally set and retrieved using the
              standard <code><a href="#configure">configure</a></code> and <code><a href="#cget">cget</a></code> instance
              methods.<p>

              An option defined in this way is said to be "locally
              defined".<p>

         <dt> <code><a name="variable">variable <i>name</i> ?<i>value</i>?</a></code>
         <dd> Defines an instance variable, a private variable
              associated with each instance of this type, and
              optionally its initial value.  This definition can be
              used to define array instance variables, but cannot
              initialize their elements.<p>

              Note that the <code>delegate</code> statement implicitly
              defines an instance variable for the named component.<p>
       
         <dt> <code><a name="method">method <i>name</i> <i>arglist</i> <i>body</i></a></code>
         <dd> Defines an instance method, a subcommand of each
              instance of this type, with the specified name, argument list
              and body.  The <i>arglist</i> is a standard Tcl argument
              list, and may contain default values and the
              <code>args</code> 

              The <i>arglist</i> is a normal Tcl argument list and may
              contain default arguments and the "args" argument.  In
              addition, the method is implicitly passed the following
              arguments as well: "type", which contains the
              fully-qualified type name; "self", which contains the
              current instance command name; "selfns", which contains
              the name of the instance's private namespace; and
              "win", which contains the original instance name.
              Consequently, the <i>arglist</i> may not contain the
              argument names "type", "self", "selfns", or "win".<p>

              An instance method defined in this way is said to be
              "locally defined".<p>

              Type and instance variables defined in the type
              <i>definition</i> are automatically visible in all
              instance methods.  If the type has locally defined
              options, the "options" array is also visible.<p>

         <dt> <code><a name="constructor">constructor <i>arglist</i> <i>body</i></a></code>
         <dd> The constructor definition specifies a <i>body</i> of
              code to be executed when a new instance is created.<p>

              The <i>arglist</i> is a normal Tcl argument list and may
              contain default arguments and the "args" argument.
              As with methods, the arguments "type",
              "self", "selfns", and "win", are defined implicitly.<p>

              If the constructor is not defined, it defaults to this:<p>

              <pre>
              constructor {args} {
                  $self configurelist $args
              }
              </pre><p>

              For standard Tk widget behavior (or to achieve the
              behavior of previous versions of snit) the argument list
              should be the single name "args", as shown.<p>

         <dt> <code><a name="destructor">destructor <i>body</i></a></code>
         <dd> The destructor is used to code any actions which must
              take place when an instance of the type is destroyed:
              typically, the destruction of anything created in the
              constructor.<p>

              As with arguments, the parameters "type",
              "self", "selfns", and "win", are defined implicitly.<p>
              
         <dt> <code><a name="onconfigure">onconfigure <i>name</i> <i>arglist</i> <i>body</i></a></code>
         <dd> Every locally-defined option has an "onconfigure"
              handler which is called when the option is set to a new
              value by the "configure" or "configurelist" instance
              method.<p>

              The <i>arglist</i> may contain exactly one
              argument name. As with methods, the arguments "type",
              "self", "selfns", and "win", are defined implicitly.<p>

              If no explicit onconfigure handler is defined for an
              option, the handler is defined as follows:<p>

              <pre>
              onconfigure <i>name</i> {value} {
                  set options(<i>name</i>) $value
              }
              </pre>

              If an explicit onconfigure handler is defined, the
              options array will be updated with the new value only if
              the handler so updates it.<p>
              
         <dt> <code><a name="oncget">oncget <i>name</i> <i>body</i></a></code>
         <dd> Every locally-defined option has an "oncget" handler
              which is called when the option's value is retrieved.

              Although there is no explicit argument list, the
              arguments "type", "self", "selfns", and "win", are
              defined implicitly, just as they are for methods.<p> 

              The variables "type", "self", "selfns", and "win" are
              defined as usual in the handler's <i>body</i>.  Whatever
              the handler returns will be the return value of the call
              to the <code><a href="#cget">cget</a></code> instance method.<p>

              If no explicit oncget handler is defined for an option,
              the handler is defined as follows:<p>

              <pre>
              oncget <i>name</i> {
                  return $options(<i>name</i>)
              }
              </pre>
              
         <dt> <code><a name="proc">proc <i>name</i> <i>args</i> <i>body</i></a></code>
         <dd> Defines a new Tcl procedure in the type's namespace.
              The new proc differs from a normal Tcl proc in that
              all type variables defined in the type
              <i>definition</i> are automatically
              visible.<p>

              Although they are not implicitly defined for procs, the
              argument names "type", "self", "selfns", and "win"
              should be avoided.<p>
              
         <dt> <code><a name="delegate">delegate method <i>name</i> to <i>comp</i> ?as <i>compmethod compargs...</i>?</a></code>
         <dd> Defines a delegated instance method.  When instance
              method <i>name</i> is used with an instance of this
              type, it will automatically be delegated to the named
              component as though the method were defined as follows:<p>

              <pre>
              method <i>name</i> {<i>args...</i>} {
                  $<i>comp</i> mymethod <i>args...</i>
              }
              </pre>

              If desired, the delegated method may target a method
              with a different name by using the "as" clause; it may
              also add arguments to the beginning of the argument
              list.  In that case, it's as though the delegated method
              were defined as follows:<p>

              <pre>
              method <i>name</i> {<i>args...</i>} {
                  $<i>comp</i> <i>compmethod</i> \
                      <i>compargs...</i>  <i>args...</i>
              }
              </pre>

              If the specified method <i>name</i> is "*", then all
              unknown method names passed to the instance will be
              passed along to the specified <i>comp</i>.  In this
              case, the "as" clause is not allowed.<p>

              A method cannot be both locally defined and delegated.<p>
              
         <dt> <code><a name="delegate">delegate option <i>name</i> to <i>comp</i> ?as <i>compoption</i>?</a></code>
         <dd> Defines a delegated option.  When the
              <code><a href="#configure">configure</a></code>, <code><a href="#configurelist">configurelist</a></code>, or
              <code><a href="#cget">cget</a></code> instance method is used to set or
              retrieve the option's value, the equivalent configure or
              cget command will be applied to the component as though
              these <code><a href="#onconfigure">onconfigure</a></code> and <code><a href="#oncget">oncget</a></code> handlers were
              defined:<p>

              <pre>
              onconfigure <i>name</i> {value} {
                  $<i>comp</i> configure <i>compoption</i> $value
              }
              
              oncget <i>name</i> {
                  return [$<i>comp</i> cget <i>compoption</i>]
              }
              </pre>

              If the "as" clause is omitted, the <i>compoption</i>
              name is the same as <i>name</i>.<p>

              Warning: options can only be delegated to a component if
              it supports the "configure" and "cget" instance methods.<p>
       </dl>
  <dt> <code><a name="snit::widget">snit::widget <i>name</i> <i>definition</i></a></code>
  <dd> This command defines a Snit megawidget type with the specified
       <i>name</i>.  The <i>definition</i> is defined identically to
       that for <code>snit::type</code>.  A <code>snit::widget</code>
       differs from a <code>snit::type</code> in these ways:<p>

       <ul>
         <li> Every snit::widget instance has an automatically-created
              component called <code>hull</code>, which is a Tk frame
              widget.  Other widgets created as part of the megawidget
              will be created within this frame.<p>

              The hull component is initially created with the
              requested widget name; then Snit does some magic,
              renaming the hull component and installing its own
              instance command in its place.  The hull component's new
              name is saved in an instance variable called
              <code>hull</code>.<p>

         <li> The name of an instance must be valid Tk window name,
              and the parent window must exist.<p>
       </ul>
       
  <dt> <code><a name="snit::widgetadaptor">snit::widgetadaptor <i>name</i> <i>definition</i></a></code>
  <dd> This command defines a Snit megawidget type with the specified
       name.  It differs from <code>snit::widget</code> in that the
       instance's <code>hull</code> component is not created
       automatically, but is created in the constructor and installed
       using the <code><a href="#installhull">installhull</a></code> command.  Once the hull is
       installed, its instance command is renamed and replaced as with
       normal <code>snit::widgets</code>.  The original command is
       again accessible in the instance variable <code>hull</code>.<p>
</dl>

<h3><a name="the_type_command">The Type Command</a></h3>

A type or widget definition creates a type command, which is used to
create instances of the type.  The type command this form.<p>

<dl>
  <dt> <code>$type <i>typemethod</i> <i>args....</i></code>
  <dd> The <i>typemethod</i> can be any of the standard type methods
       defined in the next section, or any type method defined in the
       type definition.  The subsequent <i>args</i> depend on the
       specific <i>typemethod</i> chosen.<p>
</dl>

<h3><a name="standard_type_methods">Standard Type Methods</a></h3>

In addition to any typemethods in the type's definition, all types and
widgets will have at least the following method:<p>

<dl>
  <dt> <code><a name="$type">$type create <i>name</i> ?<i>option</i> <i>value</i> ...?</a></code>
  <dd> Creates a new instance of the type, giving it the specified
       <i>name</i> and calling the type's constructor.<p>

       For <code>snit::types</code>, if <i>name</i> is not a fully-qualified
       command name, it is assumed to be a name in the namespace in
       which the call to snit::type appears.  The method returns the
       fully-qualified instance name.<p>

       For <code>snit::widgets</code> and
       <code>snit::widgetadaptors</code>, <i>name</i> must be a valid
       widget name; the method returns the widget name.<p>

       So long as <i>name</i> does not conflict with any defined type
       method name, the "create" keyword may be omitted.<p>

       If the <i>name</i> includes the string "%AUTO%", it will be
       replaced with the string "$type$counter" where "$type" is the
       type name and "$counter" is a counter that increments each time
       "%AUTO%" is used for this type.<p>

       By default, any arguments following the <i>name</i> will be a
       list of <i>option</i> names and their <i>value</i>s; however, a
       type's constructor can specify a different argument list.<p>

  <dt> <code><a name="$type">$type info typevars</a></code>
  <dd> Returns a list of the type's type variables (excluding Snit
       internal variables); all variable names are fully-qualified.<p>

  <dt> <code><a name="$type">$type info instances</a></code>
  <dd> Returns a list of the type's instances.  For snit::types, it
       will be a list of fully-qualified instance names; for
       snit::widgets, it will be a list of Tk widget names.<p>

  <dt> <code><a name="$type">$type destroy</a></code>
  <dd> Destroys the type's instances, the type's namespace, and the
       type command itself.<p>
</dl>

<h3><a name="the_instance_command">The Instance Command</a></h3>

A Snit type or widget's <code><a href="#create">create</a></code> type method creates
objects of the type; each object has a unique name which is also a
Tcl command.  This command is used to access the object's methods and
data, and has this form:<p>

<dl>
  <dt> <code>$object <i>method</i> <i>args...</i></code>
  <dd> The <i>method</i> can be any of the standard instance methods
       defined in the next section, or any instance method defined in
       the type definition. The subsequent <i>args</i> depend on the
       specific <i>method</i> chosen.<p>
</dl>

<h3><a name="standard_instance_methods">Standard Instance Methods</a></h3>

In addition to any delegated or locally-defined instance methods in
the type's definition, all Snit objects will have at least the
following methods:<p>

<dl>
  <dt> <code><a name="$object">$object configure ?<i>option</i>? ?<i>value</i>? ...</a></code>
  <dd> Assigns new values to one or more options.  If called with one
       argument, an <i>option</i> name, returns a list describing the
       option, as Tk widgets do; if called with no arguments, returns
       a list of lists describing all options, as Tk widgets do.<p>

       Two warnings.  First, unlike Tk widget options, locally-defined
       snit::type and snit::widget options do not have a "dbname" or
       "classname"; Snit never queries the Tk option database.  These
       fields in the returned information will be set to the empty
       string, {}.  Second, the information will be available for
       delegated options only if the component to which they are
       delegated has a "configure" method that returns this same kind
       of information.<p>

  <dt> <code><a name="$object">$object configurelist <i>optionlist</i></a></code>
  <dd> Like <code><a href="#configure">configure</a></code>, but takes one argument, a list of options and
       their values.  It's mostly useful in the type constructor, but
       can be used anywhere.<p>

  <dt> <code><a name="$object">$object cget <i>option</i></a></code>
  <dd> Returns the option's value.<p>

  <dt> <code><a name="$object">$object destroy</a></code>
  <dd> Destroys the object, calling the <code><a href="#destructor">destructor</a></code> and
       freeing all related memory.<p>

       <b>Note:</b> The "destroy" method isn't defined for
       <code><a href="#snit::widget">snit::widget</a></code> or <code><a href="#snit::widgetadaptor">snit::widgetadaptor</a></code>
       objects; instances of these are destroyed by calling the Tk
       "destroy" command, just as a normal widget is.<p>

  <dt> <code><a name="$object">$object info type</a></code>
  <dd> Returns the instance's type.<p>

  <dt> <code><a name="$object">$object info vars</a></code>
  <dd> Returns a list of the object's instance variables (excluding
       Snit internal variables).  The names are fully qualified.<p>

  <dt> <code><a name="$object">$object info typevars</a></code>
  <dd> Returns a list of the object's type's type variables (excluding
       Snit internal variables).  The names are fully qualified.<p>

  <dt> <code><a name="$object">$object info options</a></code>
  <dd> Returns a list of the object's option names.  This always
       includes local options and explicitly delegated options.  If
       unknown options are delegated as well, and if the component to
       which they are delegated responds to "$object configure" like Tk
       widgets do, then the result will include all possible unknown
       options which could be delegated to the component.<p>

       Note that the return value might be different for different
       instances of the same type, if component object types can vary
       from one instance to another.<p>
</dl>

<h3><a name="commands_for_use_in_object_code">Commands for use in Object Code</a></h3>

Snit defines the following commands for use in object code:
type methods, instance methods, constructors, destructors, onconfigure
handlers, oncget handlers, and procs.  They do not reside in the
::snit:: namespace; instead, they are created with the type, and are
directly available.

<dl>
  <dt> <code><a name="varname">varname <i>name</i></a></code>
  <dd> Given an instance variable name, returns the fully qualified
       name.  Use this if you're passing the variable to some other
       object, e.g., as a -textvariable to a Tk label widget.<p>

  <dt> <code><a name="typevarname">typevarname <i>name</i></a></code>
  <dd> Given an type variable name, returns the fully qualified
       name.  Use this if you're passing the variable to some other
       object, e.g., as a -textvariable to a Tk label widget.<p>

  <dt> <code><a name="codename">codename <i>name</i></a></code>
  <dd> Given the name of a proc (but not a type or instance
       method), returns the fully-qualified command name,
       suitable for passing as a callback.<p>

  <dt> <code><a name="from">from <i>argvName</i> <i>option</i> ?<i>defvalue</i>?</a></code>
  <dd> The <code><a href="#from">from</a></code> command plucks an option value from a list of
       options and their values, such as is passed into a
       type's <code><a href="#constructor">constructor</a></code>.  <i>argvName</i> must be the name
       of a variable containing such a list; <i>option</i> is the name
       of the specific option.<p>

       <code><a href="#from">from</a></code> looks for <i>option</i> in the option list.  If
       it is found, it and its value are removed from the list, and
       the value is returned.  If <i>option</i> doesn't appear in the
       list, then the <i>defvalue</i> is returned.  If the option is a
       normal (undelegated) option, and <i>defvalue</i> is not
       specified, then the option's default value as specified in the
       type definition will be returned instead.<p>
       
  <dt> <code><a name="variable">variable <i>name</i></a></code>
  <dd> Normally, instance variables are defined in the type definition
       along with the options, methods, and so forth; such instance
       variables are automatically visible in all instance-specific
       code.  However, instance code (e.g., method bodies) can declare
       such variables explicitly using the <code><a href="#variable">variable</a></code> command, if
       desired; or, instance code can use the <code><a href="#variable">variable</a></code>
       command to declare instance variables that don't appear in the
       type definition.<p>

       It's generally best to define all instance variables in the
       type definition, and omit declaring them in methods and so forth.<p>

       Note that this is not the same as the standard Tcl "::variable"
       command.<p>

  <dt> <code><a name="typevariable">typevariable <i>name</i></a></code>
  <dd> Normally, type variables are defined in the type definition,
       along with the instance variables; such type variables are
       automatically visible in all of the type's code.  However, type
       methods, instance methods and so forth can use
       <code><a href="#typevariable">typevariable</a></code> to declare type variables explicitly, if
       desired; or, they can use <code><a href="#typevariable">typevariable</a></code> to declare
       type variables that don't appear in the type definition.<p>

       It's generally best to declare all type variables in the type
       definition, and omit declaring them in methods, type methods,
       and so forth.

  <dt> <code><a name="installhull">installhull <i>name</i></a></code>
  <dd> The constructor of a <code><a href="#snit::widgetadaptor">snit::widgetadaptor</a></code> must create
       a widget to be the object's hull component; the widget is
       installed as the hull component using this command.  Note that
       the installed widget's name must be "$win".<p>

       The command which creates the hull widget usually just passes
       its result to <code><a href="#installhull">installhull</a></code> as follows:<p>

       <pre>installhull [frame $win <i>options....</i>[</pre><p>
</dl>

<h3><a name="components_and_delegation">Components and Delegation</a></h3>

When an object includes other objects, as when a toolbar contains
buttons or a GUI object contains an object that references a database,
the included object is called a component.  The standard way to handle
component objects owned by a Snit object is to assign their names to a
instance variable.  In the following example, a <code>dog</code> object
has a <code>tail</code> object:<p>

<pre>
snit::type dog {
    variable mytail

    constructor {args} {
        set mytail [tail %AUTO% -partof $self]
        $self configurelist $args
    }

    method wag {} {
        $mytail wag
    }
}

snit::type tail {
    option -length 5
    option -partof
    method wag {} { return "Wag, wag, wag."}
}
</pre>

Because the <code>tail</code> object's name is stored in an instance
variable, it's easily accessible in any method.<p>

In the above example, the <code>dog</code> object's "wag" method
simply calls the <code>tail</code> component's "wag" method.  In OO
circles, this is called delegation.  Snit provides an easier way to do
this, as shown:<p>

<pre>
snit::type dog {
    delegate method wag to mytail

    constructor {args} {
        set mytail [tail %AUTO% -partof $self]
        $self configurelist $args
    }
}

snit::type tail {
    option -length 5
    option -partof
    method wag {} { return "Wag, wag, wag."}
}
</pre>

The <code>delegate</code> statement in the type definition implicitly
defines the instance variable <code>mytail</code> to hold the
component's name; it also defines the <code>dog</code> object's "wag"
method, delegating it to the <code>tail</code> component.<p>

<h2><a name="known_bugs">KNOWN BUGS</a></h2>

<ul>
  <li> Error stack traces returned by Snit are extremely ugly and
       typically contain far too much information about Snit internals.<p>
</ul>

<h2><a name="history">HISTORY</a></h2>

During the course of developing
<a href="http://www.wjduquette.com/notebook">Notebook</a>, my Tcl-based personal
notebook application, I found I was writing it as a collection of
objects.  I wasn't using any particular object-oriented framework; I
was just writing objects in pure Tcl following the guidelines in my
<a href="http://www.wjduquette.com/tcl/objects.html">Guide to Object Commands</a>,
along with a few other tricks I'd picked up since.  And it was working
very well.  But on the other hand, it was getting tiresome.  Writing
objects in pure Tcl is straightforward, once you figure it out, but
there's a fair amount of boilerplate code to write for each one,
especially if you're trying to create megawidgets or create objects
with options, like Tk widgets have..<p>

So that was one thing--tedium is a powerful motivator.  But the other
thing I noticed is that I wasn't using inheritance at all, and I
wasn't missing it.  Instead, I was using delegation: objects that
created other objects and delegated methods to them.<p>

And I said to myself, "This is getting tedious...there has got to be
a better way."  And one afternoon, on a whim, I started working on Snit,
an object system that works the way Tcl works.  Snit doesn't support
inheritance, but it's great at delegation, and it makes creating
megawidgets easy.<p>

I should add, I'm not particularly down on Incr Tcl.  But "Snit's Not
Incr Tcl" occurred to me while I was casting about for a name, and I
guess there was a certainly inevitability about it.<p>

If you have any comments or suggestions (or bug reports!) don't
hesitate to send me e-mail at <a href="mailto:will@wjduquette.com">will@wjduquette.com</a>.  In
addition, there's now a Snit mailing list; you can find out more about
it at the Snit home page, <a href="http://www.wjduquette.com/snit">http://www.wjduquette.com/snit</a>.<p>

<h2><a name="credits">CREDITS</a></h2>

Snit has been designed and implemented from the very beginning by
William H. Duquette.  However, much credit belongs to the following
people for using Snit and providing me with valuable feedback: Rolf
Ade, Colin McCormack, Jose Nazario, Jeff Godfrey, Maurice Diamanti,
Egon Pasztor, David S. Cargo, Tom Krehbiel, and Michael Cleverly.


<p><hr><p>
Copyright &copy; 2003, by William H. Duquette.  All rights reserved.<p>


</body>
</html>
