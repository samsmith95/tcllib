#!/usr/bin/env tclsh
## -*- tcl -*-

package require Tcl 8.5
package require fileutil
package require sha1

# This application stores received nntp messages into a named directory.
# That name is specified on the command line.
# The article is read from stdin.
#
# The application supports the API expected by 'pullnews' for saving
# and id handling.

# Signature (syntax) of the storage command:
#
# (1) <cmd> last      => Returns last id processed.
# (2) <cmd> names     => Returns list of all known ids
# (3) <cmd> save <id> => Take message through stdin, and save, mark <id> as last.
# (4) <cmd> get  <id> => Return message <id> through stdout.
# (5) <cmd> has  <id> => Return boolean indicating existence of message <id>
#
# Here, <cmd> = dirstore <path-to-archive-directory>

proc main {} {
    if {![cmdline]} usage
    $::method
}

proc cmdline {} {
    global argv directory method theid theid

    if {[llength $argv] < 2} {return 0}

    # Retrieve arguments
    lassign $argv directory method

    if {$method ni {last save get has names}} {return 0}

    if {$method in {save get has}} {
	if {[llength $argv] != 3} {return 0}
	set theid [lindex $argv 2]
    } else {
	if {[llength $argv] != 2} {return 0}
    }

    validatedir store $directory
    return 1
}

proc validatedir {which path} {
    if {![file exists      $path]} { stop "$which does not exist: $path" }
    if {![file isdirectory $path]} { stop "$which not a file: $path" }
    if {![file readable    $path]} { stop "$which not readable: $path" }
    if {![file writable    $path]} { stop "$which not writable: $path" }
}

proc usage {} {
    global argv0
    puts stderr "$argv0: wrong # args, should be \"$argv0 <directory> last|names|(save <id>)|(get <id>)\""
    exit 1
}

proc stop {text} {
    global argv0
    puts stderr "$argv0: $text"
    exit 1
}

proc last {} {
    global directory
    if {![file exists $directory/last]} {
	set id {}
    } else {
	set id [string trim [fileutil::cat $directory/last]]
    }
    puts $id
    return
}

proc names {} {
    global directory
    set ids {}
    if {[file exists $directory]} {
	foreach id [lsort -dict [glob -nocomplain -directory $directory -tails q*]] {
	    lappend ids [string range $id 1 end]
	}
    }
    puts [join $ids \n]
    return
}

proc save {} {
    global directory theid

    set dst [open $directory/current w]
    fcopy stdin $dst
    close $dst
    file rename -force $directory/current $directory/q$theid

    fileutil::writeFile $directory/last $theid
    return
}

proc get {} {
    global directory theid

    set src [open $directory/q$theid r]
    fcopy $src stdout
    close $src
    return
}

proc has {} {
    global directory theid
    puts -nonewline stdout [file exists  $directory/q$theid]
    return
}

main
exit
