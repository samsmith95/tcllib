# jsonc.tcl --
#
#       Implementation of a JSON parser in C, binding to the json-c library.
#       See c/README-tcllib for notes on origin.
#
# Copyright (c) 2013 - critcl wrapper - Andreas Kupries <andreas_kupries@users.sourceforge.net>
# Copyright (c) 2013 - C binding      - mi+tcl.tk-2013@aldan.algebra.com

package require critcl
# @sak notprovided jsonc
package provide jsonc 1
package require Tcl 8.4

critcl::cheaders -Ic c/*.h
critcl::csources c/*.c

# # ## ### Import base declarations, forwards ### ## # #

critcl::ccode {
    #include <string.h>
    #include <json.h>

    #define assert(x) if (!(x)) { Tcl_Panic ("failed jsonc assert (" #x ")"); }

    static Tcl_Obj *value2obj      (Tcl_Interp *, struct json_object *);
    static Tcl_Obj *lazy_value2obj (Tcl_Interp *, struct json_object *);

    static Tcl_FreeInternalRepProc jsoncfree;
    static Tcl_DupInternalRepProc  jsoncdup;
    static Tcl_UpdateStringProc    jsonc2string;
}

# # ## ### Tcl_ObjType 'json-c' ### ## # #

# Note: Without a set-from-any function the only way of creating
# Tcl_Obj* with type 'json-c' is through function 'jsonNewObj'. It is
# not possible to generate it from an arbitrary string. It has to be
# done through the 'json2dict' command.

critcl::ccode {
    static Tcl_ObjType json_t = {
	"json-c",      /* name */
	jsoncfree,     /* freeIntRepProc */
	jsoncdup,      /* dupIntRepProc */
	jsonc2string,  /* updateStringProc */
	NULL           /* setFromAnyProc */
    };

    #define tcl2jso(O) (O->internalRep.twoPtrValue.ptr1)

    static void
    jsoncfree(Tcl_Obj *O)
    {
	assert(O->typePtr == &json_t);
	json_object_put(tcl2jso(O));
    }

    static void
    jsoncdup(Tcl_Obj *src, Tcl_Obj *dst)
    {
	assert(src->typePtr == &json_t);
	dst->bytes = src->bytes;
	dst->length = src->length;
	dst->typePtr = &json_t;
	Tcl_IncrRefCount(src);
    }

    static void
    jsonc2string(Tcl_Obj *O)
    {
	json_object	*jso = tcl2jso(O);
	Tcl_Obj     	*copy;

	assert(O->typePtr == &json_t);

	/* The string representation is generated by going through
	 * a helper generated from the json with an appropriate
	 * standard type (string, int, bool, dict, list) and taking
	 * its contents. Note that not only the helper's string rep
	 * is taken, but its internal rep as well, shimmering this
	 * object to the type.
	 *
	 * Q (AK): Why shimmer this way?
	 */

	copy = value2obj(NULL, jso);

	O->typePtr = copy->typePtr;
	O->bytes = Tcl_GetStringFromObj(copy, &O->length);
	memcpy(&O->internalRep, &copy->internalRep, sizeof(O->internalRep));

	json_object_put(jso);

	copy->bytes = NULL;
	copy->length = 0;
	copy->typePtr = NULL;
	Tcl_DecrRefCount(copy);
    }

    static Tcl_Obj *
    jsoncNewObj(struct json_object *jso)
    {
	Tcl_Obj	*result = Tcl_NewObj();

	result->bytes = NULL;
	result->typePtr = &json_t;
	tcl2jso(result) = json_object_get(jso);

	return result;
    }
}

# # ## ### Main Conversion ### ## # #

critcl::ccode {
    static Tcl_Obj *
    lazy_value2obj(Tcl_Interp *I, struct json_object *jso)
    {
	switch (json_object_get_type(jso)) {
	case json_type_object:
	case json_type_array:
	    /* Defer further construction, encapsulate the value into a 'json-c'
	     * representation.
	     */
	    return jsoncNewObj(jso);
        default:
	    return value2obj(I, jso);
	}	
    }

    static Tcl_Obj *
    value2obj(Tcl_Interp *I, struct json_object *jso)
    {
	struct array_list* ar;
	int                len;
	Tcl_Obj*           key;
	Tcl_Obj*           result;
	Tcl_Obj*           value;

	switch (json_object_get_type(jso)) {
	    case json_type_object: {
		/* Using List API here for compat with Tcl 8.4. */
		result = Tcl_NewListObj(0, NULL);

		json_object_object_foreach(jso, k, v) {
		    key   = Tcl_NewStringObj(k, -1);
		    value = lazy_value2obj(I, v);

		    Tcl_ListObjAppendElement(I, result, key);
		    Tcl_ListObjAppendElement(I, result, value);
		    json_object_object_del(jso, k);
		}
		return result;
	    }

	    case json_type_null: {
		return Tcl_NewStringObj("null",-1);
	    }

	    case json_type_boolean: {
		return Tcl_NewBooleanObj(json_object_get_boolean(jso));
	    }

	    case json_type_double: {
		return Tcl_NewDoubleObj(json_object_get_double(jso));
	    }

	    case json_type_int: {
		return Tcl_NewLongObj(json_object_get_int64(jso));
	    }

	    case json_type_array: {
		ar     = json_object_get_array(jso);
		result = Tcl_NewListObj(0, NULL);

		for (len = 0; len < ar->length; len++) {
		    value = lazy_value2obj(I, ar->array[len]);
		    Tcl_ListObjAppendElement(I, result, value);
		}
		return result;
	    }

	    case json_type_string: {
		len = json_object_get_string_len(jso);
		return Tcl_NewStringObj(json_object_get_string(jso), len);
	    }
	}
	return NULL; /* unreachable */
    }
}

namespace eval ::json {
    critcl::ccommand json2dict_critcl {dummy I objc objv} {
	struct json_tokener	*tok;
	enum json_tokener_error	 jerr;
	struct json_object	*parsed;
	const char		*text;
	int       		 len;

	if (objc != 2) {
	    Tcl_WrongNumArgs(I, 1, objv, "json");
	    return TCL_ERROR;
	}

	text   = Tcl_GetStringFromObj(objv[1], &len);
	tok    = json_tokener_new();
	parsed = json_tokener_parse_ex(tok, text, len);

	if (parsed == NULL) {
	    jerr = json_tokener_get_error(tok);
	    Tcl_SetResult(I,
			  (void *)json_tokener_error_desc(jerr),
			  TCL_STATIC);
	    json_tokener_free(tok);
	    return TCL_ERROR;
	}
	json_tokener_free(tok);

	Tcl_SetObjResult(I, value2obj(I, parsed));

	json_object_put(parsed);
	return TCL_OK;
    }

    critcl::ccommand many-json2dict_critcl {dummy I objc objv} {
	struct json_tokener	*tok;
	enum json_tokener_error	 jerr;
	struct json_object	*parsed;
	const char		*text;
	int       		 len;
	int                      max;
	int                      found;

	Tcl_Obj* result = Tcl_NewListObj(0, NULL);

	if ((objc < 2) || (objc > 3)) {
	    Tcl_WrongNumArgs(I, 1, objv, "jsonText ?max?");
	    return TCL_ERROR;
	}

	if (objc == 3) {
	    if (Tcl_GetIntFromObj(I, objv[2], &max) != TCL_OK) {
		return TCL_ERROR;
	    }
	    if (max <= 0) {
		Tcl_AppendResult (I, "Bad limit ",
				  Tcl_GetString (objv[2]),
				  " of json entities to extract.",
				  NULL);
		Tcl_SetErrorCode (I, "JSON", "BAD-LIMIT", NULL);
		return TCL_ERROR;
	    }

	} else {
	    max = -1;
	}

	text   = Tcl_GetStringFromObj(objv[1], &len);
	tok    = json_tokener_new();
	found  = 0;

	/* Iterate over the input until
	 * - we have gotten all requested values.
	 * - we have run out of input
	 * - we have run into an error
	 */

	while ((max < 0) || max) {
	    parsed = json_tokener_parse_ex(tok, text, len);

	    /* parse error, abort */
	    if (parsed == NULL) {
		jerr = json_tokener_get_error(tok);
		Tcl_SetResult(I,
			      json_tokener_error_desc(jerr),
			      TCL_STATIC);

		json_tokener_free(tok);
		Tcl_DecrRefCount (result);
		return TCL_ERROR;
	    }

	    /* Proper value extracted, extend result */
	    found ++;
	    Tcl_ListObjAppendElement(I, result,
				     value2obj(I, parsed));
	    json_object_put(parsed);

	    /* Count down on the number of still missing
	     * values, if not asking for all (-1)
	     */
	    if (max > 0) max --;

	    /* Abort if we have consumed all input */
	    if (tok->char_offset >= len) break;

	    /* Skip over consumed text for next parse */
	    text += tok->char_offset;
	    len  -= tok->char_offset;
	}

	json_tokener_free(tok);

	/* While all parse were ok we reached end of
	 * input without getting all requested values,
	 * this is an error
	 */
	if (max > 0) {
	    char buf [30];
	    sprintf (buf, "%d", found);
	    Tcl_AppendResult (I, "Bad limit ",
			      Tcl_GetString (objv[2]),
			      " of json entities to extract, found only ",
			      buf,
			      ".",
			      NULL);
	    Tcl_SetErrorCode (I, "JSON", "BAD-LIMIT", "TOO", "LARGE", NULL);
	    Tcl_DecrRefCount (result);
	    return TCL_ERROR;
	}

	/* We are good and done */
	Tcl_SetObjResult(I, result);
	return TCL_OK;
    }

    critcl::ccommand validate_critcl {dummy I objc objv} {
	struct json_tokener	*tok;
	enum json_tokener_error	 jerr;
	struct json_object	*parsed;
	const char		*text;
	int       		 len;
	int                      max;
	int                      found;

	if (objc != 2) {
	    Tcl_WrongNumArgs(I, 1, objv, "jsonText");
	    return TCL_ERROR;
	}

	text   = Tcl_GetStringFromObj(objv[1], &len);
	tok    = json_tokener_new();

	/* Iterate over the input until we have run
	 * out of text, or encountered an error
	 */

	while (1) {
	    parsed = json_tokener_parse_ex(tok, text, len);

	    /* parse error, abort, not valid */
	    if (parsed == NULL) {
		json_tokener_free(tok);
		Tcl_SetObjResult(I, Tcl_NewBooleanObj (0));
		return TCL_OK;
	    }
	    json_object_put(parsed);

	    /* Abort if we have consumed all input */
	    if (tok->char_offset >= len) break;

	    /* Skip over consumed text for next parse */
	    text += tok->char_offset;
	    len  -= tok->char_offset;
	}

	json_tokener_free(tok);

	/* We are good and done */
	Tcl_SetObjResult(I, Tcl_NewBooleanObj (1));
	return TCL_OK;
    }
}
