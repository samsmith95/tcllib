# jsonc.tcl --
#
#       Implementation of a JSON parser in C, binding to the json-c library.
#       See c/README-tcllib for notes on origin.
#
# Copyright (c) 2013 - critcl wrapper - Andreas Kupries <andreas_kupries@users.sourceforge.net>
# Copyright (c) 2013 - C binding      - mi+tcl.tk-2013@aldan.algebra.com

package require critcl
# @sak notprovided jsonc
package provide jsonc 1
package require Tcl 8.4

## Parts still written in Tcl.
critcl::tsources jsonc_tcl.tcl

critcl::cheaders -Ic c/*.h
critcl::csources c/*.c

# # ## ### Import base declarations, forwards ### ## # #

critcl::ccode {
    #include <string.h>
    #include <json.h>

    #define assert(x) if (!(x)) { Tcl_Panic ("failed jsonc assert (" #x ")"); }

    static Tcl_Obj *value2obj      (Tcl_Interp *, struct json_object *);
    static Tcl_Obj *lazy_value2obj (Tcl_Interp *, struct json_object *);

    static Tcl_FreeInternalRepProc jsoncfree;
    static Tcl_DupInternalRepProc  jsoncdup;
    static Tcl_UpdateStringProc    jsonc2string;
}

# # ## ### Tcl_ObjType 'json-c' ### ## # #

# Note: Without a set-from-any function the only way of creating
# Tcl_Obj* with type 'json-c' is through function 'jsonNewObj'. It is
# not possible to generate it from an arbitrary string. It has to be
# done through the 'json2dict' command.

critcl::ccode {
    static Tcl_ObjType json_t = {
	"json-c",      /* name */
	jsoncfree,     /* freeIntRepProc */
	jsoncdup,      /* dupIntRepProc */
	jsonc2string,  /* updateStringProc */
	NULL           /* setFromAnyProc */
    };

    #define tcl2jso(O) (O->internalRep.twoPtrValue.ptr1)

    static void
    jsoncfree(Tcl_Obj *O)
    {
	assert(O->typePtr == &json_t);
	json_object_put(tcl2jso(O));
    }

    static void
    jsoncdup(Tcl_Obj *src, Tcl_Obj *dst)
    {
	assert(src->typePtr == &json_t);
	dst->bytes = src->bytes;
	dst->length = src->length;
	dst->typePtr = &json_t;
	Tcl_IncrRefCount(src);
    }

    static void
    jsonc2string(Tcl_Obj *O)
    {
	json_object	*jso = tcl2jso(O);
	Tcl_Obj     	*copy;

	assert(O->typePtr == &json_t);

	/* The string representation is generated by going through
	 * a helper generated from the json with an appropriate
	 * standard type (string, int, bool, dict, list) and taking
	 * its contents. Note that not only the helper's string rep
	 * is taken, but its internal rep as well, shimmering this
	 * object to the type.
	 *
	 * Q (AK): Why shimmer this way?
	 */

	copy = value2obj(NULL, jso);

	O->typePtr = copy->typePtr;
	O->bytes = Tcl_GetStringFromObj(copy, &O->length);
	memcpy(&O->internalRep, &copy->internalRep, sizeof(O->internalRep));

	json_object_put(jso);

	copy->bytes = NULL;
	copy->length = 0;
	copy->typePtr = NULL;
	Tcl_DecrRefCount(copy);
    }

    static Tcl_Obj *
    jsoncNewObj(struct json_object *jso)
    {
	Tcl_Obj	*result = Tcl_NewObj();

	result->bytes = NULL;
	result->typePtr = &json_t;
	tcl2jso(result) = json_object_get(jso);

	return result;
    }
}

# # ## ### Main Conversion ### ## # #

critcl::ccode {
    static Tcl_Obj *
    lazy_value2obj(Tcl_Interp *I, struct json_object *jso)
    {
	switch (json_object_get_type(jso)) {
	case json_type_object:
	case json_type_array:
	    /* Defer further construction, encapsulate the value into a 'json-c'
	     * representation.
	     */
	    return jsoncNewObj(jso);
        default:
	    return value2obj(I, jso);
	}	
    }

    static Tcl_Obj *
    value2obj(Tcl_Interp *I, struct json_object *jso)
    {
	switch (json_object_get_type(jso)) {
	    case json_type_object: {
		/* Using List API here for compat with Tcl 8.4. */

		Tcl_Obj* result = Tcl_NewListObj(0, NULL);
		Tcl_Obj* key;
		Tcl_Obj* value;

		json_object_object_foreach(jso, k, v) {
		    key   = Tcl_NewStringObj(k, -1);
		    value = lazy_value2obj(I, v);

		    Tcl_ListObjAppendElement(I, result, key);
		    Tcl_ListObjAppendElement(I, result, value);
		    json_object_object_del(jso, k);
		}
		return result;
	    }

	    case json_type_null: {
		return Tcl_NewStringObj("null",-1);
	    }

	    case json_type_boolean: {
		return Tcl_NewBooleanObj(json_object_get_boolean(jso));
	    }

	    case json_type_double: {
		return Tcl_NewDoubleObj(json_object_get_double(jso));
	    }

	    case json_type_int: {
		return Tcl_NewLongObj(json_object_get_int64(jso));
	    }

	    case json_type_array: {
		int len;
		struct array_list *ar = json_object_get_array(jso);
		Tcl_Obj* value;
		Tcl_Obj* result = Tcl_NewListObj(0, NULL);

		for (len = 0; len < ar->length; len++) {
		    value = lazy_value2obj(I, ar->array[len]);
		    Tcl_ListObjAppendElement(I, result, value);
		}
		return result;
	    }

	    case json_type_string: {
		int len = json_object_get_string_len(jso);
		return Tcl_NewStringObj(json_object_get_string(jso), len);
	    }
	}
	return NULL; /* unreachable */
    }
}

namespace eval ::json {
    critcl::ccommand json2dict_critcl {dummy I objc objv} {

	struct json_tokener	*tok;
	enum json_tokener_error	 jerr;
	struct json_object	*parsed;
	const char		*text;
	int       		 len;

	if (objc != 2) {
	    Tcl_WrongNumArgs(I, 1, objv, "json");
	    return TCL_ERROR;
	}

	text   = Tcl_GetStringFromObj(objv[1], &len);
	tok    = json_tokener_new();
	parsed = json_tokener_parse_ex(tok, text, len);

	if (parsed == NULL) {
	    jerr = json_tokener_get_error(tok);
	    Tcl_SetResult(I,
			  (void *)json_tokener_error_desc(jerr),
			  TCL_STATIC);
	    json_tokener_free(tok);
	    return TCL_ERROR;
	}
	json_tokener_free(tok);

	Tcl_SetObjResult(I, value2obj(I, parsed));

	json_object_put(parsed);
	return TCL_OK;
    }
}
