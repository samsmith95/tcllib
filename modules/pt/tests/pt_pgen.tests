# -*- tcl -*-
# Testsuite for pt::pgen.
# Called by the ../pt_pgen.test driver file.

#----------------------------------------------------------------------
## I. Testing the generator operation itself

# TODO testing of the pt::pgen command API (#args, options, outputs) ...

#----------------------------------------------------------------------
## II. Using generated parsers to test behaviour on good and bad
##     input, i.e. the error handling implemented in our PEG parsers.

## See data/gr/README.txt for the documentation of the directory
## structure used to organize the test-cases used here.

foreach {format notes} {
    container {grammar interpreter - reference}
    snit      {snit::type Tcl parser}
    oo        {TclOO class Tcl parser}
    critcl    {PARAM based C class parser}
} {
    # Ignore critcl-based parsers if the environment does not support
    # their generation (no critcl package).
    if {$format eq "critcl" &&
	![tcltest::testConstraint critcl]} continue

    TestFilesProcessIn $mytestdir gr def -> n glabel grfile grdata {
	# Make parser instance. Shared across tests. Amortize the time
	# spent on dynamically making it.
	set p [make-parser $format $glabel $grdata]

	# Test parser on good inputs for the grammar.
	TestFilesProcess $mytestdir gr ok-${glabel} ok-${glabel}-res -> k label infile text expected {
	    test pt-pgen-parse:${parseimpl}-rde:${rdeimpl}-stack:${stackimpl}-f:${format}-g:${glabel}-t:${label}-1.$n.$k \
		"$format parser $glabel, good input - $label" -setup {
		} -body {
		    $p parset $text
		} -result $expected
	}

	# Test parser on bad inputs for the grammar.
	##
	# Note how the expected output depends not only on grammar,
	# but the parser format as well. Different optimizations and
	# such leading to different instructions implementing matches.
	# Example: "next_str" vs. "sequence of next_char".

	TestFilesProcess $mytestdir gr fail-${glabel} fail-${glabel}-${format}-res -> k label infile text expected {
	    test pt-pgen-parse:${parseimpl}-rde:${rdeimpl}-stack:${stackimpl}-f:${format}-g:${glabel}-t:${label}-2.$n.$k \
		"$format parser $glabel, bad input - $label" -setup {
		} -body {
		    set code [catch {
			$p parset $text
		    } msg]
		    # msg = list ("pt::rde" location list(msg))
		    # Sort the messages for a canonical result.
		    # NOTE: The data out of the RDE/critcl is sorted
		    # by msg id, that is not necessarily
		    # lexicographical, nor matching the Tcl results.
		    lassign $msg tag loc mlist
		    set msg [list $tag $loc [lsort -dict $mlist]]

		    # TODO: Convert message to readable.
		    list $code $msg
		} -result $expected
	} yes ;# Allow missing testsets, for two reasons:
	#      # (a) Easier during testsuite development, allowing incremental buildup
	#      # (b) Some grammar construction *cannot* fail (Ex: x*), thus we cannot provide
	#      #     failure cases either.

	# Kill shared parser instance.
	$p destroy
    }

    # Testing the handling of generated parsers for single
    # characters, for characters special to Tcl, C, and
    # PEGs. I.e. ensure that the various forms of quoting are done
    # correctly.

    # Grammar for all test cases below, with the actual character
    # mapped in (replacing @).
    set gtemplate "PEG a_pe_grammar ('@') END;"
    set etemplate "Parse error at position 0 (Line 0, column 0).\n... X ...\n    ^\nExpected one of\n* The character '@'\n"

    # Table of test cases ...
    #             Id PEG     InText Error detail
    lappend chars  0 \{      \{     [list t \{]     \{
    lappend chars  1 \[      \[     [list t \[]     \[
    lappend chars  2 \"      \"     [list t \"]     \"
    lappend chars  3 \\033   \033   [list t \33]    <ESC>
    lappend chars  4 \\n     \n     [list t \n]     <LF>
    lappend chars  5 \\r     \r     [list t \r]     <CR>
    lappend chars  6 \\t     \t     [list t \t]     <TAB>
    # \b, \f, \v - Extend PEG grammar to recognize. Also \e = \33
    lappend chars  7 \\010   \b     [list t \b]     <BS>
    lappend chars  8 \\014   \f     [list t \f]     <FF>
    lappend chars  9 \\013   \v     [list t \v]     <VTAB>
    lappend chars 10 \\007   \a     [list t \a]     <BEL>
    lappend chars 11 { }     { }    [list t { }]    <SPACE>
    lappend chars 12 \\\\    \\     [list t \\]     \\
    # math symbol, circled asterix
    lappend chars 13 \\u229b \u229b [list t \u229b] \u229b
    # test all control characters ... (and DEL)
    # more characters: above ascii = unicode BMP.

    foreach {n peg input message hmsg} $chars {
	set glabel "T_$hmsg"
	set grdata [string map [list @ $peg]  $gtemplate]
	set edata  [string map [list @ $hmsg] $etemplate]

	# Make parser instance. Shared across tests.
	# Amortize the time spent on dynamically making it.
	set p [make-parser $format $glabel $grdata]

	test pt-pgen-parse:${parseimpl}-rde:${rdeimpl}-stack:${stackimpl}-f:${format}-g:${glabel}-3.$n \
	    "$format parser $glabel, good input" -setup {
	    } -body {
		$p parset $input
	    } -result {}

	test pt-pgen-parse:${parseimpl}-rde:${rdeimpl}-stack:${stackimpl}-f:${format}-g:${glabel}-4.$n \
	    "$format parser $glabel, bad input, tcl error" -setup {
	    } -body {
		set code [catch {
		    $p parset X
		} msg]
		lassign $msg tag loc mlist
		list $tag $loc [lsort -dict $mlist]
	    } -result [list pt::rde 0 [list $message]]

	test pt-pgen-parse:${parseimpl}-rde:${rdeimpl}-stack:${stackimpl}-f:${format}-g:${glabel}-5.$n \
	    "$format parser $glabel, bad input, readable error" -setup {
	    } -body {
		set code [catch {
		    $p parset X
		} msg]
		lassign $msg tag loc mlist
		pt::util::error2readable [list $tag $loc [lsort -dict $mlist]] X
	    } -result $edata

	# Kill shared parser instance.
	$p destroy
    }

}


#----------------------------------------------------------------------
