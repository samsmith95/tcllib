# -*- tcl -*-
#
# fmt.nroff
#
# (c) 2002 Andreas Kupries <andreas_kupries@sourceforge.net>
#
# [expand] definitions to convert a tcl based manpage definition into
# Wiki markup.
#
################################################################

proc here {} [list return [__file dirname [info script]]]
proc this {} [list return [__file tail    [info script]]]

source [__file join [here] _common.tcl]   ; # Shared code

################################################################
## Backend for *roff markup

proc manpage_begin {title section version} {
    if {[mp_pass] == 1} {return}

    set module      [mp_module]
    set shortdesc   [GetDesc mdesc]
    set description [GetDesc tdesc]

    cpush mp
    set     hdr ""
    append  hdr "$title $version '''$module''' ''$shortdesc''" \n
    append  hdr \n
    append  hdr "$description"
    append  hdr \n
    return $hdr
}

proc moddesc {desc} {
    if {[mp_pass] == 2} {return}
    SetDesc mdesc $desc
    return
}
proc titledesc {desc} {
    if {[mp_pass] == 2} {return}
    SetDesc tdesc $desc
    return
}

proc manpage_end {} {
    # Strip empty lines out of the generated nroff source
    # and trim leading blanks, except in code samples.
    #
    if {[mp_pass] == 1} {return}

    set lines [list]
    foreach line [split [cpop mp] \n] {
	if {[string match " |*" $line]} {
	    lappend lines [string trimright $line]
	} elseif {[string match "   \* *" $line]} {
	    lappend lines [string map {[ [[ ] ]]} [string trimright $line]]
	} elseif {[string match "   1. *" $line]} {
	    lappend lines [string map {[ [[ ] ]]} [string trimright $line]]
	} elseif {[regexp "^   (\[^:\]): " $line]} {
	    lappend lines [string map {[ [[ ] ]]} [string trimright $line]]
	} elseif {[string match " *" $line]} {
	    lappend lines [string map {[ [[ ] ]]} [string trim $line]]
	} else {
	    lappend lines [string map {[ [[ ] ]]} [string trimright $line]]
	}
    }
    return [join $lines \n]\n
}

proc section {name} {return "\n\n----\n'''$name'''\n\n"}
proc para    {}     {return \n}

proc require {pkg {version {}}} {
    if {$version != {}} {
	return "[x_synopsis]package require '''$pkg $version'''\n\n"
    }
    return "[x_synopsis]package require '''$pkg'''\n\n"
}

proc usage {cmd args} {
    if {[mp_pass] == 1} {
	AddCall "   * $cmd [join $args " "]\n\n"
	return
    }
    return ""
}

proc call {cmd args} {
    if {[mp_pass] == 1} {
	AddCall "   * $cmd [join $args " "]\n\n"
	return
    }
    return "[lst_item "$cmd [join $args " "]"]"
}

proc description {} {
    if {[GetCall] == {}} {
	return [section DESCRIPTION]
    }
    return [x_synopsis][GetCall]\n[section DESCRIPTION]
}

proc x_synopsis {} {
    if {![Syn]} {
	return [section SYNOPSIS]\n
    }
    return ""
}

################################################################

global    list_state
array set list_state {level -1}

proc list_begin {what {hint {}}} {
    # ignoring hints.
    global list_state

    switch -exact -- $what {
	enum - bullet - definitions - arg - cmd -
	opt - tkoption {}
	default {return -code error "Unknown list type $what"}
    }

    incr list_state(level)
    set  list_state(l,$list_state(level)) $what
    set  list_state(l,$list_state(level),id) 0
    return {}
}

proc list_end {} {
    global list_state

    catch {unset list_state(l,$list_state(level))}
    catch {unset list_state(l,$list_state(level),id)}

    incr list_state(level) -1
    return {}
}

proc bullet {} {
    global list_state

    switch -exact -- $list_state(l,$list_state(level)) {
	bullet  {return "\n\n   * "}
	default {return -code error "Illegal use of bullet in non-bullet list"}
    }
}

proc enum {} {
    global list_state

    switch -exact -- $list_state(l,$list_state(level)) {
	enum    {return "\n\n   1. "}
	default {return -code error "Illegal use of bullet in non-bullet list"}
    }
}

proc lst_item {text} {
    global list_state

    switch -exact -- $list_state(l,$list_state(level)) {
	definitions {return "\n\n   $text: "}
	default     {return -code error "Illegal use of bullet in non-bullet list"}
    }
}

proc arg_def {type name {mode {}}} {
    global list_state

    switch -exact -- $list_state(l,$list_state(level)) {
	arg     {
	    set text "\n\n   "
	    append text [arg $name]
	    append text " $type"
	    if {$mode != {}} {append text " ($mode)"}
	    return "${text}: "
	}
	default {return -code error "Illegal use of arg_def in non-argument list"}
    }
}

proc cmd_def {command} {
    global list_state

    switch -exact -- $list_state(l,$list_state(level)) {
	cmd     {return "\n\n   [cmd $command]: "}
	default {return -code error "Illegal use of cmd_def in non-command list"}
    }
}

proc opt_def {name {arg {}}} {
    global list_state

    switch -exact -- $list_state(l,$list_state(level)) {
	opt {
	    if {[string match -* $name]} {set    name \\-$name}
	    set name [option $name]
	    if {$arg != {}}              {append name " $arg"}
	    return "\n\n   ${name}: "
	}
	default {return -code error "Illegal use of opt_def in non-option list"}
    }
}

proc tkoption_def {name dbname dbclass} {
    global list_state

    switch -exact -- $list_state(l,$list_state(level)) {
	tkoption {
	    set    text "\n\n"
	    append text "   Command-Line Switch:\t'''$name'''\n"
	    append text "   Database Name:\t'''$dbname'''\n"
	    append text "   Database Class:\t'''$dbclass'''\n"
	    append text "   * "
	    return $text
	}
	default {return -code error "Illegal use of tkoption_def in non-tkoption list"}
    }
}

################################################################

global textmode
set    textmode ""

proc see_also {args} {return "[section {SEE ALSO}]\n[join $args ", "]"}
proc keywords {args} {return "[section KEYWORDS]\n[join $args ", "]"}

proc example_begin {} {
    global  mode_save textmode
    lappend mode_save $textmode
    set     textmode example
    return ""
}
proc example_end   {} {
    global  mode_save textmode
    set textmode  [lindex $mode_save end]
    set mode_save [lrange $mode_save 0 end-1]
    return ""
}
proc example {code} { return ""
    set lines [list ""]
    foreach line [split $code "\n"] {
	set linex [string trim $line]
	if {$linex == {}} {lappend lines {} ; continue}
    	lappend lines " | $line"
    }
    lappend lines ""
    return [join $lines "\n"]
}

proc nl     {}     {return ""}
proc arg    {text} {return ''$text''}
proc cmd    {text} {return '''$text'''}
proc emph   {text} {return ''$text''}
proc strong {text} {return '''$text'''}
proc opt    {text} {return ?$text?}

proc comment {text} {
    return {}
}
proc sectref {text} {strong $text}
proc syscmd  {text} {strong $text}
proc method  {text} {strong $text}
proc option  {text} {strong $text}
proc widget  {text} {strong $text}
proc fun     {text} {strong $text}
proc type    {text} {strong $text}
proc package {text} {strong $text}
proc class   {text} {strong $text}
proc var     {text} {strong $text}
proc file    {text} {return "\"[emph $text]\""}
proc uri     {text} {emph $text}
proc term    {text} {emph $text}
proc const   {text} {strong $text}

################################################################
# wiki specific commands

proc HandleText {text} {
    # For the wiki we have to force certain text into a single line.
    # We also have to make sure that the text is on the same line as
    # the initiator (i.e. list bullet).

    global textmode

    if {"$textmode" == "example"} {
	set lines [list ""] 
	foreach line [split $text "\n"] {
	    set linex [string trim $line]
	    if {$linex == {}} {lappend lines {} ; continue}
	    lappend lines " | $line"
	}
	lappend lines ""
	return [join $lines "\n"]
    }

    regsub -all "\[ \t\n\]+" $text { } text
    return $text
}

################################################################

proc setx {v string} {
    upvar $v _
    set _ $string
    return
}

proc appendx {v string} {
    upvar $v _
    append _ $string
    return
}

################################################################
