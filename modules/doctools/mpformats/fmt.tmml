# -*- tcl -*-
#
# $Id: fmt.tmml,v 1.4 2002/02/13 23:20:18 jenglish Exp $
#
# [expand] definitions to convert a tcl based manpage definition
# into TMML.
#
# Copyright (C) 2001 Joe English <jenglish@sourceforge.net>.
# Freely redistributable.
#
# See also <URL: http://tmml.sourceforge.net>
#
# BUGS:
#	+ XML markup characters in [expand] macro arguments
#	  are not properly escaped.  (Plain text outside of
#	  [...] is handled correctly however.)
#
#	+ Text must be preceded by [para] or one of the
#	  list item macros, or else the output will be invalid.
#
######################################################################

source [file join [file dirname [info script]] _xml.tcl]
set this [file tail [info script]]

######################################################################
# mpexpand(n) interface.
#
proc NumPasses {}	{ return 2 }
proc PassSetup {}	{ setPassProcs [mp_pass] }
proc PostProcess {text}	{ return $text }
proc HandleText {text}	{ xmlEscape $text }

######################################################################
# Utilities.
#

proc NOP {args} { }		;# do nothing
proc NYI {{message {}}} {
    return -code error [append $message " Not Yet Implemented"]
}

proc provenance {} {
    variable this
    return "Generated from [mp_file] by tcllib/doctools/mpexpand with $this"
}


######################################################################
# Cross-reference tracking.
#

global SectionNames	;# array mapping section name to refid

# sectionId --
#	Format section name as an XML ID.
#
proc sectionId {name} {
    regsub -all {[^[:alnum:]]} $name {} name
    return [string tolower $name]
}

# possibleReference text gi --
#	Check if $text is a potential cross-reference;
#	if so, format as a reference;
#	otherwise format as a $gi element.
#
proc possibleReference {text gi} {
    global SectionNames
    if {[info exists SectionNames($text)]} {
    	return "[startTag ref refid $SectionNames($text)]$text[endTag ref]"
    } else {
    	return [wrap $text $gi]
    }
}

######################################################################
# Conversion specification.
#
# Two-pass processing.  The first pass collects text for the
# SYNOPSIS, SEE ALSO, and KEYWORDS sections, and the second pass
# produces output.
#

holdBuffers synopsis see_also keywords

variable block {section dd li}	;# block context elements

proc nl  	{}	{ emptyElement br }
proc arg 	{text}	{ wrap $text m }
proc cmd	{text}	{ wrap $text cmd }
proc emph	{text}	{ possibleReference $text emph }
proc strong	{text}	{ possibleReference $text emph }
proc opt 	{text}	{ wrap $text o }

proc example_begin {}	{ sequence [xmlContext $::block] [start example] }
proc example_end   {}	{ end example }

proc example {code} {
    sequence [xmlContext $::block] [wrap [HandleText $code] example] 
}

global    state
array set state {mdesc {}}

pass 1 manpage_begin {args} NOP
pass 2 manpage_begin {title section version} {
    global state
    if {[catch {set description $state(tdesc)}]} {
	set description $state(mdesc)
    }

    sequence \
	[xmlComment [provenance]] \
	[start manpage \
	    id  	[file root [file tail [mp_file]]] \
	    cat 	cmd \
	    title	$title \
	    version	$version \
	    package	[mp_module]] \
	[start namesection] \
	[wrap $title name] \
	[wrap $description desc] \
	[end namesection] \
	;
}

pass 1 moddesc     {desc} {global state ; set state(mesc)  $desc}
pass 1 titledesc   {desc} {global state ; set state(tdesc) $desc}

pass 2 moddesc     {args} NOP
pass 2 titledesc   {args} NOP

pass 1 description {} NOP
pass 2 description {} {
    sequence \
	[xmlContext manpage] \
	[wrapLines? [held synopsis] syntax synopsis] \
	[start section] \
	[wrap "DESCRIPTION" title] \
	;
}

pass 1 section {name} { set ::SectionNames($name) [sectionId $name] }
pass 2 section {name} {
    sequence \
	[xmlContext manpage] \
    	[start section id [sectionId $name]] \
	[wrap [string toupper $name] title] \
	;
}
pass 1 para {} NOP
pass 2 para {} { sequence [xmlContext section] [start p] }

array set listTypes {
    bullet	ul
    enum	ol
    definitions	dl
}
pass 1 list_begin {what} NOP
pass 1 list_end {} NOP
pass 2 list_begin {what} {
    variable listTypes
    sequence \
    	[xmlContext {section dd li}] \
	[start $listTypes($what)] \
	;
}
pass 2 list_end {} {
    sequence \
	[xmlContext {ul ol dl}] \
	[end] \
	;
}

pass 1 bullet {}	NOP
pass 1 enum {} 		NOP
pass 2 bullet {} 	{ sequence [xmlContext {ul ol}] [start li] }
pass 2 enum {} 		{ sequence [xmlContext {ul ol}] [start li] }

pass 1 lst_item {text} NOP
pass 2 lst_item {text} {
    sequence \
    	[xmlContext dl] \
	[start dle] \
	[wrap $text dt] \
	[start dd] \
	;
}

pass 1 call {cmd args} { hold synopsis [formatCall $cmd $args] }
pass 2 call {cmd args} {
    sequence \
    	[xmlContext dl] \
	[start dle] \
	[wrap [formatCall $cmd $args] dt] \
	[start dd] \
	;
}
proc formatCall {cmd arglist} {
    return "$cmd [join $arglist { }]"	;# OR: wrap "..." command
}

pass 1 require {pkg {version {}}} {
    hold synopsis [formatRequire $pkg $version]
}
pass 2 require {pkg {version {}}} NOP
proc formatRequire {pkg version} {
    return "package require [wrap $pkg package] $version"
}

pass 1 see_also	{args} { holdWrapped see_also  $args ref }
pass 1 keywords {args} { holdWrapped keywords $args keyword }
pass 2 see_also	{args} NOP
pass 2 keywords	{args} NOP

# holdWrapped --
#	Common factor of [see_also] and [keywords].
#
proc holdWrapped {buffer arglist gi} {
    foreach arg $arglist { hold $buffer [wrap $arg $gi] }
    return
}

pass 1 manpage_end {} NOP
pass 2 manpage_end {} {
    sequence \
	[xmlContext manpage] \
	[wrapLines? [held see_also] seealso] \
	[wrapLines? [held keywords] keywords] \
	[end manpage] \
	;
}

#*EOF*

